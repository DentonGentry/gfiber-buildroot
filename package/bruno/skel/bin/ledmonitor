#!/bin/sh
#
# This script monitors CONTROL_PATH folder and decides which is the
# led sequence that has to be echoed to the LEDS_FILE.

. /etc/utils.sh

# Output file.
BASE_PATH="/tmp/gpio"
LEDS_FILE="$BASE_PATH/leds"
CONTROL_PATH="$BASE_PATH/ledcontrol"

LEDSTATE_FILE="$BASE_PATH/ledstate"
IP_FILE="$BASE_PATH/ipconnected"
ACS_FILE="$CONTROL_PATH/acsconnected"
OVERTEMP_FILE="$CONTROL_PATH/overtemperature"
HDPAIRING_FILE="$CONTROL_PATH/hdd_bad_pair"
HALT_FILE="$CONTROL_PATH/halted"
WAITPOWER_FILE="$CONTROL_PATH/waitpower"
BADBLOCK_FILE="$CONTROL_PATH/flash_bad_blocks"

# Bit sequences.
ALL_LEDS_OFF="0"
HALT_LED_ON="1"
HW_FAIL_LED_ON="1" # solid red
ACS_LED_ON="2" # solid blue
IP_LED_ON="2 0 2 0 2 0" # fast blue
ANYTHING_ELSE="2 0" # blink blue

watch-dir $CONTROL_PATH |
while read f; do
  # Check if there is an ip address on the br0 interface.
  if [ -n "$(ip -f inet6 addr show dev br0 scope global)" ] ||
      [ -n "$(ip -f inet addr show dev br0 scope global)" ]; then
    echo "IP address acquired on br0" > "$IP_FILE"
  else
    rm -f "$ACS_FILE"
    rm -f "$IP_FILE"
  fi

  if [ -f "$HALT_FILE" ]; then
    leds $HALT_LED_ON
    atomic $LEDSTATE_FILE HALT
  elif [ -f "$OVERTEMP_FILE" ]; then
    leds $HW_FAIL_LED_ON
    atomic $LEDSTATE_FILE OVERTEMP
  elif [ -f "$HDPAIRING_FILE" ]; then
    leds $HW_FAIL_LED_ON
    atomic $LEDSTATE_FILE HDPAIR_FAIL
  elif [ -f "$BADBLOCK_FILE" ]; then
    leds $HW_FAIL_LED_ON
    atomic $LEDSTATE_FILE BADBLOCK
  elif [ -f "$WAITPOWER_FILE" ]; then
    leds $ALL_LEDS_OFF
    atomic $LEDSTATE_FILE POWEROFF
  elif [ -f "$ACS_FILE" ]; then
    leds $ACS_LED_ON
    atomic $LEDSTATE_FILE ACSCONTACT
  elif [ -f "$IP_FILE" ]; then
    leds $IP_LED_ON
    atomic $LEDSTATE_FILE IPV6ACQUIRED
  else
    leds $ANYTHING_ELSE
    atomic $LEDSTATE_FILE OTHER
  fi
done
