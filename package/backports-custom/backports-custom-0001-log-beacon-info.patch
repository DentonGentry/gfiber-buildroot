From 2f3d7f9b78205698bc34567485c8ef1f34657665 Mon Sep 17 00:00:00 2001
From: David Held <drheld@google.com>
Date: Fri, 9 May 2014 14:07:06 -0400
Subject: [PATCH] Log beacon info.

---
 drivers/net/wireless/ath/ath10k/debug.h |  3 +++
 drivers/net/wireless/ath/ath10k/wmi.c   | 30 +++++++++++++++++++++++++-----
 2 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/ath/ath10k/debug.h b/drivers/net/wireless/ath/ath10k/debug.h
index 50f43b5..f7e2bc7 100644
--- a/drivers/net/wireless/ath/ath10k/debug.h
+++ b/drivers/net/wireless/ath/ath10k/debug.h
@@ -35,6 +35,9 @@ enum ath10k_debug_mask {
 	ATH10K_DBG_BMI		= 0x00000400,
 	ATH10K_DBG_REGULATORY	= 0x00000800,
 	ATH10K_DBG_ANY		= 0xffffffff,
+
+	// Use high bit so conflicts are less likely with upstream updates.
+	ATH10K_DBG_BEACON	= 0x10000000,
 };
 
 extern unsigned int ath10k_debug_mask;
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 0a2d04c..1856d54 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -557,25 +557,27 @@ err_pull:
 	return ret;
 }
 
-static void ath10k_wmi_tx_beacon_nowait(struct ath10k_vif *arvif)
+/* Returns -1 on failure, 0 on success, or 1 if already sent. */
+static int ath10k_wmi_tx_beacon_nowait(struct ath10k_vif *arvif)
 {
 	int ret;
 
 	lockdep_assert_held(&arvif->ar->data_lock);
 
 	if (arvif->beacon == NULL)
-		return;
+		return -1;
 
 	if (arvif->beacon_sent)
-		return;
+		return 1;
 
 	ret = ath10k_wmi_beacon_send_ref_nowait(arvif);
 	if (ret)
-		return;
+		return -1;
 
 	/* We need to retain the arvif->beacon reference for DMA unmapping and
 	 * freeing the skbuff later. */
 	arvif->beacon_sent = true;
+	return 0;
 }
 
 static void ath10k_wmi_tx_beacons_iter(void *data, u8 *mac,
@@ -1362,6 +1364,9 @@ static void ath10k_wmi_event_host_swba(struct ath10k *ar, struct sk_buff *skb)
 	struct sk_buff *bcn;
 	int ret, vdev_id = 0;
 
+	int attempted_to_send_beacon = 0;
+	static int beacon_count = 0;
+
 	ev = (struct wmi_host_swba_event *)skb->data;
 	map = __le32_to_cpu(ev->vdev_map);
 
@@ -1448,9 +1453,24 @@ static void ath10k_wmi_event_host_swba(struct ath10k *ar, struct sk_buff *skb)
 		arvif->beacon = bcn;
 		arvif->beacon_sent = false;
 
-		ath10k_wmi_tx_beacon_nowait(arvif);
+		ret = ath10k_wmi_tx_beacon_nowait(arvif);
+		attempted_to_send_beacon = 1;
+		if (ret == 1) {
+			ath10k_warn("beacon_sent should have been false\n");
+		} else if (ret == -1) {
+			ath10k_warn("failed to send beacon\n");
+		} else {
+			++beacon_count;
+                }
 skip:
 		spin_unlock_bh(&ar->data_lock);
+
+		if (attempted_to_send_beacon == 0) {
+			ath10k_warn("beacon callback led to no beacon\n");
+		} else if ((ath10k_debug_mask & ATH10K_DBG_BEACON) && beacon_count >= 50) {
+			beacon_count = 0;
+			ath10k_dbg(ATH10K_DBG_BEACON, "50 beacons sent\n");
+		}
 	}
 }
 
-- 
1.9.1.423.g4596e3a

