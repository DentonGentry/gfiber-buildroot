diff --git a/lib/nl.c b/lib/nl.c
index bcf89da..f3afd08 100644
--- a/lib/nl.c
+++ b/lib/nl.c
@@ -474,10 +474,18 @@ int nl_recv(struct nl_sock *sk, struct sockaddr_nl *nla,
 
 	iov.iov_len = page_size;
 	iov.iov_base = *buf = malloc(iov.iov_len);
+	if (iov.iov_base == NULL) {
+		NL_DBG(1, "malloc() failed to allocate iov_base\n");
+		return -ENOMEM;
+	}
 
 	if (sk->s_flags & NL_SOCK_PASSCRED) {
 		msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));
 		msg.msg_control = calloc(1, msg.msg_controllen);
+		if (msg.msg_control == NULL) {
+			NL_DBG(1, "calloc() failed to allocate msg_control\n");
+			goto alloc_failure;
+		}
 	}
 retry:
 
@@ -504,10 +512,18 @@ retry:
 		 * and try again. */
 		iov.iov_len *= 2;
 		iov.iov_base = *buf = realloc(*buf, iov.iov_len);
+		if (*buf == NULL) {
+			NL_DBG(1, "realloc() failed to allocate buf\n");
+			goto alloc_failure;
+		}
 		goto retry;
 	} else if (msg.msg_flags & MSG_CTRUNC) {
 		msg.msg_controllen *= 2;
 		msg.msg_control = realloc(msg.msg_control, msg.msg_controllen);
+		if (msg.msg_control == NULL) {
+			NL_DBG(1, "realloc() failed to allocate msg_control\n");
+			goto alloc_failure;
+		}
 		goto retry;
 	} else if (flags != 0) {
 		/* Buffer is big enough, do the actual reading */
@@ -526,6 +542,10 @@ retry:
 		    cmsg->cmsg_type == SCM_CREDENTIALS) {
 			if (creds) {
 				*creds = calloc(1, sizeof(struct ucred));
+				if (creds == NULL) {
+					NL_DBG(1, "calloc() failed\n");
+					goto alloc_failure;
+				}
 				memcpy(*creds, CMSG_DATA(cmsg), sizeof(struct ucred));
 			}
 			break;
@@ -539,6 +559,11 @@ abort:
 	free(msg.msg_control);
 	free(*buf);
 	return 0;
+
+alloc_failure:
+	free(msg.msg_control);
+	free(*buf);
+	return -ENOMEM;
 }
 
 #define NL_CB_CALL(cb, type, msg) \
