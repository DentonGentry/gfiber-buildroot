From d4702b6adf7d1c92b4823578d1fc2ae084a1fb2c Mon Sep 17 00:00:00 2001
From: Denton Gentry <dgentry@google.com>
Date: Mon, 12 Jan 2015 14:30:33 -0800
Subject: [PATCH] Make Zone alignments at least kDoubleSize.

MIPS requires aligned pointers. 64 bit integer stores to
unaligned addresses trap into the kernel for fixup, which
works but at a large performance penalty. Stores from the
floating point coprocessor are not fixed up, they simply
kill the process.
---
 dart/runtime/vm/zone.cc | 1 +
 dart/runtime/vm/zone.h  | 5 +++--
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/dart/runtime/vm/zone.cc b/dart/runtime/vm/zone.cc
index dc8dcf2..b16c030 100644
--- a/dart/runtime/vm/zone.cc
+++ b/dart/runtime/vm/zone.cc
@@ -63,6 +63,7 @@ void Zone::Segment::DeleteSegmentList(Segment* head) {
 Zone::Segment* Zone::Segment::New(intptr_t size, Zone::Segment* next) {
   ASSERT(size >= 0);
   Segment* result = reinterpret_cast<Segment*>(new uint8_t[size]);
+  ASSERT(Utils::IsAligned(result->start(), Zone::kAlignment));
   if (result != NULL) {
 #ifdef DEBUG
     // Zap the entire allocated segment (including the header).
diff --git a/dart/runtime/vm/zone.h b/dart/runtime/vm/zone.h
index fea44c9..b42c196 100644
--- a/dart/runtime/vm/zone.h
+++ b/dart/runtime/vm/zone.h
@@ -67,6 +67,7 @@ class Zone {
       large_segments_(NULL),
       handles_(),
       previous_(NULL) {
+    ASSERT(Utils::IsAligned(position_, kAlignment));
 #ifdef DEBUG
     // Zap the entire initial buffer.
     memset(initial_buffer_.pointer(), kZapUninitializedByte,
@@ -84,7 +85,7 @@ class Zone {
   }
 
   // All pointers returned from AllocateUnsafe() and New() have this alignment.
-  static const intptr_t kAlignment = kWordSize;
+  static const intptr_t kAlignment = kDoubleSize;
 
   // Default initial chunk size.
   static const intptr_t kInitialChunkSize = 1 * KB;
@@ -121,7 +122,7 @@ class Zone {
   // This would act as the initial stack allocated chunk so that we don't
   // end up calling malloc/free on zone scopes that allocate less than
   // kChunkSize
-  uint8_t buffer_[kInitialChunkSize];
+  uint8_t buffer_[kInitialChunkSize] __attribute__ ((aligned (sizeof(double))));
   MemoryRegion initial_buffer_;
 
   // The free region in the current (head) segment or the initial buffer is
-- 
2.2.0.rc0.207.ga3a616c

