#!/bin/sh

die() {
  echo "fatal error ($1), aborting." >&2
  exit 1
}


startswith() {
  [ "$1" != "${1#$2}" ]
}


# chown -R would be easier than this, but toolbox chown doesn't support it.
# Plus I don't know if I can trust it to not follow symlinks accidentally.  So
# let's do it the slow, paranoid way instead.
chowndirs() {
  (
    uidgid="$1"
    basedir="$2"
    echo "chown $uidgid $basedir" >&2
    cd "$basedir" || die "chowndirs '$2'"
    realdir=$(/bin/pwd)
    [ "$realdir" != '/' ] && realdir="$realdir/"
    find . | while read dir; do
      (
        # cd followed by 'chown .' avoids race conditions, although it's
        # slower.
        [ -L "$dir" ] && continue
        [ -d "$dir" ] || continue
        cd "$dir" || die "chowndirs '$dir'"
        curdir=$(/bin/pwd)
        if startswith "$curdir" "$realdir"; then
          chown "$uidgid" . || die "chown '$curdir'"
        else
          echo "'$dir' = '$curdir' -> skipping chown" >&2
        fi
      )
    done
  )
}


# Carefully try to clean up the directory structures we create for samba.
# We go through extra contortions here to minimize the chances that a bug
# (or a deliberate security attack) will cause us to accidentally rm -rf
# important stuff or start with special files in the wrong places.
cleanup() {
  (
    echo "cleaning up /var/media."
    cd /var/media || die 'cd /var/media'
    random=$(
      dd if=/dev/urandom bs=20 count=1 2>/dev/null |
      sha1sum |
      { read sum junk; echo "$sum"; }
    )
    D=clean.$random.$(date +%s).$$
    mkdir "$D"
    for d in tmp var etc; do
      [ -e "$d" ] && mv "$d" "$D"
    done
    umount-subdirs-of "$D" || die umount
    rm -rf "$D" || die rm-rf
    for d in tmp var etc; do
      [ -e "$d" ] && die "/var/media/$d could not be deleted"
    done
    return 0
  )
}


case "$1" in
  start)
    if is-storage-box; then
      cleanup || die 'start cleanup failed'
      mkdir -p \
          /var/media/tmp \
          /var/media/var/lock/subsys \
          /var/media/etc \
          /tmp/samba/sockets
      chmod 755 \
          /var/media/tmp \
          /var/media/var \
          /var/media/var/lock \
          /var/media/etc
      chown video.video /var/media/tmp
      mount -o bind /var/lock/subsys /var/media/var/lock/subsys
      cp /etc/samba/etc/* /var/media/etc/
      chmod 0444 /var/media/etc/*
      chowndirs video.video /var/media/videos
      chowndirs video.video /var/media/pictures
      chowndirs video.video /var/media/music
      babysit 60 smbd -F -D -S 2>&1 | logos smbd &
      babysit 60 nmbd -F -D -S 2>&1 | logos nmbd &
    fi 2>&1 | logos smbd &  # run in background to avoid slowing boot
    ;;
  stop)
    # we have to kill the babysitter too, because smbd eats the SIGTERM
    # exit code and returns 1 instead, so babysit thinks it needs to
    # restart.
    pkillwait -f 'babysit 60 smbd'
    pkillwait -f 'babysit 60 nmbd'
    pkillwait -x smbd
    pkillwait -x nmbd
    if is-storage-box; then
      cleanup
    fi
    ;;
  restart)
    $0 stop; $0 start
    ;;
  reload)
    pids=$(pgrep -x smbd)
    [ -n "$pids" ] && kill -1 $pids
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|reload}"
    exit 1
esac
