diff -Nrup a/extra/Configs/Config.avr32 b/extra/Configs/Config.avr32
--- a/extra/Configs/Config.avr32	1969-12-31 19:00:00.000000000 -0500
+++ b/extra/Configs/Config.avr32	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,42 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config HAVE_ELF
+	bool
+	default y
+
+config TARGET_ARCH
+	default "avr32"
+
+config ARCH_CFLAGS
+	string
+
+config ARCH_LDFLAGS
+	string
+
+config LIBGCC_CFLAGS
+	string
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+	bool
+	default y
+
+config UCLIBC_COMPLETELY_PIC
+	select FORCE_SHAREABLE_TEXT_SEGMENTS
+	bool
+	default y
+
+choice
+	prompt "Target CPU Type"
+	default CONFIG_AP7000
+
+config CONFIG_AP7000
+	bool "AP7000"
+
+endchoice
+
+config LINKRELAX
+	bool "Enable linker optimizations"
+	default n
diff -Nrup a/extra/Configs/Config.in b/extra/Configs/Config.in
--- a/extra/Configs/Config.in	2007-01-25 19:01:55.000000000 -0500
+++ b/extra/Configs/Config.in	2008-02-28 19:02:10.000000000 -0500
@@ -16,6 +16,9 @@ config TARGET_alpha
 config TARGET_arm
 	bool "arm"
 
+config TARGET_avr32
+	bool "avr32"
+
 config TARGET_bfin
 	bool "bfin"
 
@@ -83,6 +86,10 @@ if TARGET_arm
 source "extra/Configs/Config.arm"
 endif
 
+if TARGET_avr32
+source "extra/Configs/Config.avr32"
+endif
+
 if TARGET_bfin
 source "extra/Configs/Config.bfin"
 endif
diff -Nrup a/include/elf.h b/include/elf.h
--- a/include/elf.h	2007-01-25 19:22:03.000000000 -0500
+++ b/include/elf.h	2008-02-28 19:02:10.000000000 -0500
@@ -305,6 +305,8 @@ typedef struct
 /* D30V backend magic number.  Written in the absence of an ABI.  */
 #define EM_CYGNUS_D30V	0x7676
 
+#define EM_AVR32	0x18ad
+
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850	0x9080
 
@@ -2751,6 +2753,55 @@ typedef Elf32_Addr Elf32_Conflict;
 /* Keep this the last entry.  */
 #define R_960_NUM	8
 
+/* Atmel AVR32 relocations.  */
+#define R_AVR32_NONE		0
+#define R_AVR32_32		1
+#define R_AVR32_16		2
+#define R_AVR32_8		3
+#define R_AVR32_32_PCREL	4
+#define R_AVR32_16_PCREL	5
+#define R_AVR32_8_PCREL		6
+#define R_AVR32_DIFF32		7
+#define R_AVR32_DIFF16		8
+#define R_AVR32_DIFF8		9
+#define R_AVR32_GOT32		10
+#define R_AVR32_GOT16		11
+#define R_AVR32_GOT8		12
+#define R_AVR32_21S		13
+#define R_AVR32_16U		14
+#define R_AVR32_16S		15
+#define R_AVR32_8S		16
+#define R_AVR32_8S_EXT		17
+#define R_AVR32_22H_PCREL	18
+#define R_AVR32_18W_PCREL	19
+#define R_AVR32_16B_PCREL	20
+#define R_AVR32_16N_PCREL	21
+#define R_AVR32_14UW_PCREL	22
+#define R_AVR32_11H_PCREL	23
+#define R_AVR32_10UW_PCREL	24
+#define R_AVR32_9H_PCREL	25
+#define R_AVR32_9UW_PCREL	26
+#define R_AVR32_HI16		27
+#define R_AVR32_LO16		28
+#define R_AVR32_GOTPC		29
+#define R_AVR32_GOTCALL		30
+#define R_AVR32_LDA_GOT		31
+#define R_AVR32_GOT21S		32
+#define R_AVR32_GOT18SW		33
+#define R_AVR32_GOT16S		34
+#define R_AVR32_GOT7UW		35
+#define R_AVR32_32_CPENT	36
+#define R_AVR32_CPCALL		37
+#define R_AVR32_16_CP		38
+#define R_AVR32_9W_CP		39
+#define R_AVR32_RELATIVE	40
+#define R_AVR32_GLOB_DAT	41
+#define R_AVR32_JMP_SLOT	42
+#define R_AVR32_ALIGN		43
+#define R_AVR32_NUM		44
+
+/* AVR32 dynamic tags */
+#define DT_AVR32_GOTSZ		0x70000001 /* Total size of GOT in bytes */
 
 /* v850 relocations.  */
 #define R_V850_NONE		0
diff -Nrup a/include/elf.h.orig b/include/elf.h.orig
--- a/include/elf.h.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/include/elf.h.orig	2007-01-25 19:22:03.000000000 -0500
@@ -0,0 +1,2886 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 1995-2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ELF_H
+#define	_ELF_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Standard ELF types.  */
+
+#include <stdint.h>
+
+/* Type for a 16-bit quantity.  */
+typedef uint16_t Elf32_Half;
+typedef uint16_t Elf64_Half;
+
+/* Types for signed and unsigned 32-bit quantities.  */
+typedef uint32_t Elf32_Word;
+typedef	int32_t  Elf32_Sword;
+typedef uint32_t Elf64_Word;
+typedef	int32_t  Elf64_Sword;
+
+/* Types for signed and unsigned 64-bit quantities.  */
+typedef uint64_t Elf32_Xword;
+typedef	int64_t  Elf32_Sxword;
+typedef uint64_t Elf64_Xword;
+typedef	int64_t  Elf64_Sxword;
+
+/* Type of addresses.  */
+typedef uint32_t Elf32_Addr;
+typedef uint64_t Elf64_Addr;
+
+/* Type of file offsets.  */
+typedef uint32_t Elf32_Off;
+typedef uint64_t Elf64_Off;
+
+/* Type for section indices, which are 16-bit quantities.  */
+typedef uint16_t Elf32_Section;
+typedef uint16_t Elf64_Section;
+
+/* Type for version symbol information.  */
+typedef Elf32_Half Elf32_Versym;
+typedef Elf64_Half Elf64_Versym;
+
+
+/* The ELF file header.  This appears at the start of every ELF file.  */
+
+#define EI_NIDENT (16)
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf32_Half	e_type;			/* Object file type */
+  Elf32_Half	e_machine;		/* Architecture */
+  Elf32_Word	e_version;		/* Object file version */
+  Elf32_Addr	e_entry;		/* Entry point virtual address */
+  Elf32_Off	e_phoff;		/* Program header table file offset */
+  Elf32_Off	e_shoff;		/* Section header table file offset */
+  Elf32_Word	e_flags;		/* Processor-specific flags */
+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf32_Half	e_phentsize;		/* Program header table entry size */
+  Elf32_Half	e_phnum;		/* Program header table entry count */
+  Elf32_Half	e_shentsize;		/* Section header table entry size */
+  Elf32_Half	e_shnum;		/* Section header table entry count */
+  Elf32_Half	e_shstrndx;		/* Section header string table index */
+} Elf32_Ehdr;
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf64_Half	e_type;			/* Object file type */
+  Elf64_Half	e_machine;		/* Architecture */
+  Elf64_Word	e_version;		/* Object file version */
+  Elf64_Addr	e_entry;		/* Entry point virtual address */
+  Elf64_Off	e_phoff;		/* Program header table file offset */
+  Elf64_Off	e_shoff;		/* Section header table file offset */
+  Elf64_Word	e_flags;		/* Processor-specific flags */
+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf64_Half	e_phentsize;		/* Program header table entry size */
+  Elf64_Half	e_phnum;		/* Program header table entry count */
+  Elf64_Half	e_shentsize;		/* Section header table entry size */
+  Elf64_Half	e_shnum;		/* Section header table entry count */
+  Elf64_Half	e_shstrndx;		/* Section header string table index */
+} Elf64_Ehdr;
+
+/* Fields in the e_ident array.  The EI_* macros are indices into the
+   array.  The macros under each EI_* macro are the values the byte
+   may have.  */
+
+#define EI_MAG0		0		/* File identification byte 0 index */
+#define ELFMAG0		0x7f		/* Magic number byte 0 */
+
+#define EI_MAG1		1		/* File identification byte 1 index */
+#define ELFMAG1		'E'		/* Magic number byte 1 */
+
+#define EI_MAG2		2		/* File identification byte 2 index */
+#define ELFMAG2		'L'		/* Magic number byte 2 */
+
+#define EI_MAG3		3		/* File identification byte 3 index */
+#define ELFMAG3		'F'		/* Magic number byte 3 */
+
+/* Conglomeration of the identification bytes, for easy testing as a word.  */
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define EI_CLASS	4		/* File class byte index */
+#define ELFCLASSNONE	0		/* Invalid class */
+#define ELFCLASS32	1		/* 32-bit objects */
+#define ELFCLASS64	2		/* 64-bit objects */
+#define ELFCLASSNUM	3
+
+#define EI_DATA		5		/* Data encoding byte index */
+#define ELFDATANONE	0		/* Invalid data encoding */
+#define ELFDATA2LSB	1		/* 2's complement, little endian */
+#define ELFDATA2MSB	2		/* 2's complement, big endian */
+#define ELFDATANUM	3
+
+#define EI_VERSION	6		/* File version byte index */
+					/* Value must be EV_CURRENT */
+
+#define EI_OSABI	7		/* OS ABI identification */
+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
+#define ELFOSABI_SYSV		0	/* Alias.  */
+#define ELFOSABI_HPUX		1	/* HP-UX */
+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
+#define ELFOSABI_LINUX		3	/* Linux.  */
+#define ELFOSABI_HURD		4	/* GNU/Hurd */
+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
+#define ELFOSABI_AIX		7	/* IBM AIX.  */
+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
+#define ELFOSABI_OPENVMS	13	/* OpenVMS */
+#define ELFOSABI_NSK		14	/* Hewlett-Packard Non-Stop Kernel */
+#define ELFOSABI_AROS		15	/* Amiga Research OS */
+#define ELFOSABI_ARM		97	/* ARM */
+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
+
+#define EI_ABIVERSION	8		/* ABI version */
+
+#define EI_PAD		9		/* Byte index of padding bytes */
+
+/* Legal values for e_type (object file type).  */
+
+#define ET_NONE		0		/* No file type */
+#define ET_REL		1		/* Relocatable file */
+#define ET_EXEC		2		/* Executable file */
+#define ET_DYN		3		/* Shared object file */
+#define ET_CORE		4		/* Core file */
+#define	ET_NUM		5		/* Number of defined types */
+#define ET_LOOS		0xfe00		/* OS-specific range start */
+#define ET_HIOS		0xfeff		/* OS-specific range end */
+#define ET_LOPROC	0xff00		/* Processor-specific range start */
+#define ET_HIPROC	0xffff		/* Processor-specific range end */
+
+/* Legal values for e_machine (architecture).  */
+
+#define EM_NONE		 0		/* No machine */
+#define EM_M32		 1		/* AT&T WE 32100 */
+#define EM_SPARC	 2		/* SUN SPARC */
+#define EM_386		 3		/* Intel 80386 */
+#define EM_68K		 4		/* Motorola m68k family */
+#define EM_88K		 5		/* Motorola m88k family */
+#define EM_486		 6		/* Intel 80486 *//* Reserved for future use */
+#define EM_860		 7		/* Intel 80860 */
+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
+#define EM_S370		 9		/* IBM System/370 */
+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+
+#define EM_PARISC	15		/* HPPA */
+#define EM_VPP500	17		/* Fujitsu VPP500 */
+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+#define EM_960		19		/* Intel 80960 */
+#define EM_PPC		20		/* PowerPC */
+#define EM_PPC64	21		/* PowerPC 64-bit */
+#define EM_S390		22		/* IBM S390 */
+
+#define EM_V800		36		/* NEC V800 series */
+#define EM_FR20		37		/* Fujitsu FR20 */
+#define EM_RH32		38		/* TRW RH-32 */
+#define EM_MCORE	39		/* Motorola M*Core */ /* May also be taken by Fujitsu MMA */
+#define EM_RCE		39		/* Old name for MCore */
+#define EM_ARM		40		/* ARM */
+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
+#define EM_SH		42		/* Renesas SH */
+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
+#define EM_TRICORE	44		/* Siemens Tricore */
+#define EM_ARC		45		/* Argonaut RISC Core */
+#define EM_H8_300	46		/* Renesas H8/300 */
+#define EM_H8_300H	47		/* Renesas H8/300H */
+#define EM_H8S		48		/* Renesas H8S */
+#define EM_H8_500	49		/* Renesas H8/500 */
+#define EM_IA_64	50		/* Intel Merced */
+#define EM_MIPS_X	51		/* Stanford MIPS-X */
+#define EM_COLDFIRE	52		/* Motorola Coldfire */
+#define EM_68HC12	53		/* Motorola M68HC12 */
+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+#define EM_PCP		55		/* Siemens PCP */
+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
+#define EM_STARCORE	58		/* Motorola Start*Core processor */
+#define EM_ME16		59		/* Toyota ME16 processor */
+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+#define EM_X86_64	62		/* AMD x86-64 architecture */
+#define EM_PDSP		63		/* Sony DSP Processor */
+
+#define EM_FX66		66		/* Siemens FX66 microcontroller */
+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+#define EM_SVX		73		/* Silicon Graphics SVx */
+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
+#define EM_VAX		75		/* Digital VAX */
+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+#define EM_HUANY	81		/* Harvard University machine-independent object files */
+#define EM_PRISM	82		/* SiTera Prism */
+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+#define EM_FR30		84		/* Fujitsu FR30 */
+#define EM_D10V		85		/* Mitsubishi D10V */
+#define EM_D30V		86		/* Mitsubishi D30V */
+#define EM_V850		87		/* NEC v850 */
+#define EM_M32R		88		/* Renesas M32R */
+#define EM_MN10300	89		/* Matsushita MN10300 */
+#define EM_MN10200	90		/* Matsushita MN10200 */
+#define EM_PJ		91		/* picoJava */
+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+#define EM_IP2K		101		/* Ubicom IP2022 micro controller */
+#define EM_CR		103		/* National Semiconductor CompactRISC */
+#define EM_MSP430	105		/* TI msp430 micro controller */
+#define EM_BLACKFIN	106		/* Analog Devices Blackfin */
+#define EM_ALTERA_NIOS2	113	/* Altera Nios II soft-core processor */
+#define EM_CRX		114		/* National Semiconductor CRX */
+#define EM_NUM		95
+
+/* If it is necessary to assign new unofficial EM_* values, please pick large
+   random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
+   with official or non-GNU unofficial values.
+
+   NOTE: Do not just increment the most recent number by one.
+   Somebody else somewhere will do exactly the same thing, and you
+   will have a collision.  Instead, pick a random number.
+
+   Normally, each entity or maintainer responsible for a machine with an
+   unofficial e_machine number should eventually ask registry@caldera.com for
+   an officially blessed number to be added to the list above.  */
+
+/* picoJava */
+#define EM_PJ_OLD	99
+
+/* Cygnus PowerPC ELF backend.  Written in the absence of an ABI.  */
+#define EM_CYGNUS_POWERPC 0x9025
+
+/* Old version of Sparc v9, from before the ABI; this should be
+   removed shortly.  */
+#define EM_OLD_SPARCV9	11
+
+/* Old version of PowerPC, this should be removed shortly. */
+#define EM_PPC_OLD	17
+
+/* (Deprecated) Temporary number for the OpenRISC processor.  */
+#define EM_OR32		0x8472
+
+/* Renesas M32C and M16C.  */
+#define EM_M32C			0xFEB0
+
+/* Cygnus M32R ELF backend.  Written in the absence of an ABI.  */
+#define EM_CYGNUS_M32R	0x9041
+
+/* old S/390 backend magic number. Written in the absence of an ABI.  */
+#define EM_S390_OLD	0xa390
+
+/* D10V backend magic number.  Written in the absence of an ABI.  */
+#define EM_CYGNUS_D10V	0x7650
+
+/* D30V backend magic number.  Written in the absence of an ABI.  */
+#define EM_CYGNUS_D30V	0x7676
+
+/* V850 backend magic number.  Written in the absense of an ABI.  */
+#define EM_CYGNUS_V850	0x9080
+
+/* mn10200 and mn10300 backend magic numbers.
+   Written in the absense of an ABI.  */
+#define EM_CYGNUS_MN10200	0xdead
+#define EM_CYGNUS_MN10300	0xbeef
+
+/* FR30 magic number - no EABI available.  */
+#define EM_CYGNUS_FR30		0x3330
+
+/* AVR magic number
+   Written in the absense of an ABI.  */
+#define EM_AVR_OLD		0x1057
+
+/* OpenRISC magic number
+   Written in the absense of an ABI.  */
+#define EM_OPENRISC_OLD		0x3426
+
+/* DLX magic number
+   Written in the absense of an ABI.  */
+#define EM_DLX			0x5aa5
+
+#define EM_XSTORMY16		0xad45
+
+/* FRV magic number - no EABI available??.  */
+#define EM_CYGNUS_FRV	0x5441
+
+/* Ubicom IP2xxx; no ABI */
+#define EM_IP2K_OLD		0x8217
+
+#define EM_MT                   0x2530  /* Morpho MT; no ABI */
+
+/* MSP430 magic number
+      Written in the absense everything.  */
+#define EM_MSP430_OLD		0x1059
+
+/* Vitesse IQ2000.  */
+#define EM_IQ2000		0xFEBA
+
+/* Old, unofficial value for Xtensa.  */
+#define EM_XTENSA_OLD		0xabc7
+
+/* Alpha backend magic number.  Written in the absence of an ABI.  */
+#define EM_ALPHA	0x9026
+
+/* NIOS magic number - no EABI available.  */
+#define EM_NIOS32	0xFEBB
+
+/* V850 backend magic number.  Written in the absense of an ABI.  */
+#define EM_CYGNUS_V850 0x9080
+
+/* Legal values for e_version (version).  */
+
+#define EV_NONE		0		/* Invalid ELF version */
+#define EV_CURRENT	1		/* Current version */
+#define EV_NUM		2
+
+/* Section header.  */
+
+typedef struct
+{
+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
+  Elf32_Word	sh_type;		/* Section type */
+  Elf32_Word	sh_flags;		/* Section flags */
+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf32_Off	sh_offset;		/* Section file offset */
+  Elf32_Word	sh_size;		/* Section size in bytes */
+  Elf32_Word	sh_link;		/* Link to another section */
+  Elf32_Word	sh_info;		/* Additional section information */
+  Elf32_Word	sh_addralign;		/* Section alignment */
+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
+} Elf32_Shdr;
+
+typedef struct
+{
+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
+  Elf64_Word	sh_type;		/* Section type */
+  Elf64_Xword	sh_flags;		/* Section flags */
+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf64_Off	sh_offset;		/* Section file offset */
+  Elf64_Xword	sh_size;		/* Section size in bytes */
+  Elf64_Word	sh_link;		/* Link to another section */
+  Elf64_Word	sh_info;		/* Additional section information */
+  Elf64_Xword	sh_addralign;		/* Section alignment */
+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
+} Elf64_Shdr;
+
+/* Special section indices.  */
+
+#define SHN_UNDEF	0		/* Undefined section */
+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
+#define SHN_BEFORE	0xff00		/* Order section before all others
+					   (Solaris).  */
+#define SHN_AFTER	0xff01		/* Order section after all others
+					   (Solaris).  */
+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
+#define SHN_LOOS	0xff20		/* Start of OS-specific */
+#define SHN_HIOS	0xff3f		/* End of OS-specific */
+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
+
+/* Legal values for sh_type (section type).  */
+
+#define SHT_NULL	  0		/* Section header table entry unused */
+#define SHT_PROGBITS	  1		/* Program data */
+#define SHT_SYMTAB	  2		/* Symbol table */
+#define SHT_STRTAB	  3		/* String table */
+#define SHT_RELA	  4		/* Relocation entries with addends */
+#define SHT_HASH	  5		/* Symbol hash table */
+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
+#define SHT_NOTE	  7		/* Notes */
+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
+#define SHT_REL		  9		/* Relocation entries, no addends */
+#define SHT_SHLIB	  10		/* Reserved */
+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
+#define SHT_GROUP	  17		/* Section group */
+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
+#define	SHT_NUM		  19		/* Number of defined types.  */
+#define SHT_LOOS	  0x60000000	/* Start OS-specific */
+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
+#define SHT_SUNW_move	  0x6ffffffa
+#define SHT_SUNW_COMDAT   0x6ffffffb
+#define SHT_SUNW_syminfo  0x6ffffffc
+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
+
+/* Legal values for sh_flags (section flags).  */
+
+#define SHF_WRITE	     (1 << 0)	/* Writable */
+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
+					   required */
+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
+					   (Solaris).  */
+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
+					   referenced or allocated (Solaris).*/
+
+/* Section group handling.  */
+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
+
+/* Symbol table entry.  */
+
+typedef struct
+{
+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
+  Elf32_Addr	st_value;		/* Symbol value */
+  Elf32_Word	st_size;		/* Symbol size */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char	st_other;		/* Symbol visibility */
+  Elf32_Section	st_shndx;		/* Section index */
+} Elf32_Sym;
+
+typedef struct
+{
+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char st_other;		/* Symbol visibility */
+  Elf64_Section	st_shndx;		/* Section index */
+  Elf64_Addr	st_value;		/* Symbol value */
+  Elf64_Xword	st_size;		/* Symbol size */
+} Elf64_Sym;
+
+/* The syminfo section if available contains additional information about
+   every dynamic symbol.  */
+
+typedef struct
+{
+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf32_Half si_flags;			/* Per symbol flags */
+} Elf32_Syminfo;
+
+typedef struct
+{
+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf64_Half si_flags;			/* Per symbol flags */
+} Elf64_Syminfo;
+
+/* Possible values for si_boundto.  */
+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
+
+/* Possible bitmasks for si_flags.  */
+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
+					   loaded */
+/* Syminfo version values.  */
+#define SYMINFO_NONE		0
+#define SYMINFO_CURRENT		1
+#define SYMINFO_NUM		2
+
+
+/* How to extract and insert information held in the st_info field.  */
+
+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
+#define ELF32_ST_TYPE(val)		((val) & 0xf)
+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
+
+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
+
+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
+
+#define STB_LOCAL	0		/* Local symbol */
+#define STB_GLOBAL	1		/* Global symbol */
+#define STB_WEAK	2		/* Weak symbol */
+#define	STB_NUM		3		/* Number of defined types.  */
+#define STB_LOOS	10		/* Start of OS-specific */
+#define STB_HIOS	12		/* End of OS-specific */
+#define STB_LOPROC	13		/* Start of processor-specific */
+#define STB_HIPROC	15		/* End of processor-specific */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_NOTYPE	0		/* Symbol type is unspecified */
+#define STT_OBJECT	1		/* Symbol is a data object */
+#define STT_FUNC	2		/* Symbol is a code object */
+#define STT_SECTION	3		/* Symbol associated with a section */
+#define STT_FILE	4		/* Symbol's name is file name */
+#define STT_COMMON	5		/* Symbol is a common data object */
+#define STT_TLS		6		/* Symbol is thread-local data object*/
+#define	STT_NUM		7		/* Number of defined types.  */
+#define STT_LOOS	10		/* Start of OS-specific */
+#define STT_HIOS	12		/* End of OS-specific */
+#define STT_LOPROC	13		/* Start of processor-specific */
+#define STT_HIPROC	15		/* End of processor-specific */
+
+
+/* Symbol table indices are found in the hash buckets and chain table
+   of a symbol hash table section.  This special index value indicates
+   the end of a chain, meaning no further symbols are found in that bucket.  */
+
+#define STN_UNDEF	0		/* End of a chain.  */
+
+
+/* How to extract and insert information held in the st_other field.  */
+
+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
+
+/* For ELF64 the definitions are the same.  */
+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
+
+/* Symbol visibility specification encoded in the st_other field.  */
+#define STV_DEFAULT	0		/* Default symbol visibility rules */
+#define STV_INTERNAL	1		/* Processor specific hidden class */
+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
+#define STV_PROTECTED	3		/* Not preemptible, not exported */
+
+
+/* Relocation table entry without addend (in section of type SHT_REL).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+} Elf32_Rel;
+
+/* I have seen two different definitions of the Elf64_Rel and
+   Elf64_Rela structures, so we'll leave them out until Novell (or
+   whoever) gets their act together.  */
+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+} Elf64_Rel;
+
+/* Relocation table entry with addend (in section of type SHT_RELA).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+  Elf32_Sword	r_addend;		/* Addend */
+} Elf32_Rela;
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+  Elf64_Sxword	r_addend;		/* Addend */
+} Elf64_Rela;
+
+/* How to extract and insert information held in the r_info field.  */
+
+#define ELF32_R_SYM(val)		((val) >> 8)
+#define ELF32_R_TYPE(val)		((val) & 0xff)
+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
+
+/* Program segment header.  */
+
+typedef struct
+{
+  Elf32_Word	p_type;			/* Segment type */
+  Elf32_Off	p_offset;		/* Segment file offset */
+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
+  Elf32_Addr	p_paddr;		/* Segment physical address */
+  Elf32_Word	p_filesz;		/* Segment size in file */
+  Elf32_Word	p_memsz;		/* Segment size in memory */
+  Elf32_Word	p_flags;		/* Segment flags */
+  Elf32_Word	p_align;		/* Segment alignment */
+} Elf32_Phdr;
+
+typedef struct
+{
+  Elf64_Word	p_type;			/* Segment type */
+  Elf64_Word	p_flags;		/* Segment flags */
+  Elf64_Off	p_offset;		/* Segment file offset */
+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
+  Elf64_Addr	p_paddr;		/* Segment physical address */
+  Elf64_Xword	p_filesz;		/* Segment size in file */
+  Elf64_Xword	p_memsz;		/* Segment size in memory */
+  Elf64_Xword	p_align;		/* Segment alignment */
+} Elf64_Phdr;
+
+/* Legal values for p_type (segment type).  */
+
+#define	PT_NULL		0		/* Program header table entry unused */
+#define PT_LOAD		1		/* Loadable program segment */
+#define PT_DYNAMIC	2		/* Dynamic linking information */
+#define PT_INTERP	3		/* Program interpreter */
+#define PT_NOTE		4		/* Auxiliary information */
+#define PT_SHLIB	5		/* Reserved */
+#define PT_PHDR		6		/* Entry for header table itself */
+#define PT_TLS		7		/* Thread-local storage segment */
+#define	PT_NUM		8		/* Number of defined types */
+#define PT_LOOS		0x60000000	/* Start of OS-specific */
+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
+#define PT_PAX_FLAGS	0x65041580	/* Indicates PaX flag markings */
+#define PT_LOSUNW	0x6ffffffa
+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
+#define PT_HISUNW	0x6fffffff
+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
+
+/* Legal values for p_flags (segment flags).  */
+
+#define PF_X		(1 << 0)	/* Segment is executable */
+#define PF_W		(1 << 1)	/* Segment is writable */
+#define PF_R		(1 << 2)	/* Segment is readable */
+#define PF_PAGEEXEC	(1 << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1 << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1 << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1 << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1 << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1 << 9)	/* Disable MPROTECT */
+#define PF_RANDEXEC	(1 << 10)	/* Enable  RANDEXEC */
+#define PF_NORANDEXEC	(1 << 11)	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1 << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1 << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1 << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1 << 15)	/* Disable RANDMMAP */
+#define PF_MASKOS	0x0ff00000	/* OS-specific */
+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
+
+/* Legal values for note segment descriptor types for core files. */
+
+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
+#define NT_AUXV		6		/* Contains copy of auxv array */
+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
+#define NT_ASRS		8		/* Contains copy of asrset struct */
+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
+#define NT_PRCRED	14		/* Contains copy of prcred struct */
+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct*/
+
+/* Legal values for the note segment descriptor types for object files.  */
+
+#define NT_VERSION	1		/* Contains a version string.  */
+
+
+/* Dynamic section entry.  */
+
+typedef struct
+{
+  Elf32_Sword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf32_Word d_val;			/* Integer value */
+      Elf32_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf32_Dyn;
+
+typedef struct
+{
+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf64_Xword d_val;		/* Integer value */
+      Elf64_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf64_Dyn;
+
+/* Legal values for d_tag (dynamic entry type).  */
+
+#define DT_NULL		0		/* Marks end of dynamic section */
+#define DT_NEEDED	1		/* Name of needed library */
+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
+#define DT_PLTGOT	3		/* Processor defined value */
+#define DT_HASH		4		/* Address of symbol hash table */
+#define DT_STRTAB	5		/* Address of string table */
+#define DT_SYMTAB	6		/* Address of symbol table */
+#define DT_RELA		7		/* Address of Rela relocs */
+#define DT_RELASZ	8		/* Total size of Rela relocs */
+#define DT_RELAENT	9		/* Size of one Rela reloc */
+#define DT_STRSZ	10		/* Size of string table */
+#define DT_SYMENT	11		/* Size of one symbol table entry */
+#define DT_INIT		12		/* Address of init function */
+#define DT_FINI		13		/* Address of termination function */
+#define DT_SONAME	14		/* Name of shared object */
+#define DT_RPATH	15		/* Library search path (deprecated) */
+#define DT_SYMBOLIC	16		/* Start symbol search here */
+#define DT_REL		17		/* Address of Rel relocs */
+#define DT_RELSZ	18		/* Total size of Rel relocs */
+#define DT_RELENT	19		/* Size of one Rel reloc */
+#define DT_PLTREL	20		/* Type of reloc in PLT */
+#define DT_DEBUG	21		/* For debugging; unspecified */
+#define DT_TEXTREL	22		/* Reloc might modify .text */
+#define DT_JMPREL	23		/* Address of PLT relocs */
+#define	DT_BIND_NOW	24		/* Process relocations of object */
+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
+#define DT_RUNPATH	29		/* Library search path */
+#define DT_FLAGS	30		/* Flags for the object being loaded */
+#define DT_ENCODING	32		/* Start of encoded range */
+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
+#define	DT_NUM		34		/* Number used */
+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
+
+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
+   approach.  */
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
+#define DT_CHECKSUM	0x6ffffdf8
+#define DT_PLTPADSZ	0x6ffffdf9
+#define DT_MOVEENT	0x6ffffdfa
+#define DT_MOVESZ	0x6ffffdfb
+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
+					   the following DT_* entry.  */
+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
+#define DT_VALNUM 12
+
+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
+
+   If any adjustment is made to the ELF object after it has been
+   built these entries will need to be adjusted.  */
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
+#define DT_ADDRNUM 10
+
+/* The versioning entry types.  The next are defined as part of the
+   GNU extension.  */
+#define DT_VERSYM	0x6ffffff0
+
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+
+/* These were chosen by Sun.  */
+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
+					   table */
+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
+					   versions */
+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
+#define DT_VERSIONTAGNUM 16
+
+/* Sun added these machine-independent extensions in the "processor-specific"
+   range.  Be compatible.  */
+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
+#define DT_EXTRANUM	3
+
+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
+
+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
+   entry in the dynamic section.  */
+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
+#define DF_1_TRANS	0x00000200
+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
+
+/* Flags for the feature selection in DT_FEATURE_1.  */
+#define DTF_1_PARINIT	0x00000001
+#define DTF_1_CONFEXP	0x00000002
+
+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
+					   generally available.  */
+
+/* Version definition sections.  */
+
+typedef struct
+{
+  Elf32_Half	vd_version;		/* Version revision */
+  Elf32_Half	vd_flags;		/* Version information */
+  Elf32_Half	vd_ndx;			/* Version Index */
+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vd_hash;		/* Version name hash value */
+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf32_Verdef;
+
+typedef struct
+{
+  Elf64_Half	vd_version;		/* Version revision */
+  Elf64_Half	vd_flags;		/* Version information */
+  Elf64_Half	vd_ndx;			/* Version Index */
+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vd_hash;		/* Version name hash value */
+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf64_Verdef;
+
+
+/* Legal values for vd_version (version revision).  */
+#define VER_DEF_NONE	0		/* No version */
+#define VER_DEF_CURRENT	1		/* Current version */
+#define VER_DEF_NUM	2		/* Given version number */
+
+/* Legal values for vd_flags (version information flags).  */
+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+/* Versym symbol index values.  */
+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
+
+/* Auxialiary version information.  */
+
+typedef struct
+{
+  Elf32_Word	vda_name;		/* Version or dependency names */
+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf32_Verdaux;
+
+typedef struct
+{
+  Elf64_Word	vda_name;		/* Version or dependency names */
+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf64_Verdaux;
+
+
+/* Version dependency section.  */
+
+typedef struct
+{
+  Elf32_Half	vn_version;		/* Version of structure */
+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf32_Verneed;
+
+typedef struct
+{
+  Elf64_Half	vn_version;		/* Version of structure */
+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf64_Verneed;
+
+
+/* Legal values for vn_version (version revision).  */
+#define VER_NEED_NONE	 0		/* No version */
+#define VER_NEED_CURRENT 1		/* Current version */
+#define VER_NEED_NUM	 2		/* Given version number */
+
+/* Auxiliary needed version information.  */
+
+typedef struct
+{
+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
+  Elf32_Half	vna_flags;		/* Dependency specific information */
+  Elf32_Half	vna_other;		/* Unused */
+  Elf32_Word	vna_name;		/* Dependency name string offset */
+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf32_Vernaux;
+
+typedef struct
+{
+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
+  Elf64_Half	vna_flags;		/* Dependency specific information */
+  Elf64_Half	vna_other;		/* Unused */
+  Elf64_Word	vna_name;		/* Dependency name string offset */
+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf64_Vernaux;
+
+
+/* Legal values for vna_flags.  */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+
+/* Auxiliary vector.  */
+
+/* This vector is normally only used by the program interpreter.  The
+   usual definition in an ABI supplement uses the name auxv_t.  The
+   vector is not usually defined in a standard <elf.h> file, but it
+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
+   types are an arrangement between the exec server and the program
+   interpreter, so we don't fully specify them here.  */
+
+typedef struct
+{
+  uint32_t a_type;		/* Entry type */
+  union
+    {
+      uint32_t a_val;		/* Integer value */
+      /* We use to have pointer elements added here.  We cannot do that,
+	 though, since it does not work when using 32-bit definitions
+	 on 64-bit platforms and vice versa.  */
+    } a_un;
+} Elf32_auxv_t;
+
+typedef struct
+{
+  uint64_t a_type;		/* Entry type */
+  union
+    {
+      uint64_t a_val;		/* Integer value */
+      /* We use to have pointer elements added here.  We cannot do that,
+	 though, since it does not work when using 32-bit definitions
+	 on 64-bit platforms and vice versa.  */
+    } a_un;
+} Elf64_auxv_t;
+
+/* Legal values for a_type (entry type).  */
+
+#define AT_NULL		0		/* End of vector */
+#define AT_IGNORE	1		/* Entry should be ignored */
+#define AT_EXECFD	2		/* File descriptor of program */
+#define AT_PHDR		3		/* Program headers for program */
+#define AT_PHENT	4		/* Size of program header entry */
+#define AT_PHNUM	5		/* Number of program headers */
+#define AT_PAGESZ	6		/* System page size */
+#define AT_BASE		7		/* Base address of interpreter */
+#define AT_FLAGS	8		/* Flags */
+#define AT_ENTRY	9		/* Entry point of program */
+#define AT_NOTELF	10		/* Program is not ELF */
+#define AT_UID		11		/* Real uid */
+#define AT_EUID		12		/* Effective uid */
+#define AT_GID		13		/* Real gid */
+#define AT_EGID		14		/* Effective gid */
+#define AT_CLKTCK	17		/* Frequency of times() */
+
+/* Some more special a_type values describing the hardware.  */
+#define AT_PLATFORM	15		/* String identifying platform.  */
+#define AT_HWCAP	16		/* Machine dependent hints about
+					   processor capabilities.  */
+
+/* This entry gives some information about the FPU initialization
+   performed by the kernel.  */
+#define AT_FPUCW	18		/* Used FPU control word.  */
+
+/* Cache block sizes.  */
+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
+
+/* A special ignored value for PPC, used by the kernel to control the
+   interpretation of the AUXV. Must be > 16.  */
+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
+
+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
+
+/* Pointer to the global system page used for system calls and other
+   nice things.  */
+#define AT_SYSINFO	32
+#define AT_SYSINFO_EHDR	33
+
+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
+   log2 of line size; mask those to get cache size.  */
+#define AT_L1I_CACHESHAPE	34
+#define AT_L1D_CACHESHAPE	35
+#define AT_L2_CACHESHAPE	36
+#define AT_L3_CACHESHAPE	37
+
+/* Note section contents.  Each entry in the note section begins with
+   a header of a fixed form.  */
+
+typedef struct
+{
+  Elf32_Word n_namesz;			/* Length of the note's name.  */
+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf32_Word n_type;			/* Type of the note.  */
+} Elf32_Nhdr;
+
+typedef struct
+{
+  Elf64_Word n_namesz;			/* Length of the note's name.  */
+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf64_Word n_type;			/* Type of the note.  */
+} Elf64_Nhdr;
+
+/* Known names of notes.  */
+
+/* Solaris entries in the note section have this name.  */
+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
+
+/* Note entries for GNU systems have this name.  */
+#define ELF_NOTE_GNU		"GNU"
+
+
+/* Defined types of notes for Solaris.  */
+
+/* Value of descriptor (one word) is desired pagesize for the binary.  */
+#define ELF_NOTE_PAGESIZE_HINT	1
+
+
+/* Defined note types for GNU systems.  */
+
+/* ABI information.  The descriptor consists of words:
+   word 0: OS descriptor
+   word 1: major version of the ABI
+   word 2: minor version of the ABI
+   word 3: subminor version of the ABI
+*/
+#define ELF_NOTE_ABI		1
+
+/* Known OSes.  These value can appear in word 0 of an ELF_NOTE_ABI
+   note section entry.  */
+#define ELF_NOTE_OS_LINUX	0
+#define ELF_NOTE_OS_GNU		1
+#define ELF_NOTE_OS_SOLARIS2	2
+#define ELF_NOTE_OS_FREEBSD	3
+
+
+/* Move records.  */
+typedef struct
+{
+  Elf32_Xword m_value;		/* Symbol value.  */
+  Elf32_Word m_info;		/* Size and index.  */
+  Elf32_Word m_poffset;		/* Symbol offset.  */
+  Elf32_Half m_repeat;		/* Repeat count.  */
+  Elf32_Half m_stride;		/* Stride info.  */
+} Elf32_Move;
+
+typedef struct
+{
+  Elf64_Xword m_value;		/* Symbol value.  */
+  Elf64_Xword m_info;		/* Size and index.  */
+  Elf64_Xword m_poffset;	/* Symbol offset.  */
+  Elf64_Half m_repeat;		/* Repeat count.  */
+  Elf64_Half m_stride;		/* Stride info.  */
+} Elf64_Move;
+
+/* Macro to construct move records.  */
+#define ELF32_M_SYM(info)	((info) >> 8)
+#define ELF32_M_SIZE(info)	((unsigned char) (info))
+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
+
+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
+
+
+/* Motorola 68k specific definitions.  */
+
+/* Values for Elf32_Ehdr.e_flags.  */
+#define EF_CPU32	0x00810000
+
+/* m68k relocs.  */
+
+#define R_68K_NONE	0		/* No reloc */
+#define R_68K_32	1		/* Direct 32 bit  */
+#define R_68K_16	2		/* Direct 16 bit  */
+#define R_68K_8		3		/* Direct 8 bit  */
+#define R_68K_PC32	4		/* PC relative 32 bit */
+#define R_68K_PC16	5		/* PC relative 16 bit */
+#define R_68K_PC8	6		/* PC relative 8 bit */
+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
+#define R_68K_COPY	19		/* Copy symbol at runtime */
+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
+#define R_68K_RELATIVE	22		/* Adjust by program base */
+/* Keep this the last entry.  */
+#define R_68K_NUM	23
+
+/* Intel 80386 specific definitions.  */
+
+/* i386 relocs.  */
+
+#define R_386_NONE	   0		/* No reloc */
+#define R_386_32	   1		/* Direct 32 bit  */
+#define R_386_PC32	   2		/* PC relative 32 bit */
+#define R_386_GOT32	   3		/* 32 bit GOT entry */
+#define R_386_PLT32	   4		/* 32 bit PLT address */
+#define R_386_COPY	   5		/* Copy symbol at runtime */
+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
+#define R_386_RELATIVE	   8		/* Adjust by program base */
+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
+#define R_386_32PLT	   11
+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
+					   block offset */
+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
+					   offset */
+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
+					   block */
+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
+					   general dynamic thread local data */
+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
+					   local dynamic thread local data
+					   in LE code */
+#define R_386_16	   20
+#define R_386_PC16	   21
+#define R_386_8		   22
+#define R_386_PC8	   23
+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
+					   thread local data */
+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
+					   __tls_get_addr() */
+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
+					   thread local data in LE code */
+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
+					   __tls_get_addr() in LDM code */
+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
+					   block offset */
+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
+					   TLS block */
+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
+/* Keep this the last entry.  */
+#define R_386_NUM	   38
+
+/* FR-V specific definitions.  */
+#define R_FRV_NONE		0	/* No reloc.  */
+#define R_FRV_32		1	/* Direct 32 bit.  */
+/* Canonical function descriptor address.  */
+#define R_FRV_FUNCDESC		14
+/* Private function descriptor initialization.  */
+#define R_FRV_FUNCDESC_VALUE	18
+
+						/* gpr support */
+#define EF_FRV_GPR_MASK		0x00000003	/* mask for # of gprs */
+#define EF_FRV_GPR_32		0x00000001	/* -mgpr-32 */
+#define EF_FRV_GPR_64		0x00000002	/* -mgpr-64 */
+
+						/* fpr support */
+#define EF_FRV_FPR_MASK		0x0000000c	/* mask for # of fprs */
+#define EF_FRV_FPR_32		0x00000004	/* -mfpr-32 */
+#define EF_FRV_FPR_64		0x00000008	/* -mfpr-64 */
+#define EF_FRV_FPR_NONE		0x0000000c	/* -msoft-float */
+
+#define EF_FRV_PIC   0x00000100
+#define EF_FRV_FDPIC 0x00008000
+
+/* SUN SPARC specific definitions.  */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
+
+/* Values for Elf64_Ehdr.e_flags.  */
+
+#define EF_SPARCV9_MM		3
+#define EF_SPARCV9_TSO		0
+#define EF_SPARCV9_PSO		1
+#define EF_SPARCV9_RMO		2
+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
+#define EF_SPARC_EXT_MASK	0xFFFF00
+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
+
+/* SPARC relocs.  */
+
+#define R_SPARC_NONE		0	/* No reloc */
+#define R_SPARC_8		1	/* Direct 8 bit */
+#define R_SPARC_16		2	/* Direct 16 bit */
+#define R_SPARC_32		3	/* Direct 32 bit */
+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
+#define R_SPARC_HI22		9	/* High 22 bit */
+#define R_SPARC_22		10	/* Direct 22 bit */
+#define R_SPARC_13		11	/* Direct 13 bit */
+#define R_SPARC_LO10		12	/* Truncated 10 bit */
+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
+
+/* Additional Sparc64 relocs.  */
+
+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
+#define R_SPARC_10		30	/* Direct 10 bit */
+#define R_SPARC_11		31	/* Direct 11 bit */
+#define R_SPARC_64		32	/* Direct 64 bit */
+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
+#define R_SPARC_7		43	/* Direct 7 bit */
+#define R_SPARC_5		44	/* Direct 5 bit */
+#define R_SPARC_6		45	/* Direct 6 bit */
+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
+#define R_SPARC_REGISTER	53	/* Global register usage */
+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
+#define R_SPARC_TLS_GD_HI22	56
+#define R_SPARC_TLS_GD_LO10	57
+#define R_SPARC_TLS_GD_ADD	58
+#define R_SPARC_TLS_GD_CALL	59
+#define R_SPARC_TLS_LDM_HI22	60
+#define R_SPARC_TLS_LDM_LO10	61
+#define R_SPARC_TLS_LDM_ADD	62
+#define R_SPARC_TLS_LDM_CALL	63
+#define R_SPARC_TLS_LDO_HIX22	64
+#define R_SPARC_TLS_LDO_LOX10	65
+#define R_SPARC_TLS_LDO_ADD	66
+#define R_SPARC_TLS_IE_HI22	67
+#define R_SPARC_TLS_IE_LO10	68
+#define R_SPARC_TLS_IE_LD	69
+#define R_SPARC_TLS_IE_LDX	70
+#define R_SPARC_TLS_IE_ADD	71
+#define R_SPARC_TLS_LE_HIX22	72
+#define R_SPARC_TLS_LE_LOX10	73
+#define R_SPARC_TLS_DTPMOD32	74
+#define R_SPARC_TLS_DTPMOD64	75
+#define R_SPARC_TLS_DTPOFF32	76
+#define R_SPARC_TLS_DTPOFF64	77
+#define R_SPARC_TLS_TPOFF32	78
+#define R_SPARC_TLS_TPOFF64	79
+/* Keep this the last entry.  */
+#define R_SPARC_NUM		80
+
+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
+
+#define DT_SPARC_REGISTER 0x70000001
+#define DT_SPARC_NUM	2
+
+/* Bits present in AT_HWCAP, primarily for Sparc32.  */
+
+#define HWCAP_SPARC_FLUSH	1	/* The cpu supports flush insn.  */
+#define HWCAP_SPARC_STBAR	2
+#define HWCAP_SPARC_SWAP	4
+#define HWCAP_SPARC_MULDIV	8
+#define HWCAP_SPARC_V9		16	/* The cpu is v9, so v8plus is ok.  */
+#define HWCAP_SPARC_ULTRA3	32
+
+/* MIPS R3000 specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
+#define EF_MIPS_PIC	    2		/* Contains PIC code */
+#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
+#define EF_MIPS_XGOT	    8
+#define EF_MIPS_64BIT_WHIRL 16
+#define EF_MIPS_ABI2	    32
+#define EF_MIPS_ABI_ON32    64
+#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
+
+/* Legal values for MIPS architecture level.  */
+
+#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
+#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
+#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
+#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
+#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
+#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
+#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
+
+/* The following are non-official names and should not be used.  */
+
+#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
+#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
+#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
+#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
+#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
+#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
+#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
+
+/* Special section indices.  */
+
+#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
+#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
+#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
+#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
+#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
+#define SHT_MIPS_MSYM	       0x70000001
+#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
+#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
+#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
+#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
+#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
+#define SHT_MIPS_PACKAGE       0x70000007
+#define SHT_MIPS_PACKSYM       0x70000008
+#define SHT_MIPS_RELD	       0x70000009
+#define SHT_MIPS_IFACE         0x7000000b
+#define SHT_MIPS_CONTENT       0x7000000c
+#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
+#define SHT_MIPS_SHDR	       0x70000010
+#define SHT_MIPS_FDESC	       0x70000011
+#define SHT_MIPS_EXTSYM	       0x70000012
+#define SHT_MIPS_DENSE	       0x70000013
+#define SHT_MIPS_PDESC	       0x70000014
+#define SHT_MIPS_LOCSYM	       0x70000015
+#define SHT_MIPS_AUXSYM	       0x70000016
+#define SHT_MIPS_OPTSYM	       0x70000017
+#define SHT_MIPS_LOCSTR	       0x70000018
+#define SHT_MIPS_LINE	       0x70000019
+#define SHT_MIPS_RFDESC	       0x7000001a
+#define SHT_MIPS_DELTASYM      0x7000001b
+#define SHT_MIPS_DELTAINST     0x7000001c
+#define SHT_MIPS_DELTACLASS    0x7000001d
+#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
+#define SHT_MIPS_DELTADECL     0x7000001f
+#define SHT_MIPS_SYMBOL_LIB    0x70000020
+#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
+#define SHT_MIPS_TRANSLATE     0x70000022
+#define SHT_MIPS_PIXIE	       0x70000023
+#define SHT_MIPS_XLATE	       0x70000024
+#define SHT_MIPS_XLATE_DEBUG   0x70000025
+#define SHT_MIPS_WHIRL	       0x70000026
+#define SHT_MIPS_EH_REGION     0x70000027
+#define SHT_MIPS_XLATE_OLD     0x70000028
+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
+#define SHF_MIPS_MERGE	 0x20000000
+#define SHF_MIPS_ADDR	 0x40000000
+#define SHF_MIPS_STRINGS 0x80000000
+#define SHF_MIPS_NOSTRIP 0x08000000
+#define SHF_MIPS_LOCAL	 0x04000000
+#define SHF_MIPS_NAMES	 0x02000000
+#define SHF_MIPS_NODUPE	 0x01000000
+
+
+/* Symbol tables.  */
+
+/* MIPS specific values for `st_other'.  */
+#define STO_MIPS_DEFAULT		0x0
+#define STO_MIPS_INTERNAL		0x1
+#define STO_MIPS_HIDDEN			0x2
+#define STO_MIPS_PROTECTED		0x3
+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
+
+/* MIPS specific values for `st_info'.  */
+#define STB_MIPS_SPLIT_COMMON		13
+
+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
+
+typedef union
+{
+  struct
+    {
+      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
+      Elf32_Word gt_unused;		/* Not used */
+    } gt_header;			/* First entry in section */
+  struct
+    {
+      Elf32_Word gt_g_value;		/* If this value were used for -G */
+      Elf32_Word gt_bytes;		/* This many bytes would be used */
+    } gt_entry;				/* Subsequent entries in section */
+} Elf32_gptab;
+
+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
+
+typedef struct
+{
+  Elf32_Word	ri_gprmask;		/* General registers used */
+  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
+  Elf32_Sword	ri_gp_value;		/* $gp register value */
+} Elf32_RegInfo;
+
+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
+
+typedef struct
+{
+  unsigned char kind;		/* Determines interpretation of the
+				   variable part of descriptor.  */
+  unsigned char size;		/* Size of descriptor, including header.  */
+  Elf32_Section section;	/* Section header index of section affected,
+				   0 for global options.  */
+  Elf32_Word info;		/* Kind-specific information.  */
+} Elf_Options;
+
+/* Values for `kind' field in Elf_Options.  */
+
+#define ODK_NULL	0	/* Undefined.  */
+#define ODK_REGINFO	1	/* Register usage information.  */
+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
+#define ODK_PAD		3	/* Section padding options.  */
+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
+#define ODK_FILL	5	/* record the fill value used by the linker. */
+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
+
+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
+
+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
+#define OEX_PRECISEFP	OEX_FPDBUG
+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
+
+#define OEX_FPU_INVAL	0x10
+#define OEX_FPU_DIV0	0x08
+#define OEX_FPU_OFLO	0x04
+#define OEX_FPU_UFLO	0x02
+#define OEX_FPU_INEX	0x01
+
+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
+
+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
+
+#define OPAD_PREFIX	0x1
+#define OPAD_POSTFIX	0x2
+#define OPAD_SYMBOL	0x4
+
+/* Entry found in `.options' section.  */
+
+typedef struct
+{
+  Elf32_Word hwp_flags1;	/* Extra flags.  */
+  Elf32_Word hwp_flags2;	/* Extra flags.  */
+} Elf_Options_Hw;
+
+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
+
+#define OHWA0_R4KEOP_CHECKED	0x00000001
+#define OHWA1_R4KEOP_CLEAN	0x00000002
+
+/* MIPS relocs.  */
+
+#define R_MIPS_NONE		0	/* No reloc */
+#define R_MIPS_16		1	/* Direct 16 bit */
+#define R_MIPS_32		2	/* Direct 32 bit */
+#define R_MIPS_REL32		3	/* PC relative 32 bit */
+#define R_MIPS_26		4	/* Direct 26 bit shifted */
+#define R_MIPS_HI16		5	/* High 16 bit */
+#define R_MIPS_LO16		6	/* Low 16 bit */
+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
+#define R_MIPS_PC16		10	/* PC relative 16 bit */
+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
+
+#define R_MIPS_SHIFT5		16
+#define R_MIPS_SHIFT6		17
+#define R_MIPS_64		18
+#define R_MIPS_GOT_DISP		19
+#define R_MIPS_GOT_PAGE		20
+#define R_MIPS_GOT_OFST		21
+#define R_MIPS_GOT_HI16		22
+#define R_MIPS_GOT_LO16		23
+#define R_MIPS_SUB		24
+#define R_MIPS_INSERT_A		25
+#define R_MIPS_INSERT_B		26
+#define R_MIPS_DELETE		27
+#define R_MIPS_HIGHER		28
+#define R_MIPS_HIGHEST		29
+#define R_MIPS_CALL_HI16	30
+#define R_MIPS_CALL_LO16	31
+#define R_MIPS_SCN_DISP		32
+#define R_MIPS_REL16		33
+#define R_MIPS_ADD_IMMEDIATE	34
+#define R_MIPS_PJUMP		35
+#define R_MIPS_RELGOT		36
+#define R_MIPS_JALR		37
+#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
+#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
+#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
+#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
+#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
+#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
+#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
+#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
+#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
+#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
+#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
+#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
+#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
+/* Keep this the last entry.  */
+#define R_MIPS_NUM		51
+
+/* Legal values for p_type field of Elf32_Phdr.  */
+
+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
+#define PT_MIPS_OPTIONS 0x70000002
+
+/* Special program header types.  */
+
+#define PF_MIPS_LOCAL	0x10000000
+
+/* Legal values for d_tag field of Elf32_Dyn.  */
+
+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
+#define DT_MIPS_MSYM	     0x70000007
+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
+						DT_MIPS_DELTA_CLASS.  */
+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
+						DT_MIPS_DELTA_INSTANCE.  */
+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
+					     DT_MIPS_DELTA_RELOC.  */
+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
+					   relocations refer to.  */
+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
+					   DT_MIPS_DELTA_SYM.  */
+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
+					     class declaration.  */
+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
+						DT_MIPS_DELTA_CLASSSYM.  */
+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
+#define DT_MIPS_PIXIE_INIT   0x70000023
+#define DT_MIPS_SYMBOL_LIB   0x70000024
+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
+						    function stored in GOT.  */
+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
+					   by rld on dlopen() calls.  */
+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
+#define DT_MIPS_NUM	     0x32
+
+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
+
+#define RHF_NONE		   0		/* No flags */
+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
+#define RHF_NO_MOVE		   (1 << 3)
+#define RHF_SGI_ONLY		   (1 << 4)
+#define RHF_GUARANTEE_INIT	   (1 << 5)
+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
+#define RHF_GUARANTEE_START_INIT   (1 << 7)
+#define RHF_PIXIE		   (1 << 8)
+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
+#define RHF_REQUICKSTART	   (1 << 10)
+#define RHF_REQUICKSTARTED	   (1 << 11)
+#define RHF_CORD		   (1 << 12)
+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
+
+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
+
+typedef struct
+{
+  Elf32_Word l_name;		/* Name (string table index) */
+  Elf32_Word l_time_stamp;	/* Timestamp */
+  Elf32_Word l_checksum;	/* Checksum */
+  Elf32_Word l_version;		/* Interface version */
+  Elf32_Word l_flags;		/* Flags */
+} Elf32_Lib;
+
+typedef struct
+{
+  Elf64_Word l_name;		/* Name (string table index) */
+  Elf64_Word l_time_stamp;	/* Timestamp */
+  Elf64_Word l_checksum;	/* Checksum */
+  Elf64_Word l_version;		/* Interface version */
+  Elf64_Word l_flags;		/* Flags */
+} Elf64_Lib;
+
+
+/* Legal values for l_flags.  */
+
+#define LL_NONE		  0
+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
+#define LL_REQUIRE_MINOR  (1 << 2)
+#define LL_EXPORTS	  (1 << 3)
+#define LL_DELAY_LOAD	  (1 << 4)
+#define LL_DELTA	  (1 << 5)
+
+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
+
+typedef Elf32_Addr Elf32_Conflict;
+
+
+/* HPPA specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
+					      prediction.  */
+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
+
+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
+
+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
+
+/* Additional section indeces.  */
+
+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
+					      symbols in ANSI C.  */
+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
+
+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
+#define STT_HP_STUB		(STT_LOOS + 0x2)
+
+/* HPPA relocs.  */
+
+#define R_PARISC_NONE		0	/* No reloc.  */
+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LORESERVE	128
+#define R_PARISC_COPY		128	/* Copy relocation.  */
+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_HIRESERVE	255
+
+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PT_HP_TLS		(PT_LOOS + 0x0)
+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
+#define PT_HP_STACK		(PT_LOOS + 0x14)
+
+#define PT_PARISC_ARCHEXT	0x70000000
+#define PT_PARISC_UNWIND	0x70000001
+
+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PF_PARISC_SBP		0x08000000
+
+#define PF_HP_PAGE_SIZE		0x00100000
+#define PF_HP_FAR_SHARED	0x00200000
+#define PF_HP_NEAR_SHARED	0x00400000
+#define PF_HP_CODE		0x01000000
+#define PF_HP_MODIFY		0x02000000
+#define PF_HP_LAZYSWAP		0x04000000
+#define PF_HP_SBP		0x08000000
+
+
+/* Alpha specific definitions.  */
+
+/* Legal values for e_flags field of Elf64_Ehdr.  */
+
+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
+
+/* Legal values for sh_type field of Elf64_Shdr.  */
+
+/* These two are primerily concerned with ECOFF debugging info.  */
+#define SHT_ALPHA_DEBUG		0x70000001
+#define SHT_ALPHA_REGINFO	0x70000002
+
+/* Legal values for sh_flags field of Elf64_Shdr.  */
+
+#define SHF_ALPHA_GPREL		0x10000000
+
+/* Legal values for st_other field of Elf64_Sym.  */
+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
+
+/* Alpha relocs.  */
+
+#define R_ALPHA_NONE		0	/* No reloc */
+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
+#define R_ALPHA_TLS_GD_HI	28
+#define R_ALPHA_TLSGD		29
+#define R_ALPHA_TLS_LDM		30
+#define R_ALPHA_DTPMOD64	31
+#define R_ALPHA_GOTDTPREL	32
+#define R_ALPHA_DTPREL64	33
+#define R_ALPHA_DTPRELHI	34
+#define R_ALPHA_DTPRELLO	35
+#define R_ALPHA_DTPREL16	36
+#define R_ALPHA_GOTTPREL	37
+#define R_ALPHA_TPREL64		38
+#define R_ALPHA_TPRELHI		39
+#define R_ALPHA_TPRELLO		40
+#define R_ALPHA_TPREL16		41
+/* Keep this the last entry.  */
+#define R_ALPHA_NUM		46
+
+/* Magic values of the LITUSE relocation addend.  */
+#define LITUSE_ALPHA_ADDR	0
+#define LITUSE_ALPHA_BASE	1
+#define LITUSE_ALPHA_BYTOFF	2
+#define LITUSE_ALPHA_JSR	3
+#define LITUSE_ALPHA_TLS_GD	4
+#define LITUSE_ALPHA_TLS_LDM	5
+
+/* Legal values for d_tag of Elf64_Dyn.  */
+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
+#define DT_ALPHA_NUM		1
+
+/* PowerPC specific declarations */
+
+/* Values for Elf32/64_Ehdr.e_flags.  */
+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
+
+/* Cygnus local bits below */
+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
+						   flag */
+
+/* PowerPC relocations defined by the ABIs */
+#define R_PPC_NONE		0
+#define R_PPC_ADDR32		1	/* 32bit absolute address */
+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
+#define R_PPC_ADDR16		3	/* 16bit absolute address */
+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
+#define R_PPC_ADDR14_BRTAKEN	8
+#define R_PPC_ADDR14_BRNTAKEN	9
+#define R_PPC_REL24		10	/* PC relative 26 bit */
+#define R_PPC_REL14		11	/* PC relative 16 bit */
+#define R_PPC_REL14_BRTAKEN	12
+#define R_PPC_REL14_BRNTAKEN	13
+#define R_PPC_GOT16		14
+#define R_PPC_GOT16_LO		15
+#define R_PPC_GOT16_HI		16
+#define R_PPC_GOT16_HA		17
+#define R_PPC_PLTREL24		18
+#define R_PPC_COPY		19
+#define R_PPC_GLOB_DAT		20
+#define R_PPC_JMP_SLOT		21
+#define R_PPC_RELATIVE		22
+#define R_PPC_LOCAL24PC		23
+#define R_PPC_UADDR32		24
+#define R_PPC_UADDR16		25
+#define R_PPC_REL32		26
+#define R_PPC_PLT32		27
+#define R_PPC_PLTREL32		28
+#define R_PPC_PLT16_LO		29
+#define R_PPC_PLT16_HI		30
+#define R_PPC_PLT16_HA		31
+#define R_PPC_SDAREL16		32
+#define R_PPC_SECTOFF		33
+#define R_PPC_SECTOFF_LO	34
+#define R_PPC_SECTOFF_HI	35
+#define R_PPC_SECTOFF_HA	36
+
+/* PowerPC relocations defined for the TLS access ABI.  */
+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
+
+/* Keep this the last entry.  */
+#define R_PPC_NUM		95
+
+/* The remaining relocs are from the Embedded ELF ABI, and are not
+   in the SVR4 ELF ABI.  */
+#define R_PPC_EMB_NADDR32	101
+#define R_PPC_EMB_NADDR16	102
+#define R_PPC_EMB_NADDR16_LO	103
+#define R_PPC_EMB_NADDR16_HI	104
+#define R_PPC_EMB_NADDR16_HA	105
+#define R_PPC_EMB_SDAI16	106
+#define R_PPC_EMB_SDA2I16	107
+#define R_PPC_EMB_SDA2REL	108
+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
+#define R_PPC_EMB_MRKREF	110
+#define R_PPC_EMB_RELSEC16	111
+#define R_PPC_EMB_RELST_LO	112
+#define R_PPC_EMB_RELST_HI	113
+#define R_PPC_EMB_RELST_HA	114
+#define R_PPC_EMB_BIT_FLD	115
+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
+
+/* Diab tool relocations.  */
+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
+
+/* GNU relocs used in PIC code sequences.  */
+#define R_PPC_REL16		249	/* word32   (sym-.) */
+#define R_PPC_REL16_LO		250	/* half16   (sym-.)@l */
+#define R_PPC_REL16_HI		251	/* half16   (sym-.)@h */
+#define R_PPC_REL16_HA		252	/* half16   (sym-.)@ha */
+
+/* This is a phony reloc to handle any old fashioned TOC16 references
+   that may still be in object files.  */
+#define R_PPC_TOC16		255
+
+/* PowerPC specific values for the Dyn d_tag field.  */
+#define DT_PPC_GOT		(DT_LOPROC + 0)
+#define DT_PPC_NUM		1
+
+/* PowerPC64 relocations defined by the ABIs */
+#define R_PPC64_NONE		R_PPC_NONE
+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
+#define R_PPC64_GOT16		R_PPC_GOT16
+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
+
+#define R_PPC64_COPY		R_PPC_COPY
+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
+
+#define R_PPC64_UADDR32		R_PPC_UADDR32
+#define R_PPC64_UADDR16		R_PPC_UADDR16
+#define R_PPC64_REL32		R_PPC_REL32
+#define R_PPC64_PLT32		R_PPC_PLT32
+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
+
+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
+
+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
+
+/* PowerPC64 relocations defined for the TLS access ABI.  */
+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
+
+/* Keep this the last entry.  */
+#define R_PPC64_NUM		107
+
+/* PowerPC64 specific values for the Dyn d_tag field.  */
+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
+#define DT_PPC64_OPD	(DT_LOPROC + 1)
+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
+#define DT_PPC64_NUM    3
+
+
+/* ARM specific declarations */
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#define EF_ARM_RELEXEC     0x01
+#define EF_ARM_HASENTRY    0x02
+#define EF_ARM_INTERWORK   0x04
+#define EF_ARM_APCS_26     0x08
+#define EF_ARM_APCS_FLOAT  0x10
+#define EF_ARM_PIC         0x20
+#define EF_ARM_ALIGN8      0x40		/* 8-bit structure alignment is in use */
+#define EF_ARM_NEW_ABI     0x80
+#define EF_ARM_OLD_ABI     0x100
+
+/* Other constants defined in the ARM ELF spec. version B-01.  */
+/* NB. These conflict with values defined above.  */
+#define EF_ARM_SYMSARESORTED	0x04
+#define EF_ARM_DYNSYMSUSESEGIDX 0x08
+#define EF_ARM_MAPSYMSFIRST	0x10
+#define EF_ARM_EABIMASK		0XFF000000
+
+#define EF_ARM_EABI_VERSION(flags) ((flags) & EF_ARM_EABIMASK)
+#define EF_ARM_EABI_UNKNOWN  0x00000000
+#define EF_ARM_EABI_VER1     0x01000000
+#define EF_ARM_EABI_VER2     0x02000000
+
+/* Additional symbol types for Thumb */
+#define STT_ARM_TFUNC      0xd
+
+/* ARM-specific values for sh_flags */
+#define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry point */
+#define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply defined
+					   in the input to a link step */
+
+/* ARM-specific program header flags */
+#define PF_ARM_SB          0x10000000   /* Segment contains the location
+					   addressed by the static base */
+
+/* Processor specific values for the Phdr p_type field.  */
+#define PT_ARM_EXIDX	0x70000001	/* .ARM.exidx segment */
+
+/* ARM relocs.  */
+
+#define R_ARM_NONE		0	/* No reloc */
+#define R_ARM_PC24		1	/* PC relative 26 bit branch */
+#define R_ARM_ABS32		2	/* Direct 32 bit  */
+#define R_ARM_REL32		3	/* PC relative 32 bit */
+#define R_ARM_PC13		4
+#define R_ARM_ABS16		5	/* Direct 16 bit */
+#define R_ARM_ABS12		6	/* Direct 12 bit */
+#define R_ARM_THM_ABS5		7
+#define R_ARM_ABS8		8	/* Direct 8 bit */
+#define R_ARM_SBREL32		9
+#define R_ARM_THM_PC22		10
+#define R_ARM_THM_PC8		11
+#define R_ARM_AMP_VCALL9	12
+#define R_ARM_SWI24		13
+#define R_ARM_THM_SWI8		14
+#define R_ARM_XPC25		15
+#define R_ARM_THM_XPC22		16
+#define R_ARM_COPY		20	/* Copy symbol at runtime */
+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
+#define R_ARM_RELATIVE		23	/* Adjust by program base */
+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
+#define R_ARM_PLT32		27	/* 32 bit PLT address */
+#define R_ARM_ALU_PCREL_7_0	32
+#define R_ARM_ALU_PCREL_15_8	33
+#define R_ARM_ALU_PCREL_23_15	34
+#define R_ARM_LDR_SBREL_11_0	35
+#define R_ARM_ALU_SBREL_19_12	36
+#define R_ARM_ALU_SBREL_27_20	37
+#define R_ARM_GNU_VTENTRY	100
+#define R_ARM_GNU_VTINHERIT	101
+#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
+#define R_ARM_THM_PC9		103	/* thumb conditional branch */
+#define R_ARM_RXPC25		249
+#define R_ARM_RSBREL32		250
+#define R_ARM_THM_RPC22		251
+#define R_ARM_RREL32		252
+#define R_ARM_RABS22		253
+#define R_ARM_RPC24		254
+#define R_ARM_RBASE		255
+/* Keep this the last entry.  */
+#define R_ARM_NUM		256
+
+/* IA-64 specific declarations.  */
+
+/* Processor specific flags for the Ehdr e_flags field.  */
+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
+
+/* Processor specific values for the Phdr p_type field.  */
+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
+
+/* Processor specific flags for the Phdr p_flags field.  */
+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Shdr sh_type field.  */
+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
+
+/* Processor specific flags for the Shdr sh_flags field.  */
+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Dyn d_tag field.  */
+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
+#define DT_IA_64_NUM		1
+
+/* IA-64 relocations.  */
+#define R_IA64_NONE		0x00	/* none */
+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
+#define R_IA64_COPY		0x84	/* copy relocation */
+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
+
+/* SH specific declarations */
+
+/* SH specific values for `st_other'.  */
+
+/* If set, this is a symbol pointing to SHmedia code, which will be branched
+   to, so need to add 1 to the symbol value. */
+#define STO_SH5_ISA32 (1 << 2)
+
+/* SH relocs.  */
+#define	R_SH_NONE		0
+#define	R_SH_DIR32		1
+#define	R_SH_REL32		2
+#define	R_SH_DIR8WPN		3
+#define	R_SH_IND12W		4
+#define	R_SH_DIR8WPL		5
+#define	R_SH_DIR8WPZ		6
+#define	R_SH_DIR8BP		7
+#define	R_SH_DIR8W		8
+#define	R_SH_DIR8L		9
+#define	R_SH_SWITCH16		25
+#define	R_SH_SWITCH32		26
+#define	R_SH_USES		27
+#define	R_SH_COUNT		28
+#define	R_SH_ALIGN		29
+#define	R_SH_CODE		30
+#define	R_SH_DATA		31
+#define	R_SH_LABEL		32
+#define	R_SH_SWITCH8		33
+#define	R_SH_GNU_VTINHERIT	34
+#define	R_SH_GNU_VTENTRY	35
+#define	R_SH_TLS_GD_32		144
+#define	R_SH_TLS_LD_32		145
+#define	R_SH_TLS_LDO_32		146
+#define	R_SH_TLS_IE_32		147
+#define	R_SH_TLS_LE_32		148
+#define	R_SH_TLS_DTPMOD32	149
+#define	R_SH_TLS_DTPOFF32	150
+#define	R_SH_TLS_TPOFF32	151
+#define	R_SH_GOT32		160
+#define	R_SH_PLT32		161
+#define	R_SH_COPY		162
+#define	R_SH_GLOB_DAT		163
+#define	R_SH_JMP_SLOT		164
+#define	R_SH_RELATIVE		165
+#define	R_SH_GOTOFF		166
+#define	R_SH_GOTPC		167
+#define	R_SH_RELATIVE_LOW16	197
+#define	R_SH_RELATIVE_MEDLOW16	198
+#define	R_SH_IMM_LOW16		246
+#define	R_SH_IMM_LOW16_PCREL	247
+#define	R_SH_IMM_MEDLOW16	248
+#define	R_SH_IMM_MEDLOW16_PCREL	249
+
+/* Keep this the last entry.  */
+#define	R_SH_NUM		256
+
+/* Additional s390 relocs */
+
+#define R_390_NONE		0	/* No reloc.  */
+#define R_390_8			1	/* Direct 8 bit.  */
+#define R_390_12		2	/* Direct 12 bit.  */
+#define R_390_16		3	/* Direct 16 bit.  */
+#define R_390_32		4	/* Direct 32 bit.  */
+#define R_390_PC32		5	/* PC relative 32 bit.	*/
+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
+#define R_390_COPY		9	/* Copy symbol at runtime.  */
+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
+#define R_390_RELATIVE		12	/* Adjust by program base.  */
+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
+#define R_390_PC16		16	/* PC relative 16 bit.	*/
+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
+#define R_390_64		22	/* Direct 64 bit.  */
+#define R_390_PC64		23	/* PC relative 64 bit.	*/
+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
+					   dynamic TLS code. */
+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
+					   dynamic TLS code. */
+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
+					   thread local data.  */
+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
+					  thread local data.  */
+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
+					   block offset. */
+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
+					   block.  */
+#define R_390_20		57	/* Direct 20 bit.  */
+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
+					   block offset.  */
+/* Keep this the last entry.  */
+#define R_390_NUM		61
+
+
+/* CRIS flags.  */
+#define EF_CRIS_VARIANT_MASK           0x0000000e
+#define EF_CRIS_VARIANT_ANY_V0_V10     0x00000000
+#define EF_CRIS_VARIANT_V32            0x00000002
+#define EF_CRIS_VARIANT_COMMON_V10_V32 0x00000004
+
+/* CRIS relocations.  */
+#define R_CRIS_NONE		0
+#define R_CRIS_8		1
+#define R_CRIS_16		2
+#define R_CRIS_32		3
+#define R_CRIS_8_PCREL		4
+#define R_CRIS_16_PCREL		5
+#define R_CRIS_32_PCREL		6
+#define R_CRIS_GNU_VTINHERIT	7
+#define R_CRIS_GNU_VTENTRY	8
+#define R_CRIS_COPY		9
+#define R_CRIS_GLOB_DAT		10
+#define R_CRIS_JUMP_SLOT	11
+#define R_CRIS_RELATIVE		12
+#define R_CRIS_16_GOT		13
+#define R_CRIS_32_GOT		14
+#define R_CRIS_16_GOTPLT	15
+#define R_CRIS_32_GOTPLT	16
+#define R_CRIS_32_GOTREL	17
+#define R_CRIS_32_PLT_GOTREL	18
+#define R_CRIS_32_PLT_PCREL	19
+
+/* Keep this the last entry.  */
+#define R_CRIS_NUM		20
+
+
+/* AMD x86-64 relocations.  */
+#define R_X86_64_NONE		0	/* No reloc */
+#define R_X86_64_64		1	/* Direct 64 bit  */
+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
+					   offset to GOT */
+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
+					   to two GOT entries for GD symbol */
+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
+					   to two GOT entries for LD symbol */
+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
+					   to GOT entry for IE symbol */
+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
+
+#define R_X86_64_NUM		24
+
+
+/* AM33 relocations.  */
+#define R_MN10300_NONE		0	/* No reloc.  */
+#define R_MN10300_32		1	/* Direct 32 bit.  */
+#define R_MN10300_16		2	/* Direct 16 bit.  */
+#define R_MN10300_8		3	/* Direct 8 bit.  */
+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
+#define R_MN10300_24		9	/* Direct 24 bit.  */
+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
+
+#define R_MN10300_NUM		24
+
+
+/* M32R relocs.  */
+#define R_M32R_NONE		0	/* No reloc. */
+#define R_M32R_16		1	/* Direct 16 bit. */
+#define R_M32R_32		2	/* Direct 32 bit. */
+#define R_M32R_24		3	/* Direct 24 bit. */
+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
+#define R_M32R_LO16		9	/* Low 16 bit. */
+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
+#define R_M32R_GNU_VTINHERIT	11
+#define R_M32R_GNU_VTENTRY	12
+/* M32R relocs use SHT_RELA.  */
+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
+#define R_M32R_RELA_GNU_VTINHERIT	43
+#define R_M32R_RELA_GNU_VTENTRY	44
+
+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
+#define R_M32R_COPY		50	/* Copy symbol at runtime */
+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
+#define R_M32R_RELATIVE		53	/* Adjust by program base */
+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
+					   low */
+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
+					   low */
+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
+					   GOT with unsigned low */
+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
+					   GOT with signed low */
+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
+					   GOT */
+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
+					   with unsigned low */
+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
+					   with signed low */
+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
+#define R_M32R_NUM		256	/* Keep this the last entry. */
+
+/* i960 Relocations */
+#define R_960_NONE      0
+#define R_960_12        1
+#define R_960_32        2
+#define R_960_IP24      3
+#define R_960_SUB       4
+#define R_960_OPTCALL   5
+#define R_960_OPTCALLX  6
+#define R_960_OPTCALLXA 7
+/* Keep this the last entry.  */
+#define R_960_NUM	8
+
+
+/* v850 relocations.  */
+#define R_V850_NONE		0
+#define R_V850_9_PCREL		1
+#define R_V850_22_PCREL		2
+#define R_V850_HI16_S		3
+#define R_V850_HI16		4
+#define R_V850_LO16		5
+#define R_V850_32		6
+#define R_V850_16		7
+#define R_V850_8		8
+#define R_V850_SDA_16_16_OFFSET	9	/* For ld.b, st.b, set1, clr1,
+					   not1, tst1, movea, movhi */
+#define R_V850_SDA_15_16_OFFSET	10	/* For ld.w, ld.h, ld.hu, st.w, st.h */
+#define R_V850_ZDA_16_16_OFFSET	11	/* For ld.b, st.b, set1, clr1,
+					   not1, tst1, movea, movhi */
+#define R_V850_ZDA_15_16_OFFSET	12	/* For ld.w, ld.h, ld.hu, st.w, st.h */
+#define R_V850_TDA_6_8_OFFSET	13	/* For sst.w, sld.w */
+#define R_V850_TDA_7_8_OFFSET	14	/* For sst.h, sld.h */
+#define R_V850_TDA_7_7_OFFSET	15	/* For sst.b, sld.b */
+#define R_V850_TDA_16_16_OFFSET	16	/* For set1, clr1, not1, tst1,
+					   movea, movhi */
+/* CYGNUS LOCAL v850e */
+#define R_V850_TDA_4_5_OFFSET		17	/* For sld.hu */
+#define R_V850_TDA_4_4_OFFSET		18	/* For sld.bu */
+#define R_V850_SDA_16_16_SPLIT_OFFSET	19	/* For ld.bu */
+#define R_V850_ZDA_16_16_SPLIT_OFFSET	20	/* For ld.bu */
+#define R_V850_CALLT_6_7_OFFSET		21	/* For callt */
+#define R_V850_CALLT_16_16_OFFSET	22	/* For callt */
+/* END CYGNUS LOCAL */
+#define R_V850_GNU_VTINHERIT	23
+#define R_V850_GNU_VTENTRY	24
+/* Keep this the last entry.  */
+#define R_V850_NUM		25
+
+
+/* Renesas H8/300 Relocations */
+#define R_H8_NONE       0
+#define R_H8_DIR32      1
+#define R_H8_DIR32_28   2
+#define R_H8_DIR32_24   3
+#define R_H8_DIR32_16   4
+#define R_H8_DIR32U     6
+#define R_H8_DIR32U_28  7
+#define R_H8_DIR32U_24  8
+#define R_H8_DIR32U_20  9
+#define R_H8_DIR32U_16 10
+#define R_H8_DIR24     11
+#define R_H8_DIR24_20  12
+#define R_H8_DIR24_16  13
+#define R_H8_DIR24U    14
+#define R_H8_DIR24U_20 15
+#define R_H8_DIR24U_16 16
+#define R_H8_DIR16     17
+#define R_H8_DIR16U    18
+#define R_H8_DIR16S_32 19
+#define R_H8_DIR16S_28 20
+#define R_H8_DIR16S_24 21
+#define R_H8_DIR16S_20 22
+#define R_H8_DIR16S    23
+#define R_H8_DIR8      24
+#define R_H8_DIR8U     25
+#define R_H8_DIR8Z_32  26
+#define R_H8_DIR8Z_28  27
+#define R_H8_DIR8Z_24  28
+#define R_H8_DIR8Z_20  29
+#define R_H8_DIR8Z_16  30
+#define R_H8_PCREL16   31
+#define R_H8_PCREL8    32
+#define R_H8_BPOS      33
+#define R_H8_PCREL32   34
+#define R_H8_GOT32O    35
+#define R_H8_GOT16O    36
+#define R_H8_DIR16A8   59
+#define R_H8_DIR16R8   60
+#define R_H8_DIR24A8   61
+#define R_H8_DIR24R8   62
+#define R_H8_DIR32A16  63
+#define R_H8_ABS32     65
+#define R_H8_ABS32A16 127
+#define R_H8_NUM      128
+
+/* NIOS relocations. */
+#define R_NIOS_NONE				0
+#define R_NIOS_32				1	/* A 32 bit absolute relocation.*/
+#define R_NIOS_LO16_LO5			2	/* A LO-16 5 bit absolute relocation.  */
+#define R_NIOS_LO16_HI11		3	/* A LO-16 top 11 bit absolute relocation.  */
+#define R_NIOS_HI16_LO5			4	/* A HI-16 5 bit absolute relocation.  */
+#define R_NIOS_HI16_HI11		5	/* A HI-16 top 11 bit absolute relocation.  */
+#define R_NIOS_PCREL6			6	/* A 6 bit relative relocation.  */
+#define R_NIOS_PCREL8			7	/* An 8 bit relative relocation.  */
+#define R_NIOS_PCREL11			8	/* An 11 bit relative relocation.  */
+#define R_NIOS_16				9	/* A 16 bit absolute relocation.  */
+#define R_NIOS_H_LO5			10	/* Low 5-bits of absolute relocation in halfwords.  */
+#define R_NIOS_H_HI11			11	/* Top 11 bits of 16-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_XLO5			12	/* Low 5 bits of top 16-bits of 32-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_XHI11			13	/* Top 11 bits of top 16-bits of 32-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_16				14	/* Half-word @h value */
+#define R_NIOS_H_32				15	/* Word @h value */
+#define R_NIOS_GNU_VTINHERIT	200	/* GNU extension to record C++ vtable hierarchy */
+#define R_NIOS_GNU_VTENTRY		201	/* GNU extension to record C++ vtable member usage */
+/* Keep this the last entry.  */
+#define R_NIOS_NUM				202
+
+/* NIOS II relocations */
+#define R_NIOS2_NONE			0
+#define R_NIOS2_S16				1
+#define R_NIOS2_U16				2
+#define R_NIOS2_PCREL16			3
+#define R_NIOS2_CALL26			4
+#define R_NIOS2_IMM5			5
+#define R_NIOS2_CACHE_OPX 		6
+#define R_NIOS2_IMM6			7
+#define R_NIOS2_IMM8			8
+#define R_NIOS2_HI16			9
+#define R_NIOS2_LO16			10
+#define R_NIOS2_HIADJ16 		11
+#define R_NIOS2_BFD_RELOC_32	12
+#define R_NIOS2_BFD_RELOC_16	13
+#define R_NIOS2_BFD_RELOC_8 	14
+#define R_NIOS2_GPREL			15
+#define R_NIOS2_GNU_VTINHERIT 	16
+#define R_NIOS2_GNU_VTENTRY  	17
+#define R_NIOS2_UJMP			18
+#define R_NIOS2_CJMP			19
+#define R_NIOS2_CALLR			20
+#define R_NIOS2_ALIGN			21
+/* Keep this the last entry.  */
+#define R_NIOS2_NUM				22
+
+__END_DECLS
+
+#endif	/* elf.h */
diff -Nrup a/ldso/include/dl-string.h b/ldso/include/dl-string.h
--- a/ldso/include/dl-string.h	2007-01-25 19:22:03.000000000 -0500
+++ b/ldso/include/dl-string.h	2008-02-28 19:03:13.000000000 -0500
@@ -285,7 +285,9 @@ static __always_inline char * _dl_simple
 /* On some arches constant strings are referenced through the GOT.
  * This requires that load_addr must already be defined... */
 #if defined(mc68000)  || defined(__arm__) || defined(__thumb__) || \
-    defined(__mips__) || defined(__sh__)  || defined(__powerpc__)
+    defined(__mips__) || defined(__sh__)  || defined(__powerpc__) || \
+	defined(__avr32__)
+
 # define CONSTANT_STRING_GOT_FIXUP(X) \
 	if ((X) < (const char *) load_addr) (X) += load_addr
 # define NO_EARLY_SEND_STDERR
diff -Nrup a/ldso/include/dl-syscall.h b/ldso/include/dl-syscall.h
--- a/ldso/include/dl-syscall.h	2007-01-28 00:51:31.000000000 -0500
+++ b/ldso/include/dl-syscall.h	2008-02-28 19:06:04.000000000 -0500
@@ -54,69 +54,69 @@
    dynamic linking at all, so we cannot return any error codes.
    We just punt if there is an error. */
 #define __NR__dl_exit __NR_exit
-static inline _syscall1(void, _dl_exit, int, status);
+static __always_inline _syscall1(void, _dl_exit, int, status);
 
 #define __NR__dl_close __NR_close
-static inline _syscall1(int, _dl_close, int, fd);
+static __always_inline _syscall1(int, _dl_close, int, fd);
 
 #define __NR__dl_open __NR_open
-static inline _syscall3(int, _dl_open, const char *, fn, int, flags,
+static __always_inline _syscall3(int, _dl_open, const char *, fn, int, flags,
                         __kernel_mode_t, mode);
 
 #define __NR__dl_write __NR_write
-static inline _syscall3(unsigned long, _dl_write, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_write, int, fd,
                         const void *, buf, unsigned long, count);
 
 #define __NR__dl_read __NR_read
-static inline _syscall3(unsigned long, _dl_read, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_read, int, fd,
                         const void *, buf, unsigned long, count);
 
 #define __NR__dl_mprotect __NR_mprotect
-static inline _syscall3(int, _dl_mprotect, const void *, addr,
+static __always_inline _syscall3(int, _dl_mprotect, const void *, addr,
                         unsigned long, len, int, prot);
 
 #define __NR__dl_stat __NR_stat
-static inline _syscall2(int, _dl_stat, const char *, file_name,
+static __always_inline _syscall2(int, _dl_stat, const char *, file_name,
                         struct stat *, buf);
 
 #define __NR__dl_fstat __NR_fstat
-static inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
+static __always_inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
 
 #define __NR__dl_munmap __NR_munmap
-static inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
+static __always_inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
 
 #ifdef __NR_getxuid
 # define __NR_getuid __NR_getxuid
 #endif
 #define __NR__dl_getuid __NR_getuid
-static inline _syscall0(uid_t, _dl_getuid);
+static __always_inline _syscall0(uid_t, _dl_getuid);
 
 #ifndef __NR_geteuid
 # define __NR_geteuid __NR_getuid
 #endif
 #define __NR__dl_geteuid __NR_geteuid
-static inline _syscall0(uid_t, _dl_geteuid);
+static __always_inline _syscall0(uid_t, _dl_geteuid);
 
 #ifdef __NR_getxgid
 # define __NR_getgid __NR_getxgid
 #endif
 #define __NR__dl_getgid __NR_getgid
-static inline _syscall0(gid_t, _dl_getgid);
+static __always_inline _syscall0(gid_t, _dl_getgid);
 
 #ifndef __NR_getegid
 # define __NR_getegid __NR_getgid
 #endif
 #define __NR__dl_getegid __NR_getegid
-static inline _syscall0(gid_t, _dl_getegid);
+static __always_inline _syscall0(gid_t, _dl_getegid);
 
 #ifdef __NR_getxpid
 # define __NR_getpid __NR_getxpid
 #endif
 #define __NR__dl_getpid __NR_getpid
-static inline _syscall0(gid_t, _dl_getpid);
+static __always_inline _syscall0(gid_t, _dl_getpid);
 
 #define __NR__dl_readlink __NR_readlink
-static inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
+static __always_inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
                         size_t, bufsiz);
 
 
@@ -134,14 +134,14 @@ static inline _syscall3(int, _dl_readlin
 #if defined(__UCLIBC_MMAP_HAS_6_ARGS__) && defined(__NR_mmap)
 
 # define __NR__dl_mmap __NR_mmap
-static inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
+static __always_inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
                         int, prot, int, flags, int, fd, off_t, offset);
 
 /* then try mmap2() */
 #elif defined(__NR_mmap2)
 
 # define __NR___syscall_mmap2       __NR_mmap2
-static inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
+static __always_inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
                         int, prot, int, flags, int, fd, off_t, offset);
 
 /* Some architectures always use 12 as page shift for mmap2() eventhough the
@@ -152,7 +152,7 @@ static inline _syscall6(__ptr_t, __sysca
 # define MMAP2_PAGE_SHIFT 12
 #endif
 
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
                               int flags, int fd, unsigned long offset)
 {
 	if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
@@ -165,8 +165,8 @@ static inline void * _dl_mmap(void * add
 #elif defined(__NR_mmap)
 
 # define __NR__dl_mmap_real __NR_mmap
-static inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
                               int flags, int fd, unsigned long offset)
 {
 	unsigned long buffer[6];
diff -Nrup a/ldso/ldso/avr32/dl-debug.h b/ldso/ldso/avr32/dl-debug.h
--- a/ldso/ldso/avr32/dl-debug.h	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/dl-debug.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,45 @@
+/*
+ * AVR32 ELF shared libary loader support
+ *
+ * Copyright (C) 2005 Atmel Norway
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static const char *_dl_reltypes_tab[] = {
+    "R_AVR32_NONE",
+    "R_AVR32_32", "R_AVR32_16", "R_AVR32_8",
+    "R_AVR32_32_PCREL", "R_AVR32_16_PCREL", "R_AVR32_8_PCREL",
+    "R_AVR32_DIFF32", "R_AVR32_DIFF16", "R_AVR32_DIFF8",
+    "R_AVR32_GOT32", "R_AVR32_GOT16", "R_AVR32_GOT8",
+    "R_AVR32_21S", "R_AVR32_16U", "R_AVR32_16S", "R_AVR32_8S", "R_AVR32_8S_EXT",
+    "R_AVR32_22H_PCREL", "R_AVR32_18W_PCREL", "R_AVR32_16B_PCREL",
+    "R_AVR32_16N_PCREL", "R_AVR32_14UW_PCREL", "R_AVR32_11H_PCREL",
+    "R_AVR32_10UW_PCREL", "R_AVR32_9H_PCREL", "R_AVR32_9UW_PCREL",
+    "R_AVR32_HI16", "R_AVR32_LO16",
+    "R_AVR32_GOTPC", "R_AVR32_GOTCALL", "R_AVR32_LDA_GOT",
+    "R_AVR32_GOT21S", "R_AVR32_GOT18SW", "R_AVR32_GOT16S", "R_AVR32_GOT7UW",
+    "R_AVR32_32_CPENT", "R_AVR32_CPCALL", "R_AVR32_16_CP", "R_AVR32_9W_CP",
+    "R_AVR32_RELATIVE", "R_AVR32_GLOB_DAT", "R_AVR32_JMP_SLOT",
+    "R_AVR32_ALIGN",
+};
diff -Nrup a/ldso/ldso/avr32/dl-startup.h b/ldso/ldso/avr32/dl-startup.h
--- a/ldso/ldso/avr32/dl-startup.h	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/dl-startup.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,110 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Architecture specific code used by dl-startup.c
+ * Copyright (C) 2005 Atmel Norway
+ */
+
+/* This is the library loader's main entry point. Let _dl_boot2 do its
+ * initializations and jump to the application's entry point
+ * afterwards. */
+asm(	"	.text\n"
+	"	.global	_start\n"
+	"	.type	_start,@function\n"
+	"_start:\n"
+	/* All arguments are on the stack initially */
+	"	mov	r12, sp\n"
+	"	rcall	_dl_start\n"
+	/* Returns user entry point in r12. Save it. */
+	"	mov	r0, r12\n"
+	/* We're PIC, so get the Global Offset Table */
+	"	lddpc	r6, .L_GOT\n"
+	".L_RGOT:\n"
+	"	rsub	r6, pc\n"
+	/* Adjust argc and argv according to _dl_skip_args */
+	"	ld.w	r1, r6[_dl_skip_args@got]\n"
+	"	ld.w	r1, r1[0]\n"
+	"	ld.w	r2, sp++\n"
+	"	sub	r2, r1\n"
+	"	add	sp, sp, r1 << 2\n"
+	"	st.w	--sp, r2\n"
+	/* Load the finalizer function */
+	"	ld.w	r12, r6[_dl_fini@got]\n"
+	/* Jump to the user's entry point */
+	"	mov	pc, r0\n\n"
+
+	"	.align	2\n"
+	".L_GOT:"
+	"	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_\n"
+	"	.size	_start, . - _start\n"
+	"	.previous\n");
+
+/* Get a pointer to the argv array.  On many platforms this can be just
+ * the address if the first argument, on other platforms we need to
+ * do something a little more subtle here. */
+#define GET_ARGV(ARGVP, ARGS) ARGVP = ((unsigned long *)ARGS + 1)
+
+
+/* We can't call functions before the GOT has been initialized */
+#define NO_FUNCS_BEFORE_BOOTSTRAP
+
+/*
+ * Relocate the GOT during dynamic loader bootstrap.  This will add
+ * the load address to all entries in the GOT, which is necessary
+ * because the linker doesn't generate R_AVR32_RELATIVE relocs for the
+ * GOT.
+ */
+static __always_inline
+void PERFORM_BOOTSTRAP_GOT(struct elf_resolve *tpnt)
+{
+	Elf32_Addr i, nr_got;
+	register Elf32_Addr *__r6 __asm__("r6");
+	Elf32_Addr *got = __r6;
+
+	nr_got = tpnt->dynamic_info[DT_AVR32_GOTSZ_IDX] / sizeof(*got);
+	for (i = 2; i < nr_got; i++)
+		got[i] += tpnt->loadaddr;
+}
+
+#define PERFORM_BOOTSTRAP_GOT(tpnt) PERFORM_BOOTSTRAP_GOT(tpnt)
+
+/* Handle relocation of the symbols in the dynamic loader. */
+static __always_inline
+void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
+			     unsigned long symbol_addr,
+			     unsigned long load_addr, Elf32_Sym *symtab)
+{
+	switch(ELF32_R_TYPE(rpnt->r_info)) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr;
+		break;
+	case R_AVR32_RELATIVE:
+		SEND_STDERR_DEBUG("Applying RELATIVE relocation: ");
+		SEND_ADDRESS_STDERR_DEBUG(load_addr, 0);
+		SEND_STDERR_DEBUG(" + ");
+		SEND_ADDRESS_STDERR_DEBUG(rpnt->r_addend, 1);
+		*reloc_addr = load_addr + rpnt->r_addend;
+		break;
+	default:
+		SEND_STDERR("BOOTSTRAP_RELOC: unhandled reloc_type ");
+		SEND_NUMBER_STDERR(ELF32_R_TYPE(rpnt->r_info), 1);
+		SEND_STDERR("REL, SYMBOL, LOAD: ");
+		SEND_ADDRESS_STDERR(reloc_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(symbol_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(load_addr, 1);
+		_dl_exit(1);
+	}
+}
+
+/* Transfer control to the user's application, once the dynamic loader
+ * is done. This routine has to exit the current function, then call
+ * the _dl_elf_main function.
+ *
+ * Since our _dl_boot will simply call whatever is returned by
+ * _dl_boot2, we can just return the address we're supposed to
+ * call.  */
+#define START()	return _dl_elf_main;
diff -Nrup a/ldso/ldso/avr32/dl-syscalls.h b/ldso/ldso/avr32/dl-syscalls.h
--- a/ldso/ldso/avr32/dl-syscalls.h	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/dl-syscalls.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,5 @@
+/* We can't use the real errno in ldso, since it has not yet
+ * been dynamicly linked in yet. */
+extern int _dl_errno;
+#define __set_errno(X) {(_dl_errno) = (X);}
+#include "sys/syscall.h"
diff -Nrup a/ldso/ldso/avr32/dl-sysdep.h b/ldso/ldso/avr32/dl-sysdep.h
--- a/ldso/ldso/avr32/dl-sysdep.h	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/dl-sysdep.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,103 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Various assembly language/system dependent hacks that are required
+ * so that we can minimize the amount of platform specific code.
+ * Copyright (C) 2004-2005 Atmel Norway
+ */
+
+/* Define this if the system uses RELOCA. */
+#define ELF_USES_RELOCA
+
+#include <elf.h>
+
+#define ARCH_NUM 1
+#define DT_AVR32_GOTSZ_IDX	(DT_NUM + OS_NUM)
+
+#define ARCH_DYNAMIC_INFO(dpnt, dynamic, debug_addr)			\
+	do {								\
+		if (dpnt->d_tag == DT_AVR32_GOTSZ)			\
+			dynamic[DT_AVR32_GOTSZ_IDX] = dpnt->d_un.d_val;	\
+	} while (0)
+
+/* Initialization sequence for the application/library GOT. */
+#define INIT_GOT(GOT_BASE,MODULE)					\
+	do {								\
+		unsigned long i, nr_got;				\
+									\
+		GOT_BASE[0] = (unsigned long) _dl_linux_resolve;	\
+		GOT_BASE[1] = (unsigned long) MODULE;			\
+									\
+		/* Add load address displacement to all GOT entries */	\
+		nr_got = MODULE->dynamic_info[DT_AVR32_GOTSZ_IDX] / 4;	\
+		for (i = 2; i < nr_got; i++)				\
+			GOT_BASE[i] += (unsigned long)MODULE->loadaddr;	\
+	} while (0)
+
+#define do_rem(result, n, base)	((result) = (n) % (base))
+
+/* Here we define the magic numbers that this dynamic loader should accept */
+#define MAGIC1 EM_AVR32
+#undef MAGIC2
+
+/* Used for error messages */
+#define ELF_TARGET "AVR32"
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got);
+
+/* 4096 bytes alignment */
+#define PAGE_ALIGN 0xfffff000
+#define ADDR_ALIGN 0xfff
+#define OFFS_ALIGN 0x7ffff000
+
+#define elf_machine_type_class(type)				\
+	((type == R_AVR32_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)
+
+/* AVR32 doesn't need any COPY relocs */
+#define DL_NO_COPY_RELOCS
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+	register Elf32_Addr *got asm ("r6");
+	return *got;
+}
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+	extern void __dl_start asm("_dl_start");
+	Elf32_Addr got_addr = (Elf32_Addr) &__dl_start;
+	Elf32_Addr pcrel_addr;
+
+	asm   ("	lddpc	%0, 2f\n"
+	       "1:	add	%0, pc\n"
+	       "	rjmp	3f\n"
+	       "	.align	2\n"
+	       "2:	.long	_dl_start - 1b\n"
+	       "3:\n"
+	       : "=r"(pcrel_addr) : : "cc");
+
+	return pcrel_addr - got_addr;
+}
+
+/*
+ * Perform any RELATIVE relocations specified by DT_RELCOUNT.
+ * Currently, we don't use that tag, but we might in the future as
+ * this would reduce the startup time somewhat (although probably not by much).
+ */
+static inline void
+elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
+		      Elf32_Word relative_count)
+{
+	Elf32_Rela *rpnt = (void *)rel_addr;
+
+	do {
+		Elf32_Addr *reloc_addr;
+		reloc_addr = (void *)(load_off + (rpnt++)->r_offset);
+		*reloc_addr = load_off + rpnt->r_addend;
+	} while (--relative_count);
+}
diff -Nrup a/ldso/ldso/avr32/elfinterp.c b/ldso/ldso/avr32/elfinterp.c
--- a/ldso/ldso/avr32/elfinterp.c	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/elfinterp.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,191 @@
+/*
+ * AVR32 ELF shared library loader suppport
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got)
+{
+	struct elf_resolve *tpnt = (struct elf_resolve *)got[1];
+	Elf32_Sym *sym;
+	unsigned long local_gotno;
+	unsigned long gotsym;
+	unsigned long new_addr;
+	char *strtab, *symname;
+	unsigned long *entry;
+	unsigned long sym_index = got_offset / 4;
+
+#if 0
+	local_gotno = tpnt->dynamic_info[DT_AVR32_LOCAL_GOTNO];
+	gotsym = tpnt->dynamic_info[DT_AVR32_GOTSYM];
+
+	sym = ((Elf32_Sym *)(tpnt->dynamic_info[DT_SYMTAB] + tpnt->loadaddr))
+		+ sym_index;
+	strtab = (char *)(tpnt->dynamic_info[DT_STRTAB] + tpnt->loadaddr);
+	symname = strtab + sym->st_name;
+
+#if 0
+	new_addr = (unsigned long) _dl_find_hash(strtab + sym->st_name,
+						 tpnt->symbol_scope, tpnt,
+						 resolver);
+#endif
+
+	entry = (unsigned long *)(got + local_gotno + sym_index - gotsym);
+	*entry = new_addr;
+#endif
+
+	return new_addr;
+}
+
+static int
+_dl_parse(struct elf_resolve *tpnt, struct dyn_elf *scope,
+	  unsigned long rel_addr, unsigned long rel_size,
+	  int (*reloc_func)(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			    Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab))
+{
+	Elf32_Sym *symtab;
+	Elf32_Rela *rpnt;
+	char *strtab;
+	int i;
+
+	rpnt = (Elf32_Rela *)rel_addr;
+	rel_size /= sizeof(Elf32_Rela);
+	symtab = (Elf32_Sym *)tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+
+	for (i = 0; i < rel_size; i++, rpnt++) {
+		int symtab_index, res;
+
+		symtab_index = ELF32_R_SYM(rpnt->r_info);
+
+		debug_sym(symtab, strtab, symtab_index);
+		debug_reloc(symtab, strtab, rpnt);
+
+		res = reloc_func(tpnt, scope, rpnt, symtab, strtab);
+
+		if (res == 0)
+			continue;
+
+		_dl_dprintf(2, "\n%s: ", _dl_progname);
+
+		if (symtab_index)
+			_dl_dprintf(2, "symbol '%s': ",
+				    strtab + symtab[symtab_index].st_name);
+
+		if (res < 0) {
+			int reloc_type = ELF32_R_TYPE(rpnt->r_info);
+#if defined(__SUPPORT_LD_DEBUG__)
+			_dl_dprintf(2, "can't handle reloc type %s\n",
+				    _dl_reltypes(reloc_type));
+#else
+			_dl_dprintf(2, "can't handle reloc type %x\n",
+				    reloc_type);
+#endif
+			_dl_exit(-res);
+		} else {
+			_dl_dprintf(2, "can't resolve symbol\n");
+			return res;
+		}
+	}
+
+	return 0;
+}
+
+static int _dl_do_reloc(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab)
+{
+	int reloc_type;
+	int symtab_index;
+	char *symname;
+	unsigned long *reloc_addr;
+	unsigned long symbol_addr;
+#if defined(__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+
+	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
+	reloc_type = ELF32_R_TYPE(rpnt->r_info);
+	symtab_index = ELF32_R_SYM(rpnt->r_info);
+	symbol_addr = 0;
+	symname = strtab + symtab[symtab_index].st_name;
+
+	if (symtab_index) {
+		symbol_addr = (unsigned long)
+			_dl_find_hash(strtab + symtab[symtab_index].st_name,
+				      tpnt->symbol_scope, tpnt,
+				      elf_machine_type_class(reloc_type));
+
+		/* Allow undefined references to weak symbols */
+		if (!symbol_addr &&
+		    ELF32_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
+			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n",
+				    _dl_progname, symname);
+			return 0;
+		}
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	old_val = *reloc_addr;
+#endif
+	switch (reloc_type) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr + rpnt->r_addend;
+		break;
+	case R_AVR32_RELATIVE:
+		*reloc_addr = (unsigned long)tpnt->loadaddr
+			+ rpnt->r_addend;
+		break;
+	default:
+		return -1;
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
+			    old_val, *reloc_addr);
+#endif
+
+	return 0;
+}
+
+void _dl_parse_lazy_relocation_information(struct dyn_elf *rpnt,
+					   unsigned long rel_addr,
+					   unsigned long rel_size)
+{
+	/* TODO: Might want to support this in order to get faster
+	 * startup times... */
+}
+
+int _dl_parse_relocation_information(struct dyn_elf *rpnt,
+				     unsigned long rel_addr,
+				     unsigned long rel_size)
+{
+	return _dl_parse(rpnt->dyn, rpnt->dyn->symbol_scope, rel_addr, rel_size,
+			 _dl_do_reloc);
+}
diff -Nrup a/ldso/ldso/avr32/resolve.S b/ldso/ldso/avr32/resolve.S
--- a/ldso/ldso/avr32/resolve.S	1969-12-31 19:00:00.000000000 -0500
+++ b/ldso/ldso/avr32/resolve.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,28 @@
+/*
+ * Linux dynamic resolving code for AVR32. Fixes up the GOT entry as
+ * indicated in register r12 and jumps to the resolved address.
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ *
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define ip r5
+
+	.text
+	.global	_dl_linux_resolve
+	.type	_dl_linux_resolve,@function
+_dl_linux_resolve:
+	/* The PLT code pushed r8 for us. It contains the address of this
+	   function's GOT entry, that is entry 0. ip contains the address
+	   of the GOT entry of the function we wanted to call. */
+	stm	--sp, r9-r12, lr
+	mov	r11, r8
+	sub	r12, ip, r8
+	rcall	_dl_linux_resolver
+	mov	ip, r12
+	popm	r8-r12,lr
+	mov	pc, ip
+	.size	_dl_linux_resolve, . - _dl_linux_resolve
diff -Nrup a/ldso/ldso/dl-startup.c b/ldso/ldso/dl-startup.c
--- a/ldso/ldso/dl-startup.c	2007-01-25 19:22:03.000000000 -0500
+++ b/ldso/ldso/dl-startup.c	2008-02-28 19:02:10.000000000 -0500
@@ -217,7 +217,9 @@ static void * __attribute_used__ _dl_sta
 	/* some arches (like MIPS) we have to tweak the GOT before relocations */
 	PERFORM_BOOTSTRAP_GOT(tpnt);
 
-#else
+#endif
+
+#if !defined(PERFORM_BOOTSTRAP_GOT) || defined(__avr32__)
 
 	/* OK, now do the relocations.  We do not do a lazy binding here, so
 	   that once we are done, we have considerably more flexibility. */
@@ -259,7 +261,7 @@ static void * __attribute_used__ _dl_sta
 				rel_addr += relative_count * sizeof(ELF_RELOC);;
 			}
 
-			rpnt = (ELF_RELOC *) (rel_addr + load_addr);
+			rpnt = (ELF_RELOC *) (rel_addr /* + load_addr */);
 			for (i = 0; i < rel_size; i += sizeof(ELF_RELOC), rpnt++) {
 				reloc_addr = (unsigned long *) (load_addr + (unsigned long) rpnt->r_offset);
 				symtab_index = ELF_R_SYM(rpnt->r_info);
diff -Nrup a/libc/Makefile b/libc/Makefile
--- a/libc/Makefile	2007-02-28 16:23:09.000000000 -0500
+++ b/libc/Makefile	2008-02-28 19:02:10.000000000 -0500
@@ -59,7 +59,7 @@ $(LIBNAME) shared_$(LIBNAME) ar-target: 
 	$(AR) dN 2 $(LIBNAME) $$objs && \
 	$(AR) dN 2 $(LIBNAME) $$objs
 	@for objfile in obj.signal \
-	                obj.string.generic obj.string.$(TARGET_ARCH) obj.string \
+	                obj.string obj.string.generic obj.string.$(TARGET_ARCH) \
 	                obj.sysdeps.common obj.sysdeps.$(TARGET_ARCH) ; do \
 		if [ -e $$objfile ] ; then \
 			if [ "$(MAKE_IS_SILENT)" = "n" ] ; then \
diff -Nrup a/libc/string/avr32/bcopy.S b/libc/string/avr32/bcopy.S
--- a/libc/string/avr32/bcopy.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/bcopy.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+	.text
+	.global bcopy
+	.type	bcopy, @function
+	.align	1
+bcopy:
+	/* Swap the first two arguments */
+	eor	r11, r12
+	eor	r12, r11
+	eor	r11, r12
+	rjmp	__memmove
+	.size	bcopy, . - bcopy
diff -Nrup a/libc/string/avr32/bzero.S b/libc/string/avr32/bzero.S
--- a/libc/string/avr32/bzero.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/bzero.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+	.text
+	.global bzero
+	.type	bzero, @function
+	.align	1
+bzero:
+	mov	r10, r11
+	mov	r11, 0
+	rjmp	__memset
diff -Nrup a/libc/string/avr32/Makefile b/libc/string/avr32/Makefile
--- a/libc/string/avr32/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/Makefile	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,40 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../
+include $(TOPDIR)Rules.mak
+
+SSRC	:= bcopy.S bzero.S memcmp.S memcpy.S memmove.S
+SSRC	+= memset.S strcmp.S strlen.S
+# memchr.S, strcat.S, strcpy.S, strncpy.S is broken
+SOBJS	:= $(patsubst %.S,%.o, $(SSRC))
+OBJS	:= $(SOBJS)
+
+OBJ_LIST:= ../../obj.string.$(TARGET_ARCH)
+
+all: $(OBJ_LIST)
+
+$(OBJ_LIST): $(OBJS)
+	echo $(addprefix string/$(TARGET_ARCH)/, $(OBJS)) > $@
+
+$(SOBJS): %.o: %.S
+	$(CC) $(ASFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $@
+
+clean:
+	$(RM) *.[oa] *~ core
diff -Nrup a/libc/string/avr32/memchr.S b/libc/string/avr32/memchr.S
--- a/libc/string/avr32/memchr.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/memchr.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define str r12
+#define chr r11
+#define len r10
+
+	.text
+	.global memchr
+	.type	memchr, @function
+memchr:
+	or	chr, chr, chr << 8
+	or	chr, chr, chr << 16
+
+	mov	r9, str
+	andl	r9, 3, COH
+	brne	.Lunaligned_str
+
+1:	sub	len, 4
+	brlt	2f
+	ld.w	r8, str++
+	psub.b	r9, r8, r11
+	tnbz	r9
+	brne	1b
+
+	sub	str, 4
+	bfextu	r9, r8, 24, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	bfextu	r9, r8, 16, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	bfextu	r9, r8, 8, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	retal	str
+
+2:	sub	len, -4
+	reteq	0
+
+3:	ld.ub	r8, str++
+	cp.w	r8, 0
+	reteq	str
+	sub	len, 1
+	brne	3b
+
+	retal	0
+
+.Lunaligned_str:
+1:	sub	len, 1
+	retlt	0
+	ld.ub	r8, str++
+	cp.b	r8, r11
+	reteq	str
+	sub	r9, 1
+	brge	1b
+
+	rjmp	.Laligned_search
diff -Nrup a/libc/string/avr32/memcmp.S b/libc/string/avr32/memcmp.S
--- a/libc/string/avr32/memcmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/memcmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global memcmp
+	.type	memcmp, @function
+	.align	1
+memcmp:
+	sub	len, 4
+	brlt	.Lless_than_4
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	.Lfound_word
+	sub	len, 4
+	brge	1b
+
+.Lless_than_4:
+	sub	len, -4
+	reteq	0
+
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	sub	len, 1
+	brgt	1b
+
+	retal	0
+
+.Lfound_word:
+	psub.b	r9, r8, r9
+	bfextu	r8, r9, 24, 8
+	retne	r8
+	bfextu	r8, r9, 16, 8
+	retne	r8
+	bfextu	r8, r9, 8, 8
+	retne	r8
+	retal	r9
+
+	.size	memcmp, . - memcmp
+
+	.weak	bcmp
+	bcmp = memcmp
diff -Nrup a/libc/string/avr32/memcpy.S b/libc/string/avr32/memcpy.S
--- a/libc/string/avr32/memcpy.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/memcpy.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+/* Don't use r12 as dst since we must return it unmodified */
+#define dst r9
+#define src r11
+#define len r10
+
+	.text
+	.global	memcpy
+	.type	memcpy, @function
+
+	.global	__memcpy
+	.hidden	__memcpy
+	.type	__memcpy, @function
+memcpy:
+__memcpy:
+	pref	src[0]
+	mov	dst, r12
+
+	/* If we have less than 32 bytes, don't do anything fancy */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, src++
+	st.b	dst++, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, dst
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	ldm	src, r0-r7
+	sub	src, -32
+	stm	dst, r0-r7
+	sub	dst, -32
+	sub	len, 32
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	ldm	src, r0-r3
+	sub	src, -16
+	sub	len, 16
+	stm	dst, r0-r3
+	sub	dst, -16
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	neg	len
+	add	pc, pc, len << 2
+	.rept	15
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	rsub	r8, r8, 32
+	sub	len, r8
+1:	ld.ub	r0, src++
+	st.b	dst++, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[0]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, src++
+	st.w	dst++, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+	.size	memcpy, . - memcpy
diff -Nrup a/libc/string/avr32/memmove.S b/libc/string/avr32/memmove.S
--- a/libc/string/avr32/memmove.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/memmove.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define dst r12
+#define src r11
+#define len r10
+
+	.text
+	.global memmove
+	.type	memmove, @function
+
+	.global	__memmove
+	.hidden	__memmove
+	.type	__memmove, @function
+memmove:
+__memmove:
+	cp.w	src, dst
+	brge	__memcpy
+
+	add	dst, len
+	add	src, len
+	pref	src[-1]
+
+	/*
+	 * The rest is basically the same as in memcpy.S except that
+	 * the direction is reversed.
+	 */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, --src
+	st.b	--dst, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, r12
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	sub	src, 32
+	ldm	src, r0-r7
+	sub	dst, 32
+	sub	len, 32
+	stm	dst, r0-r7
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	sub	src, 16
+	ldm	src, r0-r3
+	sub	dst, 16
+	sub	len, 16
+	stm	dst, r0-r3
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	sub	len, -16
+	breq	2f
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	len, 1
+	brne	1b
+
+2:	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	sub	len, r8
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[-4]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, --src
+	st.w	--dst, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, --src
+	st.b	--dst, r0
+	.endr
+
+	popm	r0-r7, pc
diff -Nrup a/libc/string/avr32/memset.S b/libc/string/avr32/memset.S
--- a/libc/string/avr32/memset.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/memset.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s r12
+#define c r11
+#define n r10
+
+	.text
+	.global memset
+	.type	memset, @function
+
+	.global	__memset
+	.hidden	__memset
+	.type	__memset, @function
+
+	.align	1
+memset:
+__memset:
+	cp.w	n, 32
+	mov	r9, s
+	brge	.Llarge_memset
+
+	sub	n, 1
+	retlt	s
+1:	st.b	s++, c
+	sub	n, 1
+	brge	1b
+
+	retal	r9
+
+.Llarge_memset:
+	mov	r8, r11
+	mov	r11, 3
+	bfins	r8, r8, 8, 8
+	bfins	r8, r8, 16, 16
+	tst	s, r11
+	breq	2f
+
+1:	st.b	s++, r8
+	sub	n, 1
+	tst	s, r11
+	brne	1b
+
+2:	mov	r11, r9
+	mov	r9, r8
+	sub	n, 8
+
+3:	st.d	s++, r8
+	sub	n, 8
+	brge	3b
+
+	/* If we are done, n == -8 and we'll skip all st.b insns below */
+	neg	n
+	lsl	n, 1
+	add	pc, n
+	.rept	7
+	st.b	s++, r8
+	.endr
+	retal	r11
diff -Nrup a/libc/string/avr32/strcat.S b/libc/string/avr32/strcat.S
--- a/libc/string/avr32/strcat.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/strcat.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define s1 r9
+#define s2 r11
+
+	.text
+	.global strcat
+	.type	strcat, @function
+	.align	1
+strcat:
+	mov	s1, r12
+
+	/* Make sure s1 is word-aligned */
+	mov	r10, s1
+	andl	r10, 3, COH
+	breq	2f
+
+	add	pc, pc, r10 << 3
+	sub	r0, r0, 0	/* 4-byte nop */
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	2f
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	3f
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	4f
+
+	/* Find the end of the first string */
+5:	ld.w	r8, s1++
+	tnbz	r8
+	brne	5b
+
+	sub	s1, 4
+
+	bfextu	r10, r8, 24, 8
+	cp.w	r10, 0
+	breq	1f
+	sub	s1, -1
+	bfextu	r10, r8, 16, 8
+	cp.w	r10, 0
+	breq	2f
+	sub	s1, -1
+	bfextu	r10, r8, 8, 8
+	cp.w	r10, 0
+	breq	3f
+	sub	s1, -1
+	rjmp	4f
+
+	/* Now, append s2 */
+1:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+2:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+3:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+4:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+
+	/* Copy one word at a time */
+	ld.w	r8, s2++
+	tnbz	r8
+	breq	2f
+1:	st.w	r8, s2++
+	ld.w	r8, s2++
+	tnbz	r8
+	brne	1b
+
+	/* Copy the remaining bytes */
+	bfextu	r10, r8, 24, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 16, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 8, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	st.b	s1++, r8
+	retal	r12
+	.size	strcat, . - strcat
diff -Nrup a/libc/string/avr32/strcmp.S b/libc/string/avr32/strcmp.S
--- a/libc/string/avr32/strcmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/strcmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global strcmp
+	.type	strcmp, @function
+	.align	1
+strcmp:
+	mov	r8, 3
+	tst	s1, r8
+	brne	.Lunaligned_s1
+	tst	s2, r8
+	brne	.Lunaligned_s2
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	2f
+	tnbz	r8
+	brne	1b
+	retal	0
+
+2:	bfextu	r12, r8, 24, 8
+	bfextu	r11, r9, 24, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 16, 8
+	bfextu	r11, r9, 16, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 8, 8
+	bfextu	r11, r9, 8, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 0, 8
+	bfextu	r11, r9, 0, 8
+	sub	r12, r11
+	retal	r12
+
+.Lunaligned_s1:
+3:	tst	s1, r8
+	breq	4f
+	ld.ub	r10, s1++
+	ld.ub	r9, s2++
+	sub	r10, r9
+	retne	r10
+	cp.w	r9, 0
+	brne	3b
+	retal	r10
+
+4:	tst	s2, r8
+	breq	1b
+
+.Lunaligned_s2:
+	/*
+	 * s1 and s2 can't both be aligned, and unaligned word loads
+	 * can trigger spurious exceptions if we cross a page boundary.
+	 * Do it the slow way...
+	 */
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	cp.w	r9, 0
+	brne	1b
+	retal	0
+
+	.weak	strcoll
+	strcoll	= strcmp
diff -Nrup a/libc/string/avr32/strcpy.S b/libc/string/avr32/strcpy.S
--- a/libc/string/avr32/strcpy.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/strcpy.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * To reduce the size, this one might simply call strncpy with len = -1.
+ */
+
+#define dst r9
+#define src r11
+
+	.text
+	.global strcpy
+	.type	strcpy, @function
+strcpy:
+	mov	dst, r12
+
+	pref	src[0]
+
+	/*
+	 * Check alignment. If src is aligned but dst isn't, we can't
+	 * do much about it...
+	 */
+	mov	r8, src
+	andl	r8, 3 COH
+	brne	.Lunaligned_src
+
+.Laligned_copy:
+1:	ld.w	r8, src++
+	tnbz	r8
+	breq	2f
+	st.w	dst++, r8
+	rjmp	1b
+
+2:	/*
+	 * Ok, r8 now contains the terminating '\0'. Copy the
+	 * remaining bytes individually.
+	 */
+	bfextu	r10, r8, 24, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 16, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 8, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	st.b	dst++, r8
+	retal	r12
+
+.Lunaligned_src:
+	/* Copy bytes until we're aligned */
+	rsub	r8, r8, 4
+	add	pc, pc, r8 << 3
+	nop
+	nop
+	ld.ub	r10, src++
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+
+	rjmp	.Laligned_copy
diff -Nrup a/libc/string/avr32/stringtest.c b/libc/string/avr32/stringtest.c
--- a/libc/string/avr32/stringtest.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/stringtest.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,144 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <sys/mman.h>
+
+#define BUF_SIZE (8 * 1024)
+
+static char *buf1;
+static char *buf1_ref;
+static char *buf2;
+
+extern void *optimized_memcpy(void *dest, void *src, size_t len);
+extern void *optimized_memmove(void *dest, void *src, size_t len);
+extern char *optimized_strcpy(char *dest, char *src);
+extern char *optimized_strncpy(char *dest, char *src, size_t len);
+
+void dump_mismatch(char *buf, char *ref, size_t len)
+{
+	int i, j;
+
+	for (i = 0; i < len; i += 16) {
+		if (memcmp(buf + i, ref + i, 16) == 0)
+			continue;
+
+		printf("%4x buf:", i);
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", buf[j]);
+		printf("\n     ref:");
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", ref[j]);
+		printf("\n");
+	}
+}
+
+static void test_memcpy(int src_offset, int dst_offset, int len)
+{
+	clock_t start, old, new;
+	int i;
+
+	memset(buf1, 0x55, BUF_SIZE);
+	memset(buf1_ref, 0x55, BUF_SIZE);
+	memset(buf2, 0xaa, BUF_SIZE);
+
+	printf("Testing memcpy with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	start = clock();
+	for (i = 0; i < 8192; i++)
+		optimized_memcpy(buf1 + dst_offset, buf2 + src_offset, len);
+	new = clock() - start;
+	start = clock();
+	for ( i = 0; i < 8192; i++)
+		memcpy(buf1_ref + dst_offset, buf2 + src_offset, len);
+	old = clock() - start;
+
+	if (memcmp(buf1, buf1_ref, BUF_SIZE) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, BUF_SIZE);
+	}
+	printf("CPU time used: %d vs. %d\n", new, old);
+}
+
+static void test_memmove(int src_offset, int dst_offset, int len)
+{
+	clock_t start, old, new;
+
+	memset(buf1, 0x55, BUF_SIZE);
+	memset(buf1_ref, 0x55, BUF_SIZE);
+	memset(buf2, 0xaa, BUF_SIZE);
+
+	printf("Testing memmove with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	start = clock();
+	optimized_memmove(buf1 + dst_offset, buf2 + src_offset, len);
+	new = clock() - start;
+	start = clock();
+	memmove(buf1_ref + dst_offset, buf2 + src_offset, len);
+	old = clock() - start;
+
+	if (memcmp(buf1, buf1_ref, BUF_SIZE) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, BUF_SIZE);
+	}
+	printf("CPU time used: %d vs. %d\n", new, old);
+}
+
+int main(int argc, char *argv[])
+{
+	buf2 = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf2 == MAP_FAILED) {
+		perror("Failed to allocate memory for buf2");
+		return 1;
+	}
+	buf1 = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf1 == MAP_FAILED) {
+		perror("Failed to allocate memory for buf1");
+		return 1;
+	}
+	buf1_ref = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf1_ref == MAP_FAILED) {
+		perror("Failed to allocate memory for buf1_ref");
+		return 1;
+	}
+	printf("\n === MEMCPY ===\n\n");
+
+	test_memcpy(0, 0, BUF_SIZE - 32);
+	test_memcpy(0, 0, 1);
+	test_memcpy(0, 0, 31);
+	test_memcpy(0, 0, 32);
+	test_memcpy(0, 0, 127);
+	test_memcpy(0, 0, 128);
+	test_memcpy(4, 4, BUF_SIZE - 32 - 4);
+	test_memcpy(1, 1, BUF_SIZE - 32 - 1);
+	test_memcpy(1, 1, 126);
+	test_memcpy(0, 3, 128);
+	test_memcpy(1, 4, 128);
+	test_memcpy(0, 0, 0);
+
+	printf("\n === MEMMOVE ===\n\n");
+
+	test_memmove(0, 0, BUF_SIZE - 32);
+	test_memmove(0, 0, 1);
+	test_memmove(0, 0, 31);
+	test_memmove(0, 0, 32);
+	test_memmove(0, 0, BUF_SIZE - 33);
+	test_memmove(0, 0, 128);
+	test_memmove(4, 4, BUF_SIZE - 32 - 4);
+	test_memmove(1, 1, BUF_SIZE - 32 - 1);
+	test_memmove(1, 1, BUF_SIZE - 130);
+	test_memmove(0, 3, BUF_SIZE - 128);
+	test_memmove(1, 4, BUF_SIZE - 128);
+	test_memmove(0, 0, 0);
+
+	return 0;
+}
diff -Nrup a/libc/string/avr32/strlen.S b/libc/string/avr32/strlen.S
--- a/libc/string/avr32/strlen.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/strlen.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define str r12
+
+	.text
+	.global strlen
+	.type	strlen, @function
+strlen:
+	mov	r11, r12
+
+	mov	r9, str
+	andl	r9, 3, COH
+	brne	.Lunaligned_str
+
+1:	ld.w	r8, str++
+	tnbz	r8
+	brne	1b
+
+	sub	r12, r11
+	bfextu	r9, r8, 24, 8
+	cp.w	r9, 0
+	subeq	r12, 4
+	reteq	r12
+	bfextu	r9, r8, 16, 8
+	cp.w	r9, 0
+	subeq	r12, 3
+	reteq	r12
+	bfextu	r9, r8, 8, 8
+	cp.w	r9, 0
+	subeq	r12, 2
+	reteq	r12
+	sub	r12, 1
+	retal	r12
+
+.Lunaligned_str:
+	add	pc, pc, r9 << 3
+	sub	r0, r0, 0	/* 4-byte nop */
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	brne	1b
+
+1:	sub	r12, 1
+	sub	r12, r11
+	retal	r12
diff -Nrup a/libc/string/avr32/strncpy.S b/libc/string/avr32/strncpy.S
--- a/libc/string/avr32/strncpy.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/strncpy.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define dst r9
+#define src r11
+
+	.text
+	.global strcpy
+	.type	strncpy, @function
+strncpy:
+	mov	dst, r12
+
+	pref	src[0]
+	mov	dst, r12
+
+	/*
+	 * Check alignment. If src is aligned but dst isn't, we can't
+	 * do much about it...
+	 */
+	mov	r8, src
+	andl	r8, 3 COH
+	brne	.Lunaligned_src
+
+.Laligned_copy:
+	sub	r10, 4
+	brlt	3f
+1:	ld.w	r8, src++
+	tnbz	r8
+	breq	2f
+	st.w	dst++, r8
+	sub	r10, 4
+	brne	1b
+
+3:	sub	r10, -4
+	reteq	r12
+
+	/* This is safe as long as src is word-aligned and r10 > 0 */
+	ld.w	r8, src++
+
+2:	/*
+	 * Ok, r8 now contains the terminating '\0'. Copy the
+	 * remaining bytes individually.
+	 */
+	bfextu	r11, r8, 24, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	bfextu	r11, r8, 16, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	bfextu	r11, r8, 8, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	st.b	dst++, r8
+	retal	r12
+
+.Lunaligned_src:
+	/* Copy bytes until we're aligned */
+	min	r8, r8, r10
+	sub	r10, r8
+	sub	r8, 1
+	retlt	r12
+1:	ld.ub	r10, src++
+	st.b	dst++, r10
+	sub	r8, 1
+	brge	1b
+
+	rjmp	.Laligned_copy
diff -Nrup a/libc/string/avr32/test_memcpy.c b/libc/string/avr32/test_memcpy.c
--- a/libc/string/avr32/test_memcpy.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/string/avr32/test_memcpy.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,66 @@
+
+#include <stdio.h>
+#include <string.h>
+
+#define BUF_SIZE 32768
+
+static char buf1[BUF_SIZE] __attribute__((aligned(32)));
+static char buf1_ref[BUF_SIZE] __attribute__((aligned(32)));
+static char buf2[BUF_SIZE] __attribute__((aligned(32)));
+
+extern void *new_memcpy(void *dest, void *src, size_t len);
+
+void dump_mismatch(char *buf, char *ref, size_t len)
+{
+	int i, j;
+
+	for (i = 0; i < len; i += 16) {
+		if (memcmp(buf + i, ref + i, 16) == 0)
+			continue;
+
+		printf("% 4x buf:", i);
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", buf[j]);
+		printf("\n     ref:");
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", ref[j]);
+		printf("\n");
+	}
+}
+
+void test(int src_offset, int dst_offset, int len)
+{
+	memset(buf1, 0x55, sizeof(buf1));
+	memset(buf1_ref, 0x55, sizeof(buf1_ref));
+	memset(buf2, 0xaa, sizeof(buf2));
+
+	printf("Testing with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	new_memcpy(buf1 + dst_offset, buf2 + src_offset, len);
+	memcpy(buf1_ref + dst_offset, buf2 + src_offset, len);
+
+	if (memcmp(buf1, buf1_ref, sizeof(buf1)) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, sizeof(buf1));
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	test(0, 0, BUF_SIZE);
+	test(0, 0, 1);
+	test(0, 0, 31);
+	test(0, 0, 32);
+	test(0, 0, 127);
+	test(0, 0, 128);
+	test(4, 4, BUF_SIZE - 4);
+	test(1, 1, BUF_SIZE - 1);
+	test(1, 1, 126);
+	test(0, 3, 128);
+	test(1, 4, 128);
+
+	return 0;
+}
diff -Nrup a/libc/sysdeps/linux/avr32/bits/atomicity.h b/libc/sysdeps/linux/avr32/bits/atomicity.h
--- a/libc/sysdeps/linux/avr32/bits/atomicity.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/atomicity.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,86 @@
+/* Low-level functions for atomic operations.  AVR32 version.
+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ATOMICITY_H
+#define _ATOMICITY_H 1
+
+#include <inttypes.h>
+
+static inline int
+__attribute__((unused))
+exchange_and_add (volatile uint32_t *mem, int val)
+{
+	int tmp, result;
+
+	__asm__ __volatile__(
+		"/* Inline exchange and add */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %3\n"
+		"	add	%1, %0, %4\n"
+		"	stcond	%2, %1\n"
+		"	brne	1b"
+		: "=&r"(result), "=&r"(tmp), "=m"(*mem)
+		: "m"(*mem), "r"(val)
+		: "cc", "memory");
+
+	return result;
+}
+
+static inline void
+__attribute__((unused))
+atomic_add (volatile uin32_t *mem, int val)
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline atomic add */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %2\n"
+		"	add	%0, %3\n"
+		"	stcond	%2, %0\n"
+		"	brne	1b"
+		: "=&r"(result), "=m"(*mem)
+		: "m"(*mem), "r"(val)
+		: "cc", "memory");
+}
+
+static inline int
+__attribute__((unused))
+compare_and_swap(volatile long int *p, long int oldval, long int newval)
+{
+	long int result, tmp;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%1, %3\n"
+		"	cp.w	%1, %5\n"
+		"	sreq	%0\n"
+		"	brne	2f\n"
+		"	stcond	%2, %4\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=&r"(tmp), "=m"(*p)
+		: "m"(*p), "r"(newval), "r"(oldval)
+		: "cc", "memory");
+
+	return result;
+}
+
+#endif /* atomicity.h */
diff -Nrup a/libc/sysdeps/linux/avr32/bits/byteswap.h b/libc/sysdeps/linux/avr32/bits/byteswap.h
--- a/libc/sysdeps/linux/avr32/bits/byteswap.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/byteswap.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,80 @@
+/* Macros to swap the order of bytes in integer values.
+   Copyright (C) 2005 Atmel Norway.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+/* Swap bytes in 16 bit value.  */
+#if defined __GNUC__
+# define __bswap_16(x) (__extension__ __builtin_bswap_16(x))
+#else
+/* This is better than nothing.  */
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+	return ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8));
+}
+#endif
+
+/* Swap bytes in 32 bit value.  */
+#if defined __GNUC__
+# define __bswap_32(x) (__extension__ __builtin_bswap_32(x))
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |
+	  (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24));
+}
+#endif
+
+#if defined __GNUC__
+/* Swap bytes in 64 bit value.  */
+# define __bswap_constant_64(x)				\
+	((((x) & 0xff00000000000000ull) >> 56)		\
+	 | (((x) & 0x00ff000000000000ull) >> 40)	\
+	 | (((x) & 0x0000ff0000000000ull) >> 24)	\
+	 | (((x) & 0x000000ff00000000ull) >> 8)		\
+	 | (((x) & 0x00000000ff000000ull) << 8)		\
+	 | (((x) & 0x0000000000ff0000ull) << 24)	\
+	 | (((x) & 0x000000000000ff00ull) << 40)	\
+	 | (((x) & 0x00000000000000ffull) << 56))
+
+# define __bswap_64(x)							\
+	(__extension__							\
+	 ({								\
+		 union {						\
+			 __extension__ unsigned long long int __ll;	\
+			 unsigned int __l[2];				\
+		 } __w, __r;						\
+		 if (__builtin_constant_p(x))				\
+			 __r.__ll = __bswap_constant_64(x);		\
+		 else {							\
+			 __w.__ll = (x);				\
+			 __r.__l[0] = __bswap_32(__w.__l[1]);		\
+			 __r.__l[1] = __bswap_32(__w.__l[0]);		\
+		 }							\
+		 __r.__ll;						\
+	 }))
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
diff -Nrup a/libc/sysdeps/linux/avr32/bits/endian.h b/libc/sysdeps/linux/avr32/bits/endian.h
--- a/libc/sysdeps/linux/avr32/bits/endian.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/endian.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,7 @@
+/* AVR32 is big-endian */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
diff -Nrup a/libc/sysdeps/linux/avr32/bits/fcntl.h b/libc/sysdeps/linux/avr32/bits/fcntl.h
--- a/libc/sysdeps/linux/avr32/bits/fcntl.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/fcntl.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ *
+ * This file is part of the Linux kernel
+ */
+#ifndef _FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	00000003
+#define O_RDONLY	00000000
+#define O_WRONLY	00000001
+#define O_RDWR		00000002
+#define O_CREAT		00000100	/* not fcntl */
+#define O_EXCL		00000200	/* not fcntl */
+#define O_NOCTTY	00000400	/* not fcntl */
+#define O_TRUNC		00001000	/* not fcntl */
+#define O_APPEND	00002000
+#define O_NONBLOCK	00004000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		00010000
+#define O_ASYNC		00020000
+
+#ifdef __USE_GNU
+# define O_DIRECT	00040000	/* must be a directory */
+# define O_DIRECTORY	00200000	/* direct disk access */
+# define O_NOFOLLOW	00400000	/* don't follow links */
+# define O_NOATIME	01000000	/* don't set atime */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	00100000
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5
+# define F_SETLK	6
+# define F_SETLKW	7
+#else
+# define F_GETLK	F_GETLK64
+# define F_SETLK	F_SETLK64
+# define F_SETLKW	F_SETLKW64
+#endif
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/*  for sockets. */
+# define F_GETOWN	9	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/*  for sockets. */
+# define F_GETSIG	11	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+#ifdef __USE_BSD
+/* operations for bsd flock(), also used by the kernel implementation */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock */
+# define LOCK_READ	64	/* ... Which allows concurrent
+				       read operations */
+# define LOCK_WRITE	128	/* ... Which allows concurrent
+				       write operations */
+# define LOCK_RW	192	/* ... Which allows concurrent
+				       read & write ops */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock {
+	short l_type;
+	short l_whence;
+#ifndef __USE_FILE_OFFSET64
+	__off_t l_start;
+	__off_t l_len;
+#else
+	__off64_t l_start;
+	__off64_t l_len;
+#endif
+	__pid_t l_pid;
+};
+
+#ifdef __USE_LARGEFILE64
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	__off64_t l_start;
+	__off64_t l_len;
+	__pid_t  l_pid;
+};
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+ *    BSD systems which did not managed to hide these kernel macros.  */
+#ifdef  __USE_BSD
+# define FAPPEND        O_APPEND
+# define FFSYNC         O_FSYNC
+# define FASYNC         O_ASYNC
+# define FNONBLOCK      O_NONBLOCK
+# define FNDELAY        O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL      0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM      1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL  2 /* Expect sequential page references.  */
+# define POSIX_FADV_WILLNEED    3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED    4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE     5 /* Data will be accessed once.  */
+#endif
diff -Nrup a/libc/sysdeps/linux/avr32/bits/kernel_stat.h b/libc/sysdeps/linux/avr32/bits/kernel_stat.h
--- a/libc/sysdeps/linux/avr32/bits/kernel_stat.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/kernel_stat.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,63 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+/*
+ * This file provides struct stat, taken from kernel 2.6.4
+ * (include/asm-avr32/stat.h revision 1.1).
+ */
+
+struct kernel_stat {
+        unsigned long st_dev;
+        unsigned long st_ino;
+        unsigned short st_mode;
+        unsigned short st_nlink;
+        unsigned short st_uid;
+        unsigned short st_gid;
+        unsigned long  st_rdev;
+        unsigned long  st_size;
+        unsigned long  st_blksize;
+        unsigned long  st_blocks;
+        unsigned long  st_atime;
+        unsigned long  st_atime_nsec;
+        unsigned long  st_mtime;
+        unsigned long  st_mtime_nsec;
+        unsigned long  st_ctime;
+        unsigned long  st_ctime_nsec;
+        unsigned long  __unused4;
+        unsigned long  __unused5;
+};
+
+#define STAT_HAVE_NSEC 1
+
+struct kernel_stat64 {
+	unsigned long long st_dev;
+
+	unsigned long long st_ino;
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long st_rdev;
+
+	long long	st_size;
+	unsigned long	__pad1;
+	unsigned long	st_blksize;
+
+	unsigned long long st_blocks;
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+};
+
+#endif /* _BITS_STAT_STRUCT_H */
diff -Nrup a/libc/sysdeps/linux/avr32/bits/kernel_types.h b/libc/sysdeps/linux/avr32/bits/kernel_types.h
--- a/libc/sysdeps/linux/avr32/bits/kernel_types.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/kernel_types.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,56 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts
+ * with the posix_types.h kernel header, and will ensure that
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ASM_AVR32_POSIX_TYPES_H
+#define __ASM_AVR32_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_dev_t;
+typedef unsigned long   __kernel_ino_t;
+typedef unsigned short  __kernel_mode_t;
+typedef unsigned short  __kernel_nlink_t;
+typedef long            __kernel_off_t;
+typedef int             __kernel_pid_t;
+typedef unsigned short  __kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned long	__kernel_size_t;
+typedef int             __kernel_ssize_t;
+typedef int             __kernel_ptrdiff_t;
+typedef long            __kernel_time_t;
+typedef long            __kernel_suseconds_t;
+typedef long            __kernel_clock_t;
+typedef int             __kernel_timer_t;
+typedef int             __kernel_clockid_t;
+typedef int             __kernel_daddr_t;
+typedef char *          __kernel_caddr_t;
+typedef unsigned short  __kernel_uid16_t;
+typedef unsigned short  __kernel_gid16_t;
+typedef unsigned int    __kernel_uid32_t;
+typedef unsigned int    __kernel_gid32_t;
+
+typedef unsigned short  __kernel_old_uid_t;
+typedef unsigned short  __kernel_old_gid_t;
+typedef unsigned short  __kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long       __kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__USE_ALL)
+    int     val[2];
+#else
+    int     __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ASM_AVR32_POSIX_TYPES_H */
diff -Nrup a/libc/sysdeps/linux/avr32/bits/machine-gmon.h b/libc/sysdeps/linux/avr32/bits/machine-gmon.h
--- a/libc/sysdeps/linux/avr32/bits/machine-gmon.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/machine-gmon.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,69 @@
+/* Machine-dependent definitions for profiling support.  AVR32 version.
+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define mcount_internal __mcount_internal
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+static void __attribute((used)) mcount_internal(unsigned long frompc, unsigned long selfpc)
+
+/*
+ * This mcount implementation expects to get called after the prologue
+ * has been run. It also expects that r7 contains a valid frame
+ * pointer.
+ *
+ * When profiling, the compiler should generate something like this at
+ * each function entry:
+ *
+ *	pushm	r0-r7,lr	// lr mandatory, others optional
+ *	mov	r7, sp
+ *	// rest of prologue goes here
+ *	mcall	pc[.LC1 - .]
+ *      // rest of function goes here
+ * .LC1:
+ *	.long	mcount
+ *
+ * or for PIC:
+ *
+ *	pushm	r0-r7,lr
+ *	mov	r7, sp
+ *	// rest of prologue goes here
+ *	lddpc	r0, .LC1
+ * .L1: rsub	r0, pc
+ *	mcall	r0[mcount@GOT]
+ *	// rest of function goes here
+ * .LC1:
+ *	.long	.L1 - _GLOBAL_OFFSET_TABLE_
+ *
+ * This way, when mcount() is called, r7 points to the calling
+ * function's return address. It is guaranteed that calling mcount
+ * will clobber no registers except LR, which is unavoidable.
+ */
+#define MCOUNT asm(				\
+	"	.align	4\n"			\
+	"	.global	_mcount\n"		\
+	"	.type	_mcount,@function\n"	\
+	"_mcount:\n"				\
+	"	pushm	r8-r12,lr\n"		\
+	"	mov	r11, lr\n"		\
+	"	ld.w	r12, r7[0]\n"		\
+	"	rcall	__mcount_internal\n"	\
+	"	popm	r8-r12,pc\n"		\
+	"	.size	_mcount, . - _mcount\n"	\
+	"	.weak	mcount\n"		\
+	"	mcount = _mcount");
diff -Nrup a/libc/sysdeps/linux/avr32/bits/mman.h b/libc/sysdeps/linux/avr32/bits/mman.h
--- a/libc/sysdeps/linux/avr32/bits/mman.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/mman.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,95 @@
+/* Definitions for POSIX memory map interface.  Linux/AVR32 version.
+   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+# define MAP_NONBLOCK	0x10000		/* do not block on IO */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
+
+/* Advise to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -Nrup a/libc/sysdeps/linux/avr32/bits/profil-counter.h b/libc/sysdeps/linux/avr32/bits/profil-counter.h
--- a/libc/sysdeps/linux/avr32/bits/profil-counter.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/profil-counter.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,26 @@
+/* Low-level statistical profiling support function.  Linux/AVR32 version.
+   Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <signal.h>
+
+void
+profil_counter(int signo, siginfo_t *si, struct sigcontext *sc)
+{
+	profil_count((void *)sc->pc);
+}
diff -Nrup a/libc/sysdeps/linux/avr32/bits/setjmp.h b/libc/sysdeps/linux/avr32/bits/setjmp.h
--- a/libc/sysdeps/linux/avr32/bits/setjmp.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/setjmp.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2004-2005 Atmel Norway
+ */
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+/*
+ * The jump buffer contains r0-r7, sr, sp and lr. Other registers are
+ * not saved.
+ */
+typedef int __jmp_buf[11];
+#endif
+
+#define __JMP_BUF_SP	4
+
+/* Test if longjmp to JMPBUF would unwind the frame containing a local
+   variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *)(address) < (void *)(jmpbuf[__JMP_BUF_SP]))
diff -Nrup a/libc/sysdeps/linux/avr32/bits/syscalls.h b/libc/sysdeps/linux/avr32/bits/syscalls.h
--- a/libc/sysdeps/linux/avr32/bits/syscalls.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/syscalls.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,143 @@
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/*
+ * This includes the `__NR_<name>' syscall numbers taken from the
+ * Linux kernel header files. It also defines the traditional
+ * `SYS_<name>' macros for older programs.
+ */
+#include <bits/sysnum.h>
+
+#ifndef __set_errno
+# define __set_errno(val) (*__errno_location()) = (val)
+#endif
+#ifndef SYS_ify
+# define SYS_ify(syscall_name) (__NR_##syscall_name)
+#endif
+
+#ifndef __ASSEMBLER__
+
+#undef _syscall0
+#define _syscall0(type,name)				\
+	type name(void)					\
+	{						\
+		return (type)(INLINE_SYSCALL(name, 0));	\
+	}
+
+#undef _syscall1
+#define _syscall1(type,name,type1,arg1)				\
+	type name(type1 arg1)					\
+	{							\
+		return (type)(INLINE_SYSCALL(name, 1, arg1));	\
+	}
+
+#undef _syscall2
+#define _syscall2(type,name,type1,arg1,type2,arg2)			\
+	type name(type1 arg1, type2 arg2)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 2, arg1, arg2));	\
+	}
+
+#undef _syscall3
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+	type name(type1 arg1, type2 arg2, type3 arg3)			\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 3, arg1,		\
+					     arg2, arg3));		\
+	}
+
+#undef _syscall4
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4)						\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)	\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 4, arg1, arg2,	\
+					     arg3, arg4));		\
+	}
+
+#undef _syscall5
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5)				\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5)						\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 5, arg1, arg2,	\
+					     arg3, arg4, arg5));	\
+	}
+
+#undef _syscall6
+#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5,type6,arg6)			\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5, type6 arg6)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 6, arg1, arg2, arg3,	\
+					     arg4, arg5, arg6));	\
+	}
+
+#undef unlikely
+#define unlikely(x) __builtin_expect((x), 0)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+	({								\
+		unsigned _sys_result = INTERNAL_SYSCALL(name, , nr, args); \
+		if (unlikely(INTERNAL_SYSCALL_ERROR_P(_sys_result, ))) { \
+			__set_errno(INTERNAL_SYSCALL_ERRNO(_sys_result, )); \
+			_sys_result = (unsigned int) -1;		\
+		}							\
+		(int) _sys_result;					\
+	})
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while(0)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)			\
+	({								\
+		register int _a1 asm ("r12");				\
+		register int _scno asm("r8") = SYS_ify(name);		\
+		LOAD_ARGS_##nr (args);					\
+		asm volatile ("scall	/* syscall " #name " */"	\
+			      : "=r" (_a1)				\
+			      : "r"(_scno) ASM_ARGS_##nr		\
+			      : "lr", "cc", "memory");			\
+		_a1;							\
+	})
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
+	((unsigned int)(val) >= 0xfffff001U)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, errr) (-(val))
+
+#define LOAD_ARGS_0() do { } while(0)
+#define ASM_ARGS_0
+#define LOAD_ARGS_1(a1)					\
+	_a1 = (int) (a1);				\
+	LOAD_ARGS_0()
+#define ASM_ARGS_1	ASM_ARGS_0, "r"(_a1)
+#define LOAD_ARGS_2(a1, a2)				\
+	register int _a2 asm("r11") = (int)(a2);	\
+	LOAD_ARGS_1(a1)
+#define ASM_ARGS_2	ASM_ARGS_1, "r"(_a2)
+#define LOAD_ARGS_3(a1, a2, a3)				\
+	register int _a3 asm("r10") = (int)(a3);	\
+	LOAD_ARGS_2(a1, a2)
+#define ASM_ARGS_3	ASM_ARGS_2, "r"(_a3)
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+	register int _a4 asm("r9") = (int)(a4);		\
+	LOAD_ARGS_3(a1, a2, a3)
+#define ASM_ARGS_4	ASM_ARGS_3, "r"(_a4)
+#define LOAD_ARGS_5(a1, a2, a3, a4, a5)			\
+	register int _a5 asm("r5") = (int)(a5);		\
+	LOAD_ARGS_4(a1, a2, a3, a4)
+#define ASM_ARGS_5	ASM_ARGS_4, "r"(_a5)
+#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
+	register int _a6 asm("r3") = (int)(a6);		\
+	LOAD_ARGS_5(a1, a2, a3, a4, a5)
+#define ASM_ARGS_6	ASM_ARGS_5, "r"(_a6)
+
+#endif /* __ASSEMBLER__ */
diff -Nrup a/libc/sysdeps/linux/avr32/bits/wordsize.h b/libc/sysdeps/linux/avr32/bits/wordsize.h
--- a/libc/sysdeps/linux/avr32/bits/wordsize.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bits/wordsize.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1 @@
+#define __WORDSIZE	32
diff -Nrup a/libc/sysdeps/linux/avr32/brk.c b/libc/sysdeps/linux/avr32/brk.c
--- a/libc/sysdeps/linux/avr32/brk.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/brk.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <sys/syscall.h>
+
+void *__curbrk = 0;
+
+int brk (void *addr)
+{
+	void *newbrk;
+
+	newbrk = INLINE_SYSCALL(brk, 1, addr);
+
+	__curbrk = newbrk;
+
+	if (newbrk < addr) {
+		__set_errno (ENOMEM);
+		return -1;
+	}
+
+	return 0;
+}
diff -Nrup a/libc/sysdeps/linux/avr32/bsd-_setjmp.S b/libc/sysdeps/linux/avr32/bsd-_setjmp.S
--- a/libc/sysdeps/linux/avr32/bsd-_setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bsd-_setjmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 0) */
+	.global	_setjmp
+	.type	_setjmp,"function"
+	.align	1
+_setjmp:
+	mov	r11, 0
+	bral	__sigsetjmp_internal
+	.size	_setjmp, . - _setjmp
diff -Nrup a/libc/sysdeps/linux/avr32/bsd-setjmp.S b/libc/sysdeps/linux/avr32/bsd-setjmp.S
--- a/libc/sysdeps/linux/avr32/bsd-setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/bsd-setjmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 1) */
+	.global	setjmp
+	.type	setjmp,"function"
+	.align	1
+setjmp:
+	mov	r11, 1
+	bral	__sigsetjmp_internal
+	.size	setjmp, . - setjmp
diff -Nrup a/libc/sysdeps/linux/avr32/clone.c b/libc/sysdeps/linux/avr32/clone.c
--- a/libc/sysdeps/linux/avr32/clone.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/clone.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+/*
+ * I don't know if we can be absolutely certain that the fn and arg
+ * parameters are preserved when returning as the child. If the
+ * compiler stores them in registers (r0-r7), they should be.
+ */
+int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+{
+	register int (*_fn)(void *arg) = fn;
+	register void *_arg = arg;
+	int err;
+
+	/* Sanity check the arguments */
+	err = -EINVAL;
+	if (!fn)
+		goto syscall_error;
+	if (!child_stack)
+		goto syscall_error;
+
+	err = INLINE_SYSCALL(clone, 2, flags, child_stack);
+	if (err < 0)
+		goto syscall_error;
+	else if (err != 0)
+		return err;
+
+	_exit(_fn(_arg));
+
+syscall_error:
+	__set_errno (-err);
+	return -1;
+}
diff -Nrup a/libc/sysdeps/linux/avr32/crt1.S b/libc/sysdeps/linux/avr32/crt1.S
--- a/libc/sysdeps/linux/avr32/crt1.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/crt1.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ *
+ * When we enter _start, the stack looks like this:
+ *	argc		argument counter
+ *	argv[0]		pointer to program name
+ *	argv[1..argc-1]	pointers to program args
+ *	NULL
+ *	env[0..N]	pointers to environment variables
+ *	NULL
+ *
+ * r12 contains a function pointer to be registered with `atexit'.
+ * This is how the dynamic linker arranges to have DT_FINI functions
+ * called for shared libraries that have been loaded before this
+ * code runs.
+ *
+ * We're going to call the following function:
+ * __uClibc_main(int (*main)(int, char **, char **), int argc,
+ *		 char **argv, void (*app_init)(void), void (*app_fini)(void),
+ *		 void (*rtld_fini)(void), void *stack_end)
+ *
+ * So we need to set up things as follows:
+ *	r12 = address of main
+ *	r11 = argc
+ *	r10 = &argv[0]
+ *	r9  = address of _init
+ *	r8  = address of _fini
+ *	sp[0] = whatever we got passed in r12
+ */
+
+#include <features.h>
+
+	.text
+	.global _start
+	.type	_start, @function
+_start:
+	/* Clear the frame pointer and link register since this is the outermost frame.  */
+	mov	r7, 0
+	mov	lr, 0
+
+	ld.w	r11, sp++		/* argc		*/
+	mov	r10, sp			/* &argv[0]	*/
+
+	st.w	--sp, r10		/* stack_end */
+	st.w	--sp, r12		/* rtld_fini */
+
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+.L_RGOT:
+	rsub	r6, pc
+	lda.w	r9, _init
+	lda.w	r8, _fini
+	lda.w	r12, main
+
+	/* Ok, now run uClibc's main() -- should not return */
+	call	__uClibc_main
+
+	.align	2
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+	lddpc	r9, __init_addr		/* app_init */
+	lddpc	r8, __fini_addr		/* app_fini */
+	lddpc	r12, __main_addr	/* main */
+
+	/* Ok, now run uClibc's main() -- should not return */
+	lddpc	pc, ___uClibc_main_addr
+
+	.align	2
+__init_addr:
+	.long	_init
+__fini_addr:
+	.long	_fini
+__main_addr:
+	.long	main
+___uClibc_main_addr:
+	.long	__uClibc_main
+#endif
+	.size	_start, . - _start
+
+	/*
+	 * The LSB says we need this.
+	 */
+	.section ".note.ABI-tag", "a"
+	.align	4
+	.long	2f - 1f		/* namesz */
+	.long	4f - 3f		/* descsz */
+	.long	1		/* type   */
+1:	.asciz	"GNU"		/* name */
+2:	.align	4
+3:	.long	0		/* Linux executable */
+	.long	2,6,0		/* Earliest compatible kernel */
+4:	.align	4
diff -Nrup a/libc/sysdeps/linux/avr32/crti.S b/libc/sysdeps/linux/avr32/crti.S
--- a/libc/sysdeps/linux/avr32/crti.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/crti.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,17 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+_init:
+	/* Use a four-byte instruction to avoid NOPs */
+	stm	--sp, r0-r7,lr
+	.align	2
+
+	.section .fini
+	.align	2
+	.global	_fini
+	.type	_fini, @function
+_fini:
+	stm	--sp, r0-r7,lr
+	.align	2
diff -Nrup a/libc/sysdeps/linux/avr32/crtn.S b/libc/sysdeps/linux/avr32/crtn.S
--- a/libc/sysdeps/linux/avr32/crtn.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/crtn.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,14 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+	ldm	sp++, r0-r7,pc
+	.size	_init, . - _init
+
+	.section .fini
+	.align	2
+	.global _fini
+	.type	_fini, @function
+	ldm	sp++, r0-r7,pc
+	.size	_fini, . - _fini
diff -Nrup a/libc/sysdeps/linux/avr32/__longjmp.S b/libc/sysdeps/linux/avr32/__longjmp.S
--- a/libc/sysdeps/linux/avr32/__longjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/__longjmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,17 @@
+/* longjmp for AVR32
+ *
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	.global	__longjmp
+	.type	__longjmp,"function"
+	.align	1
+__longjmp:
+	ldm	r12++, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
+	mov	r12, r11	/* get the return value right */
+	mustr	r8		/* restore status register (lower half) */
+	cp	r12, 0		/* can't return zero */
+	frs
+	moveq	r12, 1
+	mov	pc,lr
+	.size	__longjmp, . - __longjmp
diff -Nrup a/libc/sysdeps/linux/avr32/Makefile b/libc/sysdeps/linux/avr32/Makefile
--- a/libc/sysdeps/linux/avr32/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/Makefile	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,93 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../../
+include $(TOPDIR)Rules.mak
+ASFLAGS=$(CFLAGS)
+
+CRT_SRC	= crt1.S
+CRT_OBJ = crt1.o
+SCRT_OBJ = $(patsubst %,S%, $(CRT_OBJ))
+CTOR_TARGETS=$(TOPDIR)lib/crti.o $(TOPDIR)lib/crtn.o
+
+SSRC=__longjmp.S setjmp.S bsd-setjmp.S vfork.S \
+	bsd-_setjmp.S sigrestorer.S syscall.S
+SOBJS=$(patsubst %.S,%.o, $(SSRC))
+
+CSRC=clone.c brk.c sigaction.c mmap.c
+COBJS=$(patsubst %.c,%.o, $(CSRC))
+
+OBJS=$(SOBJS) $(COBJS)
+
+OBJ_LIST=../../../obj.sysdeps.$(TARGET_ARCH)
+
+all: $(OBJ_LIST)
+
+$(OBJ_LIST): $(OBJS) $(CRT_OBJ) $(SCRT_OBJ) $(CTOR_TARGETS)
+	echo $(patsubst %, sysdeps/linux/$(TARGET_ARCH)/%, $(OBJS)) > $(OBJ_LIST)
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp $(CRT_OBJ) $(SCRT_OBJ) $(TOPDIR)lib/
+
+$(CRT_OBJ): $(CRT_SRC)
+	$(CC) $(ASFLAGS) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SCRT_OBJ): $(CRT_SRC)
+	$(CC) $(ASFLAGS) $(PIEFLAG) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SOBJS): %.o : %.S
+	$(CC) $(ASFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(COBJS): %.o : %.c
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+ifeq ($(strip $(UCLIBC_CTOR_DTOR)),y)
+crti.o: crti.S
+	$(CC) $(ASFLAGS) -c crti.S -o crti.o
+
+$(TOPDIR)lib/crti.o: crti.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crti.o $(TOPDIR)lib/
+
+crtn.o: crtn.S
+	$(CC) $(ASFLAGS) -c crtn.S -o crtn.o
+
+$(TOPDIR)lib/crtn.o: crtn.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crtn.o $(TOPDIR)lib/
+else
+$(TOPDIR)lib/crti.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crti.o
+$(TOPDIR)lib/crtn.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crtn.o
+endif
+
+
+headers:
+#	$(LN) -fs ../libc/sysdeps/linux/avr32/fpu_control.h $(TOPDIR)/include/
+
+clean:
+	$(RM) *.[oa] *~ core
+	$(RM) bits/sysnum.h
+	$(RM) gmon-start.S
+
diff -Nrup a/libc/sysdeps/linux/avr32/_mmap.c b/libc/sysdeps/linux/avr32/_mmap.c
--- a/libc/sysdeps/linux/avr32/_mmap.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/_mmap.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,33 @@
+/* Copyright (C) 2005 Atmel Norway
+
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Library General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+   details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+   Derived in part from the Linux-8086 C library, the GNU C Library, and several
+   other sundry sources.  Files within this library are copyright by their
+   respective copyright holders.
+ */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+#define __NR_mmap2 __NR_mmap
+
+static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot, int, flags, int, fd, __off_t, pgoff);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+	return mmap2(addr, len, prot, flags, fd, offset >> 12);
+}
diff -Nrup a/libc/sysdeps/linux/avr32/mmap.c b/libc/sysdeps/linux/avr32/mmap.c
--- a/libc/sysdeps/linux/avr32/mmap.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/mmap.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,31 @@
+/* Copyright (C) 2005 Atmel Norway
+
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Library General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+   details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+   Derived in part from the Linux-8086 C library, the GNU C Library, and several
+   other sundry sources.  Files within this library are copyright by their
+   respective copyright holders.
+ */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot, int, flags, int, fd, __off_t, pgoff);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+	return mmap2(addr, len, prot, flags, fd, offset >> 12);
+}
diff -Nrup a/libc/sysdeps/linux/avr32/setjmp.S b/libc/sysdeps/linux/avr32/setjmp.S
--- a/libc/sysdeps/linux/avr32/setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/setjmp.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+	.text
+
+	.global	__sigsetjmp
+	.type	__sigsetjmp,"function"
+
+	/* Create a global, hidden symbol for use by setjmp() and _setjmp().
+	   If it's not hidden, the linker will complain about a relative
+	   jump to a dynamic symbol when building a shared library.
+
+	   Also, if a user overrides the __sigsetjmp function, he might not
+	   expect the setjmp() and _setjmp() function to effectively be
+	   overridden as well.  */
+	.global	__sigsetjmp_internal
+	.hidden	__sigsetjmp_internal
+	.type	__sigsetjmp_internal,"function"
+	.align	1
+__sigsetjmp:
+__sigsetjmp_internal:
+	mustr	r8
+	stm	r12, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
+
+	/* Make a tail call to __sigjmp_save; it takes the same args.  */
+#ifdef __PIC__
+	mov	r9, r6
+	lddpc	r6, .LG
+.L1:	rsub	r6, pc
+	ld.w	r8, r6[__sigjmp_save@got]
+	mov	r6, r9
+	mov	pc, r8
+
+	.align	2
+.LG:	.long	.L1 - _GLOBAL_OFFSET_TABLE_
+#else
+	rjmp	__sigjmp_save
+#endif
+	.size	__sigsetjmp, . - __sigsetjmp
diff -Nrup a/libc/sysdeps/linux/avr32/sigaction.c b/libc/sysdeps/linux/avr32/sigaction.c
--- a/libc/sysdeps/linux/avr32/sigaction.c	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sigaction.c	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/kernel_sigaction.h>
+
+#define SA_RESTORER	0x04000000
+extern void __default_rt_sa_restorer(void);
+
+/*
+ * If act is not NULL, change the action for sig to *act.
+ * If oact is not NULL, put the old action for sig in *oact.
+ */
+int __libc_sigaction(int signum, const struct sigaction *act,
+		     struct sigaction *oldact)
+{
+	struct kernel_sigaction kact, koact;
+	int result;
+
+	if (act) {
+		kact.k_sa_handler = act->sa_handler;
+		memcpy(&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
+		kact.sa_flags = act->sa_flags;
+		if (kact.sa_flags & (SA_RESTORER | SA_ONSTACK))
+			kact.sa_restorer = act->sa_restorer;
+		else
+			kact.sa_restorer = __default_rt_sa_restorer;
+		kact.sa_flags |= SA_RESTORER;
+	}
+
+	result = __syscall_rt_sigaction(signum, act ? __ptrvalue(&kact) : NULL,
+					oldact ? __ptrvalue(&koact) : NULL,
+					_NSIG / 8);
+
+	if (oldact && result >= 0) {
+		oldact->sa_handler = koact.k_sa_handler;
+		memcpy(&oldact->sa_mask, &koact.sa_mask,
+		       sizeof(oldact->sa_mask));
+		oldact->sa_flags = koact.sa_flags;
+		oldact->sa_restorer = koact.sa_restorer;
+	}
+
+	return result;
+}
+
+weak_alias(__libc_sigaction, sigaction)
diff -Nrup a/libc/sysdeps/linux/avr32/sigrestorer.S b/libc/sysdeps/linux/avr32/sigrestorer.S
--- a/libc/sysdeps/linux/avr32/sigrestorer.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sigrestorer.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <sys/syscall.h>
+
+	.global	__default_rt_sa_restorer
+	.type	__default_rt_sa_restorer,"function"
+	.align	1
+__default_rt_sa_restorer:
+	mov	r8, __NR_rt_sigreturn
+	scall
diff -Nrup a/libc/sysdeps/linux/avr32/sys/elf.h b/libc/sysdeps/linux/avr32/sys/elf.h
--- a/libc/sysdeps/linux/avr32/sys/elf.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sys/elf.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,26 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ELF_H
+#define _SYS_ELF_H	1
+
+#warning "This header is obsolete; use <sys/procfs.h> instead."
+
+#include <sys/procfs.h>
+
+#endif	/* sys/elf.h */
diff -Nrup a/libc/sysdeps/linux/avr32/sys/io.h b/libc/sysdeps/linux/avr32/sys/io.h
--- a/libc/sysdeps/linux/avr32/sys/io.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sys/io.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,48 @@
+/* Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+
+#define	_SYS_IO_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL is nonzero,
+   permission to access any I/O port is granted.  This call requires
+   root privileges. */
+extern int iopl (int __level) __THROW;
+
+/* The functions that actually perform reads and writes.  */
+extern unsigned char inb (unsigned long int port) __THROW;
+extern unsigned short int inw (unsigned long int port) __THROW;
+extern unsigned long int inl (unsigned long int port) __THROW;
+
+extern void outb (unsigned char value, unsigned long int port) __THROW;
+extern void outw (unsigned short value, unsigned long int port) __THROW;
+extern void outl (unsigned long value, unsigned long int port) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_IO_H */
diff -Nrup a/libc/sysdeps/linux/avr32/sys/procfs.h b/libc/sysdeps/linux/avr32/sys/procfs.h
--- a/libc/sysdeps/linux/avr32/sys/procfs.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sys/procfs.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,123 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   user_regs' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+#define ELF_NGREG (sizeof (struct user_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+typedef struct user_fpregs elf_fpregset_t;
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff -Nrup a/libc/sysdeps/linux/avr32/sys/ucontext.h b/libc/sysdeps/linux/avr32/sys/ucontext.h
--- a/libc/sysdeps/linux/avr32/sys/ucontext.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sys/ucontext.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,94 @@
+/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Linux/AVR32 ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	16
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15
+#define R15	R15
+};
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    fpregset_t fpregs;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+{
+    unsigned long     uc_flags;
+    struct ucontext  *uc_link;
+    stack_t           uc_stack;
+    struct sigcontext uc_mcontext;
+    sigset_t          uc_sigmask;   /* mask last for extensibility */
+} ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -Nrup a/libc/sysdeps/linux/avr32/sys/user.h b/libc/sysdeps/linux/avr32/sys/user.h
--- a/libc/sysdeps/linux/avr32/sys/user.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/sys/user.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,46 @@
+#ifndef _SYS_USER_H
+#define _SYS_USER_H
+
+struct user_fpregs
+{
+
+};
+
+struct user_regs
+{
+	unsigned long sr;
+	unsigned long pc;
+	unsigned long lr;
+	unsigned long sp;
+	unsigned long r12;
+	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long r7;
+	unsigned long r6;
+	unsigned long r5;
+	unsigned long r4;
+	unsigned long r3;
+	unsigned long r2;
+	unsigned long r1;
+	unsigned long r0;
+	unsigned long r12_orig;
+};
+
+struct user
+{
+	struct user_regs	regs;		/* general registers */
+	size_t			u_tsize;	/* text size (pages) */
+	size_t			u_dsize;	/* data size (pages) */
+	size_t			u_ssize;	/* stack size (pages) */
+	unsigned long		start_code;	/* text starting address */
+	unsigned long		start_data;	/* data starting address */
+	unsigned long		start_stack;	/* stack starting address */
+	long int		signal;		/* signal causing core dump */
+	struct user_regs *	u_ar0;		/* help gdb find registers */
+	unsigned long		magic;		/* identifies a core file */
+	char			u_comm[32];	/* user command name */
+};
+
+#endif /* _SYS_USER_H */
diff -Nrup a/libc/sysdeps/linux/avr32/syscall.S b/libc/sysdeps/linux/avr32/syscall.S
--- a/libc/sysdeps/linux/avr32/syscall.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/syscall.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,81 @@
+/*
+ * syscall for AVR32/uClibc
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <features.h>
+
+	.text
+
+	/*
+	 * long int syscall(long int sysno, ...)
+	 */
+	.global	syscall
+	.type	syscall, @function
+	.align	2
+syscall:
+	stm	--sp, r3,r5,lr
+	sub	lr, sp, -12
+	mov	r8, r12
+	ldm	lr, r3,r5,r9-r12
+	scall
+	cp.w	r12, -4095
+	brlo	.Ldone
+
+#ifdef __PIC__
+	lddpc	r5, .Lgot
+.Lgotcalc:
+	rsub	r5, pc
+# ifdef __UCLIBC_HAS_THREADS__
+	mov	r3, r12
+	mcall	r5[__errno_location@got]
+	st.w	r12[0], r3
+# else
+	ld.w	r3, r5[errno@got]
+	st.w	r3[0], r12
+# endif
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+	mov	r3, r12
+	mcall	.Lerrno_location
+	st.w	r12[0], r3
+# else
+	lddpc	r3, .Lerrno
+	st.w	r3[0], r12
+# endif
+#endif
+	mov	r12, -1
+
+.Ldone:
+	ldm	sp++, r3,r5,pc
+
+	.align	2
+#ifdef __PIC__
+.Lgot:
+	.long	.Lgotcalc - _GLOBAL_OFFSET_TABLE_
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+.Lerrno_location:
+	.long	__errno_location
+# else
+.Lerrno:
+	.long	errno
+# endif
+#endif
+
+
+	.size	syscall, . - syscall
diff -Nrup a/libc/sysdeps/linux/avr32/vfork.S b/libc/sysdeps/linux/avr32/vfork.S
--- a/libc/sysdeps/linux/avr32/vfork.S	1969-12-31 19:00:00.000000000 -0500
+++ b/libc/sysdeps/linux/avr32/vfork.S	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,55 @@
+	/*
+	 * vfork for uClibc
+	 *
+	 * Copyright (C) 2005 Atmel Norway
+	 */
+
+	/*
+	 * Clone the process without copying the address space.  The
+	 * calling process is suspended until the child either exits
+	 * or calls execve.
+	 *
+	 * This all means that we cannot rely on the stack to store
+	 * away registers, since they will be overwritten by the child
+	 * as soon as it makes another function call (e.g. execve()).
+	 * Fortunately, the Linux kernel preserves LR across system calls.
+	 */
+#include <features.h>
+#include <sys/syscall.h>
+
+	.global	__vfork
+	.type	__vfork,@function
+	.align	1
+__vfork:
+	mov	r8, __NR_vfork
+	scall
+	cp.w	r12, -4096
+	retls	r12
+
+	/* vfork failed, so we may use the stack freely */
+	pushm	r4-r7,lr
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+	rsub	r4, r12, 0
+.L_RGOT:
+	rsub	r6, pc
+	mcall	r6[__errno_location@got]
+#else
+	rsub	r4, r12, 0
+	mcall	.L__errno_location
+#endif
+	st.w	r12[0], r4
+	popm	r4-r7,pc,r12=-1
+
+	.align	2
+#ifdef __PIC__
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+.L__errno_location:
+	.long	__errno_location
+#endif
+	.size	__vfork, . - __vfork
+
+	.weak	vfork
+	vfork	= __vfork
diff -Nrup a/libc/sysdeps/linux/common/create_module.c b/libc/sysdeps/linux/common/create_module.c
--- a/libc/sysdeps/linux/common/create_module.c	2004-03-11 19:21:20.000000000 -0500
+++ b/libc/sysdeps/linux/common/create_module.c	2008-02-28 19:02:10.000000000 -0500
@@ -61,7 +61,8 @@ unsigned long create_module(const char *
 {
   return __create_module(name, size, 0, 0);
 }
-#else
+/* create_module is obsolete in Linux 2.6, so AVR32 doesn't have it */
+#elif !defined(__avr32__)
 /* Sparc, MIPS, etc don't mistake return values for errors. */ 
 _syscall2(unsigned long, create_module, const char *, name, size_t, size);
 #endif
diff -Nrup a/libc/sysdeps/linux/common/getrusage.c b/libc/sysdeps/linux/common/getrusage.c
--- a/libc/sysdeps/linux/common/getrusage.c	2005-01-05 18:11:28.000000000 -0500
+++ b/libc/sysdeps/linux/common/getrusage.c	2008-02-28 19:02:10.000000000 -0500
@@ -10,4 +10,4 @@
 #include "syscalls.h"
 #include <unistd.h>
 #include <wait.h>
-_syscall2(int, getrusage, int, who, struct rusage *, usage);
+_syscall2(int, getrusage, __rusage_who_t, who, struct rusage *, usage);
diff -Nrup a/libc/sysdeps/linux/common/open64.c b/libc/sysdeps/linux/common/open64.c
--- a/libc/sysdeps/linux/common/open64.c	2002-10-31 13:20:21.000000000 -0500
+++ b/libc/sysdeps/linux/common/open64.c	2008-02-28 19:02:10.000000000 -0500
@@ -26,7 +26,7 @@
 #endif
 
 #ifdef __UCLIBC_HAS_LFS__
-extern int __libc_open (__const char *file, int oflag, mode_t mode);
+extern int __libc_open (__const char *file, int oflag, ...);
 
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
diff -Nrup a/libc/sysdeps/linux/common/__syscall_fcntl.c b/libc/sysdeps/linux/common/__syscall_fcntl.c
--- a/libc/sysdeps/linux/common/__syscall_fcntl.c	2005-07-30 10:02:24.000000000 -0400
+++ b/libc/sysdeps/linux/common/__syscall_fcntl.c	2008-02-28 19:02:10.000000000 -0500
@@ -12,7 +12,7 @@
 #include <fcntl.h>
 
 #if defined __UCLIBC_HAS_LFS__ && defined __NR_fcntl64
-extern int __libc_fcntl64(int fd, int cmd, long arg);
+extern int __libc_fcntl64(int fd, int cmd, ...);
 #endif
 
 #define __NR___syscall_fcntl __NR_fcntl
diff -Nrup a/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h b/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h
--- a/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h	1969-12-31 19:00:00.000000000 -0500
+++ b/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,92 @@
+/* Machine-dependent pthreads configuration and inline functions.
+
+   Copyright (C) 2005 Atmel Norway
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+static inline int
+_test_and_set (int *p, int v) __THROW
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline test and set */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %2\n"
+		"	tst	%0, %3\n"
+		"	breq	2f\n"
+		"	stcond	%1, %3\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=m"(*p)
+		: "m"(*p), "r"(v)
+		: "memory", "cc");
+
+	return result;
+}
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+	return _test_and_set(spinlock, 1);
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("sp");
+
+/* Compare-and-swap for semaphores. */
+
+#define HAS_COMPARE_AND_SWAP
+PT_EI int
+__compare_and_swap(long int *p, long int oldval, long int newval)
+{
+	long int result, tmp;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%1, %3\n"
+		"	cp.w	%1, %5\n"
+		"	sreq	%0\n"
+		"	brne	2f\n"
+		"	stcond	%2, %4\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=&r"(tmp), "=m"(*p)
+		: "m"(*p), "r"(newval), "r"(oldval)
+		: "cc", "memory");
+
+	return result;
+}
+
+#endif /* pt-machine.h */
diff -Nrup a/Makefile b/Makefile
--- a/Makefile	2007-02-01 21:24:29.000000000 -0500
+++ b/Makefile	2008-02-28 19:02:10.000000000 -0500
@@ -163,7 +163,7 @@ install_dev:
 	else \
 		extra_exclude="" ; \
 	fi ; \
-	tar -chf - include --exclude .svn --exclude CVS $$extra_exclude \
+	tar -chf - --exclude .svn --exclude CVS $$extra_exclude include \
 		| tar -xf - -C $(PREFIX)$(DEVEL_PREFIX)
 	echo '/* Dont use _syscall#() macros; use the syscall() function */' > \
 		$(PREFIX)$(DEVEL_PREFIX)include/bits/syscalls.h
diff -Nrup a/Makefile.orig b/Makefile.orig
--- a/Makefile.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/Makefile.orig	2007-02-01 21:24:29.000000000 -0500
@@ -0,0 +1,383 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later
+# version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU Library General Public License for more details.
+#
+# You should have received a copy of the GNU Library General
+# Public License along with this program; if not, write to the
+# Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+# Boston, MA 02111-1307 USA
+
+
+#--------------------------------------------------------------
+# You shouldn't need to mess with anything beyond this point...
+#--------------------------------------------------------------
+noconfig_targets := menuconfig config oldconfig randconfig \
+	defconfig allyesconfig allnoconfig clean distclean \
+	release tags TAGS
+TOPDIR=./
+include Rules.mak
+
+DIRS = ldso libc libcrypt libresolv libnsl libutil libm libpthread librt
+ifeq ($(strip $(UCLIBC_HAS_GETTEXT_AWARENESS)),y)
+	DIRS += libintl
+endif
+
+ifeq ($(strip $(HAVE_DOT_CONFIG)),y)
+
+all: headers pregen subdirs shared finished
+
+# In this section, we need .config
+-include .config.cmd
+
+shared: subdirs
+ifeq ($(strip $(HAVE_SHARED)),y)
+	$(SECHO)
+	$(SECHO) Building shared libraries ...
+	$(SECHO)
+	@$(MAKE) -C libc shared
+	@$(MAKE) -C ldso shared
+	@$(MAKE) -C libcrypt shared
+	@$(MAKE) -C libresolv shared
+	@$(MAKE) -C libnsl shared
+	@$(MAKE) -C libutil shared
+	@$(MAKE) -C libm shared
+	@$(MAKE) -C libpthread shared
+	@$(MAKE) -C librt shared
+ifeq ($(strip $(UCLIBC_HAS_GETTEXT_AWARENESS)),y)
+	@$(MAKE) -C libintl shared
+endif
+else
+	$(SECHO)
+	$(SECHO) Not building shared libraries ...
+	$(SECHO)
+endif
+
+finished: shared
+	$(SECHO)
+	$(SECHO) Finally finished compiling ...
+	$(SECHO)
+
+include/bits/uClibc_config.h: .config
+	@if [ ! -x ./extra/config/conf ] ; then \
+	    $(MAKE) -C extra/config conf; \
+	fi;
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -o extra/Configs/Config.in
+
+# For the moment, we have to keep re-running this target 
+# because the fix includes scripts rely on pre-processers 
+# in order to generate the headers correctly :(.  That 
+# means we can't use the $(HOSTCC) in order to get the 
+# correct output.
+ifeq ($(strip $(ARCH_HAS_MMU)),y)
+export header_extra_args = 
+else
+export header_extra_args = -n
+endif
+headers: include/bits/uClibc_config.h
+	@$(SHELL_SET_X); \
+	./extra/scripts/fix_includes.sh \
+		-k $(KERNEL_SOURCE) -t $(TARGET_ARCH) \
+		$(header_extra_args)
+	@cd include/bits; \
+	set -e; \
+	for i in `ls ../../libc/sysdeps/linux/common/bits/*.h` ; do \
+		$(LN) -fs $$i .; \
+	done; \
+	if [ -d ../../libc/sysdeps/linux/$(TARGET_ARCH)/bits ] ; then \
+		for i in `ls ../../libc/sysdeps/linux/$(TARGET_ARCH)/bits/*.h` ; do \
+			$(LN) -fs $$i .; \
+		done; \
+	fi
+	@cd include/sys; \
+	set -e; \
+	for i in `ls ../../libc/sysdeps/linux/common/sys/*.h` ; do \
+		$(LN) -fs $$i .; \
+	done; \
+	if [ -d ../../libc/sysdeps/linux/$(TARGET_ARCH)/sys ] ; then \
+		for i in `ls ../../libc/sysdeps/linux/$(TARGET_ARCH)/sys/*.h` ; do \
+			$(LN) -fs $$i .; \
+		done; \
+	fi
+	@cd $(TOPDIR); \
+	set -e; \
+	$(SHELL_SET_X); \
+	TOPDIR=. CC="$(CC)" /bin/sh extra/scripts/gen_bits_syscall_h.sh > include/bits/sysnum.h.new; \
+	if cmp include/bits/sysnum.h include/bits/sysnum.h.new >/dev/null 2>&1; then \
+		$(RM) include/bits/sysnum.h.new; \
+	else \
+		mv -f include/bits/sysnum.h.new include/bits/sysnum.h; \
+	fi
+	$(MAKE) -C libc/sysdeps/linux/common headers
+	$(MAKE) -C libc/sysdeps/linux/$(TARGET_ARCH) headers
+
+# Command used to download source code
+WGET:=wget --passive-ftp
+
+LOCALE_DATA_FILENAME:=uClibc-locale-030818.tgz
+
+pregen: headers
+ifeq ($(strip $(UCLIBC_DOWNLOAD_PREGENERATED_LOCALE_DATA)),y)
+	(cd extra/locale; \
+	if [ ! -f $(LOCALE_DATA_FILENAME) ] ; then \
+	$(WGET) http://www.uclibc.org/downloads/$(LOCALE_DATA_FILENAME) ; \
+	fi );
+endif
+ifeq ($(strip $(UCLIBC_PREGENERATED_LOCALE_DATA)),y)
+	(cd extra/locale; zcat $(LOCALE_DATA_FILENAME) | tar -xvf -)
+	$(MAKE) -C extra/locale pregen
+endif
+
+
+subdirs: $(patsubst %, _dir_%, $(DIRS))
+$(patsubst %, _dir_%, $(DIRS)): headers
+	$(MAKE) -C $(patsubst _dir_%, %, $@)
+
+tags:
+	ctags -R
+
+install: install_runtime install_dev finished2
+
+
+RUNTIME_PREFIX_LIB_FROM_DEVEL_PREFIX_LIB=$(shell extra/scripts/relative_path.sh $(DEVEL_PREFIX)lib $(RUNTIME_PREFIX)lib)
+
+# Installs header files and development library links.
+install_dev:
+	$(INSTALL) -d $(PREFIX)$(DEVEL_PREFIX)lib
+	$(INSTALL) -d $(PREFIX)$(DEVEL_PREFIX)include
+	-$(INSTALL) -m 644 lib/*.[ao] $(PREFIX)$(DEVEL_PREFIX)lib/
+	if [ "$(KERNEL_SOURCE)" = "$(DEVEL_PREFIX)" ] ; then \
+		extra_exclude="--exclude include/linux --exclude include/asm'*'" ; \
+	else \
+		extra_exclude="" ; \
+	fi ; \
+	tar -chf - include --exclude .svn --exclude CVS $$extra_exclude \
+		| tar -xf - -C $(PREFIX)$(DEVEL_PREFIX)
+	echo '/* Dont use _syscall#() macros; use the syscall() function */' > \
+		$(PREFIX)$(DEVEL_PREFIX)include/bits/syscalls.h
+ifneq ($(strip $(UCLIBC_HAS_FLOATS)),y)
+	# Remove floating point related headers since float support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/complex.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/fpu_control.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/ieee754.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/math.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/tgmath.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_WCHAR)),y)
+	# Remove wide char headers since wide char support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/wctype.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/wchar.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_LOCALE)),y)
+	# Remove iconv header since locale support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/iconv.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_GLIBC_CUSTOM_PRINTF)),y)
+	# Remove printf header since custom print specifier support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/printf.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_XLOCALE)),y)
+	# Remove xlocale header since extended locale support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/xlocale.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_GETTEXT_AWARENESS)),y)
+	# Remove libintl header since gettext support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/libintl.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_REGEX)),y)
+	# Remove regex headers since regex support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/regex.h
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/regexp.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_WORDEXP)),y)
+	# Remove wordexp header since wordexp support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/wordexp.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_FTW)),y)
+	# Remove ftw header since ftw support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/ftw.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_GLOB)),y)
+	# Remove glob header since glob support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/glob.h
+endif
+ifneq ($(strip $(UCLIBC_HAS_GNU_GETOPT)),y)
+	# Remove getopt header since gnu getopt support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/getopt.h
+endif
+ifneq ($(strip $(HAS_SHADOW)),y)
+	# Remove getopt header since shadow password support is disabled.
+	$(RM) $(PREFIX)$(DEVEL_PREFIX)include/shadow.h
+endif
+	-@for i in `find  $(PREFIX)$(DEVEL_PREFIX) -type d` ; do \
+	    chmod 755 $$i; chmod 644 $$i/*.h > /dev/null 2>&1; \
+	done;
+	-find $(PREFIX)$(DEVEL_PREFIX) -name .svn | xargs $(RM) -r;
+	-chown -R `id | sed 's/^uid=\([0-9]*\).*gid=\([0-9]*\).*$$/\1:\2/'` $(PREFIX)$(DEVEL_PREFIX)
+ifeq ($(strip $(HAVE_SHARED)),y)
+	for i in `find lib/ -type l -name 'lib[a-zA-Z]*.so' | \
+	sed -e 's/lib\///'` ; do \
+		$(LN) -sf $(RUNTIME_PREFIX_LIB_FROM_DEVEL_PREFIX_LIB)$$i.$(MAJOR_VERSION) \
+		$(PREFIX)$(DEVEL_PREFIX)lib/$$i; \
+	done;
+ifeq ($(strip $(PTHREADS_DEBUG_SUPPORT)),y)
+	$(LN) -sf $(RUNTIME_PREFIX_LIB_FROM_DEVEL_PREFIX_LIB)libthread_db.so.1 \
+		$(PREFIX)$(DEVEL_PREFIX)lib/libthread_db.so
+endif
+#	# If we build shared libraries then the static libs are PIC...
+#	# Make _pic.a symlinks to make mklibs.py and similar tools happy.
+	for i in `find lib/  -type f -name '*.a' | sed -e 's/lib\///'` ; do \
+		$(LN) -sf $$i $(PREFIX)$(DEVEL_PREFIX)lib/`echo $$i \
+			| sed -e 's/\.a$$/_pic.a/'`; \
+	done;
+	# Ugh!!! Remember that libdl.a and libdl_pic.a are different.  Since
+	# libdl is pretty small, and not likely to benefit from mklibs.py and
+	# similar, lets just remove libdl_pic.a and avoid the issue
+	rm -f $(PREFIX)$(DEVEL_PREFIX)lib/libdl_pic.a
+endif
+
+
+# Installs run-time libraries
+install_runtime:
+ifeq ($(strip $(HAVE_SHARED)),y)
+	$(INSTALL) -d $(PREFIX)$(RUNTIME_PREFIX)lib
+	$(INSTALL) -m 644 lib/lib*-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so \
+		$(PREFIX)$(RUNTIME_PREFIX)lib
+	cp -dRf lib/*.so.* $(PREFIX)$(RUNTIME_PREFIX)lib
+	@if [ -x lib/ld-uClibc-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so ] ; then \
+	    set -e; \
+		$(SHELL_SET_X); \
+	    $(INSTALL) -m 755 lib/ld-uClibc-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so \
+	    		$(PREFIX)$(RUNTIME_PREFIX)lib; \
+	fi;
+endif
+
+.PHONY: utils
+ifeq ($(strip $(HAVE_SHARED)),y)
+utils:
+	$(MAKE) CROSS="$(CROSS)" CC="$(CC)" -C utils
+else
+utils: dummy
+endif
+
+# Installs helper applications, such as 'ldd' and 'ldconfig'
+install_utils: utils
+	$(MAKE) CROSS="$(CROSS)" CC="$(CC)" -C utils install
+#ifeq ($(strip $(UCLIBC_HAS_LOCALE)),y)
+#	@$(MAKE) -C libc/misc/wchar iconv.target
+#	$(INSTALL) -d $(PREFIX)$(RUNTIME_PREFIX)/usr/bin;
+#	$(INSTALL) -m 755 libc/misc/wchar/iconv.target $(PREFIX)$(RUNTIME_PREFIX)/usr/bin/iconv
+#endif
+
+finished2:
+	$(SECHO)
+	$(SECHO) Finished installing ...
+	$(SECHO)
+
+else # ifeq ($(strip $(HAVE_DOT_CONFIG)),y)
+
+all: menuconfig
+
+# configuration
+# ---------------------------------------------------------------------------
+extra/config/conf:
+	$(MAKE) -C extra/config conf
+
+extra/config/mconf:
+	$(MAKE) -C extra/config ncurses mconf
+
+menuconfig: extra/config/mconf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/mconf extra/Configs/Config.in
+
+config: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf extra/Configs/Config.in
+
+oldconfig: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -o extra/Configs/Config.in
+
+randconfig: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -r extra/Configs/Config.in
+
+allyesconfig: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -y extra/Configs/Config.in
+	sed -i -e "s/^DODEBUG=.*/# DODEBUG is not set/" .config
+	sed -i -e "s/^DOASSERTS=.*/# DOASSERTS is not set/" .config
+	sed -i -e "s/^SUPPORT_LD_DEBUG_EARLY=.*/# SUPPORT_LD_DEBUG_EARLY is not set/" .config
+	sed -i -e "s/^SUPPORT_LD_DEBUG=.*/# SUPPORT_LD_DEBUG is not set/" .config
+	sed -i -e "s/^UCLIBC_MJN3_ONLY=.*/# UCLIBC_MJN3_ONLY is not set/" .config
+	@./extra/config/conf -o extra/Configs/Config.in
+
+allnoconfig: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -n extra/Configs/Config.in
+
+defconfig: extra/config/conf
+	$(RM) -r include/bits
+	$(INSTALL) -d include/bits
+	@./extra/config/conf -d extra/Configs/Config.in
+
+clean:
+	- find . \( -name \*.o -o -name \*.a -o -name \*.so -o -name core -o -name .\#\* \) -exec $(RM) {} \;
+	@$(RM) -r tmp lib include/bits libc/tmp _install
+	$(RM) libc/obj.* headers
+	$(MAKE) -C test clean
+	$(MAKE) -C ldso clean
+	$(MAKE) -C libc/misc/internals clean
+	$(MAKE) -C libc/misc/wchar clean
+	$(MAKE) -C libc/unistd clean
+	$(MAKE) -C libc/sysdeps/linux/common clean
+	$(MAKE) -C extra/locale clean
+	$(MAKE) -C utils clean
+	@set -e; \
+	for i in `(cd $(TOPDIR)/libc/sysdeps/linux/common/sys; ls *.h)` ; do \
+		$(RM) include/sys/$$i; \
+	done; \
+	if [ -d libc/sysdeps/linux/$(TARGET_ARCH)/sys ] ; then \
+		for i in `(cd libc/sysdeps/linux/$(TARGET_ARCH)/sys; ls *.h)` ; do \
+			$(RM) include/sys/$$i; \
+		done; \
+	fi;
+	@$(RM) include/linux include/asm*
+	@if [ -d libc/sysdeps/linux/$(TARGET_ARCH) ]; then		\
+	    $(MAKE) -C libc/sysdeps/linux/$(TARGET_ARCH) clean;		\
+	fi;
+
+distclean: clean
+	$(RM) .config .config.old .config.cmd
+	$(MAKE) -C extra clean
+
+dist release:
+	$(RM) -r ../uClibc-$(VERSION) ../uClibc-$(VERSION).tar.bz2
+	svn -q export . ../uClibc-$(VERSION)
+	tar cjf ../uClibc-$(VERSION).tar.bz2 -C .. uClibc-$(VERSION)
+	du -b ../uClibc-$(VERSION).tar.bz2
+
+endif # ifeq ($(strip $(HAVE_DOT_CONFIG)),y)
+
+check:
+	$(MAKE) -C test
+
+.PHONY: dummy subdirs release distclean clean config oldconfig menuconfig
diff -Nrup a/Rules.mak b/Rules.mak
--- a/Rules.mak	2007-02-28 16:12:06.000000000 -0500
+++ b/Rules.mak	2008-02-28 19:02:10.000000000 -0500
@@ -234,6 +234,12 @@ ifeq ($(strip $(TARGET_ARCH)),frv)
 	UCLIBC_LDSO=ld.so.1
 endif
 
+ifeq ($(strip $(TARGET_ARCH)),avr32)
+	CPU_CFLAGS-$(CONFIG_AP7000)	+= -mcpu=ap7000
+	CPU_CFLAGS-$(LINKRELAX)		+= -masm-addr-pseudos -Wa,--pic,--linkrelax
+	CPU_LDFLAGS-$(LINKRELAX)	+= --relax
+endif
+
 # Keep the check_gcc from being needlessly executed
 ifndef PIEFLAG
 ifneq ($(UCLIBC_BUILD_PIE),y)
diff -Nrup a/Rules.mak.orig b/Rules.mak.orig
--- a/Rules.mak.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/Rules.mak.orig	2008-02-28 19:02:10.000000000 -0500
@@ -0,0 +1,361 @@
+# Rules.make for uClibc
+#
+# Copyright (C) 2000 by Lineo, inc.
+# Copyright (C) 2000-2002 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+
+#-----------------------------------------------------------
+# This file contains rules which are shared between multiple
+# Makefiles.  All normal configuration options live in the 
+# file named ".config".  Don't mess with this file unless 
+# you know what you are doing.
+
+
+#-----------------------------------------------------------
+# If you are running a cross compiler, you will want to set 
+# 'CROSS' to something more interesting ...  Target 
+# architecture is determined by asking the CC compiler what 
+# arch it compiles things for, so unless your compiler is 
+# broken, you should not need to specify TARGET_ARCH.
+#
+# Most people will set this stuff on the command line, i.e.
+#        make CROSS=arm-linux-
+# will build uClibc for 'arm'.
+
+ifndef CROSS
+CROSS=
+endif
+CC         = $(CROSS)gcc
+AR         = $(CROSS)ar
+LD         = $(CROSS)ld
+NM         = $(CROSS)nm
+RANLIB     = $(CROSS)ranlib
+STRIPTOOL  = $(CROSS)strip
+
+INSTALL    = install
+LN         = ln
+RM         = rm -f
+
+# Select the compiler needed to build binaries for your development system
+HOSTCC     = gcc
+HOSTCFLAGS = -O2 -Wall
+
+
+#---------------------------------------------------------
+# Nothing beyond this point should ever be touched by mere
+# mortals.  Unless you hang out with the gods, you should
+# probably leave all this stuff alone.
+MAJOR_VERSION := 0
+MINOR_VERSION := 9
+SUBLEVEL      := 28
+EXTRAVERSION  := 3
+VERSION       := $(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).$(EXTRAVERSION)
+# Ensure consistent sort order, 'gcc -print-search-dirs' behavior, etc.
+LC_ALL := C
+export MAJOR_VERSION MINOR_VERSION SUBLEVEL VERSION LC_ALL
+
+SHARED_FULLNAME:=libuClibc-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
+SHARED_MAJORNAME:=libc.so.$(MAJOR_VERSION)
+UCLIBC_LDSO:=ld-uClibc.so.$(MAJOR_VERSION)
+LIBNAME:=libc.a
+LIBC:=$(TOPDIR)libc/$(LIBNAME)
+
+# Make sure DESTDIR and PREFIX can be used to install
+# PREFIX is a uClibcism while DESTDIR is a common GNUism
+ifndef PREFIX
+PREFIX = $(DESTDIR)
+endif
+
+# Pull in the user's uClibc configuration
+ifeq ($(filter $(noconfig_targets),$(MAKECMDGOALS)),)
+-include $(TOPDIR).config
+endif
+
+ifndef CROSS
+CROSS=$(subst ",, $(strip $(CROSS_COMPILER_PREFIX)))
+endif
+
+# A nifty macro to make testing gcc features easier
+check_gcc=$(shell \
+	if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
+	then echo "$(1)"; else echo "$(2)"; fi)
+check_as=$(shell \
+	if $(CC) -Wa,$(1) -Wa,-Z -c -o /dev/null -xassembler /dev/null > /dev/null 2>&1; \
+	then echo "-Wa,$(1)"; fi)
+
+# Setup some shortcuts so that silent mode is silent like it should be
+ifeq ($(subst s,,$(MAKEFLAGS)),$(MAKEFLAGS))
+export MAKE_IS_SILENT=n
+SECHO=@echo
+SHELL_SET_X=set -x
+else
+export MAKE_IS_SILENT=y
+SECHO=-@false
+SHELL_SET_X=set +x
+endif
+
+# Make certain these contain a final "/", but no "//"s.
+TARGET_ARCH:=$(shell grep -s ^TARGET_ARCH $(TOPDIR)/.config | sed -e 's/^TARGET_ARCH=//' -e 's/"//g')
+RUNTIME_PREFIX:=$(strip $(subst //,/, $(subst ,/, $(subst ",, $(strip $(RUNTIME_PREFIX))))))
+DEVEL_PREFIX:=$(strip $(subst //,/, $(subst ,/, $(subst ",, $(strip $(DEVEL_PREFIX))))))
+export RUNTIME_PREFIX DEVEL_PREFIX
+
+ARFLAGS:=cr
+
+OPTIMIZATION:=
+PICFLAG:=-fPIC
+PIEFLAG_NAME:=-fPIE
+
+# Some nice CPU specific optimizations
+ifeq ($(strip $(TARGET_ARCH)),i386)
+	OPTIMIZATION+=$(call check_gcc,-mpreferred-stack-boundary=2,)
+	OPTIMIZATION+=$(call check_gcc,-falign-jumps=0 -falign-loops=0,-malign-jumps=0 -malign-loops=0)
+	CPU_CFLAGS-$(CONFIG_386)+=-march=i386
+	CPU_CFLAGS-$(CONFIG_486)+=-march=i486
+	CPU_CFLAGS-$(CONFIG_ELAN)+=-march=i486
+	CPU_CFLAGS-$(CONFIG_586)+=-march=i586
+	CPU_CFLAGS-$(CONFIG_586MMX)+=$(call check_gcc,-march=pentium-mmx,-march=i586)
+	CPU_CFLAGS-$(CONFIG_686)+=-march=i686
+	CPU_CFLAGS-$(CONFIG_PENTIUMII)+=$(call check_gcc,-march=pentium2,-march=i686)
+	CPU_CFLAGS-$(CONFIG_PENTIUMIII)+=$(call check_gcc,-march=pentium3,-march=i686)
+	CPU_CFLAGS-$(CONFIG_PENTIUM4)+=$(call check_gcc,-march=pentium4,-march=i686)
+	CPU_CFLAGS-$(CONFIG_K6)+=$(call check_gcc,-march=k6,-march=i586)
+	CPU_CFLAGS-$(CONFIG_K7)+=$(call check_gcc,-march=athlon,-malign-functions=4 -march=i686)
+	CPU_CFLAGS-$(CONFIG_CRUSOE)+=-march=i686 -malign-functions=0 -malign-jumps=0 -malign-loops=0
+	CPU_CFLAGS-$(CONFIG_WINCHIPC6)+=$(call check_gcc,-march=winchip-c6,-march=i586)
+	CPU_CFLAGS-$(CONFIG_WINCHIP2)+=$(call check_gcc,-march=winchip2,-march=i586)
+	CPU_CFLAGS-$(CONFIG_CYRIXIII)+=$(call check_gcc,-march=c3,-march=i486) -malign-functions=0 -malign-jumps=0 -malign-loops=0
+	CPU_CFLAGS-$(CONFIG_NEHEMIAH)+=$(call check_gcc,-march=c3-2,-march=i686)
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),arm)
+	OPTIMIZATION+=-fstrict-aliasing
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN)+=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN)+=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN)+=-mlittle-endian
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN)+=-mbig-endian
+	CPU_CFLAGS-$(CONFIG_GENERIC_ARM)+=
+	CPU_CFLAGS-$(CONFIG_ARM610)+=-mtune=arm610 -march=armv3
+	CPU_CFLAGS-$(CONFIG_ARM710)+=-mtune=arm710 -march=armv3
+	CPU_CFLAGS-$(CONFIG_ARM720T)+=-mtune=arm7tdmi -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM920T)+=-mtune=arm9tdmi -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM922T)+=-mtune=arm9tdmi -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM926T)+=-mtune=arm9tdmi -march=armv5
+	CPU_CFLAGS-$(CONFIG_ARM1136JF_S)+=-mtune=arm1136jf-s -march=armv6
+	CPU_CFLAGS-$(CONFIG_ARM_SA110)+=-mtune=strongarm110 -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM_SA1100)+=-mtune=strongarm1100 -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM_XSCALE)+=$(call check_gcc,-mtune=xscale,-mtune=strongarm110)
+	CPU_CFLAGS-$(CONFIG_ARM_XSCALE)+=-march=armv4 -Wa,-mcpu=xscale
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),mips)
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_1)+=-mips1
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_2)+=-mips2 -mtune=mips2
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_3)+=-mips3 -mtune=mips3
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_4)+=-mips4 -mtune=mips4
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS32)+=-mips32 -mtune=mips32
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS64)+=-mips64 -mtune=mips32
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),sh)
+	OPTIMIZATION+=-fstrict-aliasing
+	OPTIMIZATION+= $(call check_gcc,-mprefergot,)
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN)+=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN)+=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN)+=-ml
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN)+=-mb
+	CPU_CFLAGS-$(CONFIG_SH2)+=-m2
+	CPU_CFLAGS-$(CONFIG_SH3)+=-m3
+ifeq ($(strip $(UCLIBC_HAS_FLOATS)),y)
+	CPU_CFLAGS-$(CONFIG_SH2A)+=-m2a
+	CPU_CFLAGS-$(CONFIG_SH4)+=-m4
+else
+	CPU_CFLAGS-$(CONFIG_SH2A)+=-m2a-nofpu
+	CPU_CFLAGS-$(CONFIG_SH4)+=-m4-nofpu
+endif
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),sh64)
+	OPTIMIZATION+=-fstrict-aliasing
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN):=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN):=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN):=-ml
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN):=-mb
+	CPU_CFLAGS-$(CONFIG_SH5)+=-m5-32media
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),h8300)
+	CPU_LDFLAGS-$(CONFIG_H8300H)+= -ms8300h
+	CPU_LDFLAGS-$(CONFIG_H8S)   += -ms8300s
+	CPU_CFLAGS-$(CONFIG_H8300H) += -mh -mint32 -fsigned-char
+	CPU_CFLAGS-$(CONFIG_H8S)    += -ms -mint32 -fsigned-char
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),cris)
+	CPU_LDFLAGS-$(CONFIG_CRIS)+=-mcrislinux
+	CPU_CFLAGS-$(CONFIG_CRIS)+=-mlinux
+	PICFLAG:=-fpic
+	PIEFLAG_NAME:=-fpie
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),powerpc)
+# PowerPC can hold 8192 entries in its GOT with -fpic which is more than
+# enough. Therefore use -fpic which will reduce code size and generates
+# faster code.
+	PICFLAG:=-fpic
+	PIEFLAG_NAME:=-fpie
+	PPC_HAS_REL16:=$(shell echo -e "\t.text\n\taddis 11,30,_GLOBAL_OFFSET_TABLE_-.@ha" | $(CC) -c -x assembler -o /dev/null -  2> /dev/null && echo -n y || echo -n n)
+	CPU_CFLAGS-$(PPC_HAS_REL16)+= -DHAVE_ASM_PPC_REL16
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),frv)
+	CPU_LDFLAGS-$(CONFIG_FRV)+=-melf32frvfd
+	CPU_CFLAGS-$(CONFIG_FRV)+=-mfdpic
+	# Using -pie causes the program to have an interpreter, which is
+	# forbidden, so we must make do with -shared.  Unfortunately,
+	# -shared by itself would get us global function descriptors
+	# and calls through PLTs, dynamic resolution of symbols, etc,
+	# which would break as well, but -Bsymbolic comes to the rescue.
+	export LDPIEFLAG:=-shared -Bsymbolic
+	UCLIBC_LDSO=ld.so.1
+endif
+
+ifeq ($(strip $(TARGET_ARCH)),avr32)
+	CPU_CFLAGS-$(CONFIG_AP7000)	+= -mcpu=ap7000
+endif
+
+# Keep the check_gcc from being needlessly executed
+ifndef PIEFLAG
+ifneq ($(UCLIBC_BUILD_PIE),y)
+export PIEFLAG:=
+else
+export PIEFLAG:=$(call check_gcc,$(PIEFLAG_NAME),$(PICFLAG))
+endif
+endif
+# We need to keep track of both the CC PIE flag (above) as 
+# well as the LD PIE flag (below) because we can't rely on 
+# gcc passing -pie if we used -fPIE
+ifndef LDPIEFLAG
+ifneq ($(UCLIBC_BUILD_PIE),y)
+export LDPIEFLAG:=
+else
+export LDPIEFLAG:=$(shell $(LD) --help | grep -q pie && echo "-Wl,-pie")
+endif
+endif
+
+# Use '-Os' optimization if available, else use -O2, allow Config to override
+OPTIMIZATION+=$(call check_gcc,-Os,-O2)
+# Use the gcc 3.4 -funit-at-a-time optimization when available
+OPTIMIZATION+=$(call check_gcc,-funit-at-a-time,)
+
+# Add a bunch of extra pedantic annoyingly strict checks
+XWARNINGS=$(subst ",, $(strip $(WARNINGS))) -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing
+XARCH_CFLAGS=$(subst ",, $(strip $(ARCH_CFLAGS)))
+CPU_CFLAGS=$(subst ",, $(strip $(CPU_CFLAGS-y)))
+
+LDADD_LIBFLOAT=
+ifeq ($(strip $(UCLIBC_HAS_SOFT_FLOAT)),y)
+# Add -msoft-float to the CPU_FLAGS since ldso and libdl ignore CFLAGS.
+# If -msoft-float isn't supported, we want an error anyway.
+# Hmm... might need to revisit this for arm since it has 2 different
+# soft float encodings.
+    CPU_CFLAGS += -msoft-float
+ifeq ($(strip $(TARGET_ARCH)),arm)
+# No longer needed with current toolchains, but leave it here for now.
+# If anyone is actually still using gcc 2.95 (say), they can uncomment it.
+#    LDADD_LIBFLOAT=-lfloat
+endif
+endif
+
+SSP_DISABLE_FLAGS:=$(call check_gcc,-fno-stack-protector,)
+ifeq ($(UCLIBC_BUILD_SSP),y)
+SSP_CFLAGS:=$(call check_gcc,-fno-stack-protector-all,)
+SSP_CFLAGS+=$(call check_gcc,-fstack-protector,)
+SSP_ALL_CFLAGS:=$(call check_gcc,-fstack-protector-all,)
+else
+SSP_CFLAGS:=$(SSP_DISABLE_FLAGS)
+endif
+
+# Some nice CFLAGS to work with
+CFLAGS:=$(XWARNINGS) $(CPU_CFLAGS) $(SSP_CFLAGS) \
+	-fno-builtin -nostdinc -D_LIBC -I$(TOPDIR)include -I.
+LDFLAGS_NOSTRIP:=$(CPU_LDFLAGS-y) -shared --warn-common --warn-once -z combreloc -z defs
+
+ifeq ($(DODEBUG),y)
+    #CFLAGS += -g3
+    CFLAGS += -O0 -g3
+    LDFLAGS := $(LDFLAGS_NOSTRIP)
+    STRIPTOOL:= true -Since_we_are_debugging
+else
+    CFLAGS += $(OPTIMIZATION) $(XARCH_CFLAGS)
+    LDFLAGS := $(LDFLAGS_NOSTRIP) -s
+endif
+
+ifeq ($(UCLIBC_BUILD_RELRO),y)
+LDFLAGS+=-z relro
+endif
+
+ifeq ($(UCLIBC_BUILD_NOW),y)
+LDFLAGS+=-z now
+endif
+
+# Sigh, some stupid versions of gcc can't seem to cope with '-iwithprefix include'
+#CFLAGS+=-iwithprefix include
+CFLAGS+=-isystem $(shell $(CC) -print-file-name=include)
+
+ifneq ($(DOASSERTS),y)
+    CFLAGS += -DNDEBUG
+endif
+
+CFLAGS_NOPIC:=$(CFLAGS)
+ifeq ($(DOPIC),y)
+    CFLAGS += $(PICFLAG)
+endif
+
+ifeq ($(DL_FINI_CRT_COMPAT),y)
+CFLAGS += -D_DL_FINI_CRT_COMPAT
+endif
+
+# Keep the check_as from being needlessly executed
+ASFLAGS = $(CFLAGS)
+ifndef ASFLAGS_NOEXEC
+ifeq ($(UCLIBC_BUILD_NOEXECSTACK),y)
+export ASFLAGS_NOEXEC := $(call check_as,--noexecstack)
+else
+export ASFLAGS_NOEXEC :=
+endif
+endif
+ASFLAGS += $(ASFLAGS_NOEXEC)
+
+LIBGCC_CFLAGS ?= $(CFLAGS) $(CPU_CFLAGS-y)
+LIBGCC:=$(shell $(CC) $(LIBGCC_CFLAGS) -print-libgcc-file-name)
+LIBGCC_DIR:=$(dir $(LIBGCC))
+
+########################################
+#
+# uClinux shared lib support
+#
+
+ifeq ($(CONFIG_BINFMT_SHARED_FLAT),y)
+  # For the shared version of this, we specify no stack and its library ID
+  FLTFLAGS += -s 0
+  LIBID=1
+  export LIBID FLTFLAGS
+  SHARED_TARGET = lib/libc
+endif
+
+TARGET_ARCH:=$(strip $(subst ",, $(strip $(TARGET_ARCH))))
diff -Nrup a/utils/ldd.c b/utils/ldd.c
--- a/utils/ldd.c	2004-10-06 03:34:17.000000000 -0400
+++ b/utils/ldd.c	2008-02-28 19:02:10.000000000 -0500
@@ -56,6 +56,11 @@
 #define ELFCLASSM	ELFCLASS32
 #endif
 
+#if defined(__avr32__)
+#define MATCH_MACHINE(x) (x == EM_AVR32)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #if defined(__s390__)
 #define MATCH_MACHINE(x) (x == EM_S390)
 #define ELFCLASSM	ELFCLASS32
