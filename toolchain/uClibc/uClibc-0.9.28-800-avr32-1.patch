Index: uclibc/Makefile
===================================================================
RCS file: /disk1/ic_group/design/I9980/REPOSITORY/I7413/source/uclibc/Makefile,v
retrieving revision 1.1.1.3
diff -u -r1.1.1.3 Makefile
--- uclibc/Makefile	31 Aug 2005 13:08:25 -0000	1.1.1.3
+++ uclibc/Makefile	7 Dec 2005 06:38:39 -0000
@@ -163,7 +163,7 @@
 	else \
 		extra_exclude="" ; \
 	fi ; \
-	tar -chf - include --exclude .svn --exclude CVS $$extra_exclude \
+	tar -chf - --exclude .svn --exclude CVS $$extra_exclude include \
 		| tar -xf - -C $(PREFIX)$(DEVEL_PREFIX)
 ifneq ($(strip $(UCLIBC_HAS_FLOATS)),y)
 	# Remove floating point related headers since float support is disabled.
--- a/extra/scripts/fix_includes.sh	2005-08-18 00:49:41.000000000 +0200
+++ b/extra/scripts/fix_includes.sh	2006-09-27 13:23:12.000000000 +0200
@@ -78,36 +78,6 @@ if [ ! -d "$KERNEL_SOURCE" ]; then
     exit 1;
 fi;
 
-if [ -f "$KERNEL_SOURCE/Makefile" ] ; then
-# set current VERSION, PATCHLEVEL, SUBLEVEL, EXTRAVERSION
-eval `sed -n -e 's/^\([A-Z]*\) = \([0-9]*\)$/\1=\2/p' -e 's/^\([A-Z]*\) = \(-[-a-z0-9]*\)$/\1=\2/p' $KERNEL_SOURCE/Makefile`
-else
-ver=`grep UTS_RELEASE $KERNEL_SOURCE/include/linux/version.h | cut -d '"' -f 2`
-VERSION=`echo "$ver" | cut -d '.' -f 1`
-PATCHLEVEL=`echo "$ver" | cut -d '.' -f 2`
-if echo "$ver" | grep -q '-' ; then
-SUBLEVEL=`echo "$ver" | sed "s/${VERSION}.${PATCHLEVEL}.//" | cut -d '-' -f 1`
-EXTRAVERSION=`echo "$ver" | sed "s/${VERSION}.${PATCHLEVEL}.${SUBLEVEL}-//"`
-else
-SUBLEVEL=`echo "$ver" | cut -d '.' -f 3`
-#EXTRAVERSION=
-fi
-fi
-if [ -z "$VERSION" -o -z "$PATCHLEVEL" -o -z "$SUBLEVEL" ]
-then
-    echo "Unable to determine version for kernel headers"
-    echo -e "\tprovided in directory $KERNEL_SOURCE"
-    exit 1
-fi
-
-if [ "$MAKE_IS_SILENT" != "y" ]; then
-echo "Current kernel version is $VERSION.$PATCHLEVEL.$SUBLEVEL${EXTRAVERSION}"
-echo -e "\n"
-echo "Using kernel headers from $VERSION.$PATCHLEVEL.$SUBLEVEL${EXTRAVERSION} for architecture '$TARGET_ARCH'"
-echo -e "\tprovided in directory $KERNEL_SOURCE"
-echo -e "\n"
-fi
-
 # Create a symlink to include/asm
 
 rm -f include/asm*
@@ -172,7 +142,7 @@ fi;
 
 
 # Annoyingly, 2.6.x kernel headers also need an include/asm-generic/ directory
-if [ $VERSION -eq 2 ] && [ $PATCHLEVEL -ge 6 ] ; then
+if [ -d $KERNEL_SOURCE/include/asm-generic ] ; then
     ln -fs $KERNEL_SOURCE/include/asm-generic include/asm-generic
 fi;
 
From 7b2f125425cf777e7937b533217588e27952b87d Mon Sep 17 00:00:00 2001
From: Haavard Skinnemoen <hskinnemoen@atmel.com>
Date: Mon, 7 Aug 2006 11:12:50 +0200
Subject: [PATCH] Let optimized stringops override default ones

The default, slow stringops must be archived _before_ the optimized
stringops if there is to be any point doing the optimizations in the
first place.
---
 libc/Makefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/libc/Makefile b/libc/Makefile
index 31e4bab..687eac5 100644
--- a/libc/Makefile
+++ b/libc/Makefile
@@ -59,7 +59,7 @@ # will evaluate to no files :(.
 	$(AR) dN 2 $(LIBNAME) $$objs && \
 	$(AR) dN 2 $(LIBNAME) $$objs
 	@for objfile in obj.signal \
-	                obj.string.generic obj.string.$(TARGET_ARCH) obj.string \
+	                obj.string obj.string.generic obj.string.$(TARGET_ARCH) \
 	                obj.sysdeps.common obj.sysdeps.$(TARGET_ARCH) ; do \
 		if [ -e $$objfile ] ; then \
 			if [ "$(MAKE_IS_SILENT)" = "n" ] ; then \
-- 
1.4.1.1

Subject: [PATCH] Fix getrusage argument type

The first argument to getrusage is of type __rusage_who_t, not int.
This patch fixes that.
---

 libc/sysdeps/linux/common/getrusage.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: uClibc-0.9.28/libc/sysdeps/linux/common/getrusage.c
===================================================================
--- uClibc-0.9.28.orig/libc/sysdeps/linux/common/getrusage.c	2006-02-07 17:18:22.000000000 +0100
+++ uClibc-0.9.28/libc/sysdeps/linux/common/getrusage.c	2006-02-07 17:18:31.000000000 +0100
@@ -10,4 +10,4 @@
 #include "syscalls.h"
 #include <unistd.h>
 #include <wait.h>
-_syscall2(int, getrusage, int, who, struct rusage *, usage);
+_syscall2(int, getrusage, __rusage_who_t, who, struct rusage *, usage);
Subject: [PATCH] Fix __libc_fcntl64 prototype in __syscall_fcntl.c

__libc_fcntl64 is a varargs function and should be declared as such.
Otherwise, the gcc compiler for AVR32, and perhaps other architectures,
will use the wrong calling convention.

---

 libc/sysdeps/linux/common/__syscall_fcntl.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: uClibc-0.9.28/libc/sysdeps/linux/common/__syscall_fcntl.c
===================================================================
--- uClibc-0.9.28.orig/libc/sysdeps/linux/common/__syscall_fcntl.c	2006-02-07 16:48:32.000000000 +0100
+++ uClibc-0.9.28/libc/sysdeps/linux/common/__syscall_fcntl.c	2006-02-07 17:19:09.000000000 +0100
@@ -12,7 +12,7 @@
 #include <fcntl.h>
 
 #if defined __UCLIBC_HAS_LFS__ && defined __NR_fcntl64
-extern int __libc_fcntl64(int fd, int cmd, long arg);
+extern int __libc_fcntl64(int fd, int cmd, ...);
 #endif
 
 #define __NR___syscall_fcntl __NR_fcntl
From nobody Mon Sep 17 00:00:00 2001
From: HÃ¥vard Skinnemoen <hskinnemoen@atmel.com>
Date: Fri Apr 7 17:10:32 2006 +0200
Subject: [PATCH] Fix broken __libc_open declaration in open64.c

__libc_open is a vararg function and should therefore be declared as
such. Fixes bug #4190.

---

 libc/sysdeps/linux/common/open64.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

70f2c81903327a8a346e370830932b80045ab04e
diff --git a/libc/sysdeps/linux/common/open64.c b/libc/sysdeps/linux/common/open64.c
index 543aa13..d9a27a7 100644
--- a/libc/sysdeps/linux/common/open64.c
+++ b/libc/sysdeps/linux/common/open64.c
@@ -26,7 +26,7 @@
 #endif
 
 #ifdef __UCLIBC_HAS_LFS__
-extern int __libc_open (__const char *file, int oflag, mode_t mode);
+extern int __libc_open (__const char *file, int oflag, ...);
 
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
-- 
1.2.4

Subject: [PATCH] AVR32 Architecture support

Add support for the AVR32 architecture in the core libc and build system.
This also adds AVR32-ELF definitions to elf.h

---

 Rules.mak                                      |    4 
 extra/Configs/Config.avr32                     |   38 +++++
 extra/Configs/Config.in                        |    7 +
 include/elf.h                                  |   51 +++++++
 libc/sysdeps/linux/avr32/Makefile              |   93 +++++++++++++
 libc/sysdeps/linux/avr32/__longjmp.S           |   17 ++
 libc/sysdeps/linux/avr32/_mmap.c               |   33 ++++
 libc/sysdeps/linux/avr32/bits/atomicity.h      |   86 ++++++++++++
 libc/sysdeps/linux/avr32/bits/byteswap.h       |   80 +++++++++++
 libc/sysdeps/linux/avr32/bits/endian.h         |    7 +
 libc/sysdeps/linux/avr32/bits/fcntl.h          |  167 +++++++++++++++++++++++++
 libc/sysdeps/linux/avr32/bits/kernel_stat.h    |   63 +++++++++
 libc/sysdeps/linux/avr32/bits/kernel_types.h   |   56 ++++++++
 libc/sysdeps/linux/avr32/bits/machine-gmon.h   |   69 ++++++++++
 libc/sysdeps/linux/avr32/bits/mman.h           |   95 ++++++++++++++
 libc/sysdeps/linux/avr32/bits/profil-counter.h |   26 +++
 libc/sysdeps/linux/avr32/bits/setjmp.h         |   21 +++
 libc/sysdeps/linux/avr32/bits/syscalls.h       |  143 +++++++++++++++++++++
 libc/sysdeps/linux/avr32/bits/wordsize.h       |    1 
 libc/sysdeps/linux/avr32/brk.c                 |   23 +++
 libc/sysdeps/linux/avr32/bsd-_setjmp.S         |   12 +
 libc/sysdeps/linux/avr32/bsd-setjmp.S          |   12 +
 libc/sysdeps/linux/avr32/clone.c               |   37 +++++
 libc/sysdeps/linux/avr32/crt1.S                |   93 +++++++++++++
 libc/sysdeps/linux/avr32/crti.S                |   17 ++
 libc/sysdeps/linux/avr32/crtn.S                |   14 ++
 libc/sysdeps/linux/avr32/mmap.c                |   31 ++++
 libc/sysdeps/linux/avr32/setjmp.S              |   43 ++++++
 libc/sysdeps/linux/avr32/sigaction.c           |   49 +++++++
 libc/sysdeps/linux/avr32/sigrestorer.S         |   11 +
 libc/sysdeps/linux/avr32/sys/elf.h             |   26 +++
 libc/sysdeps/linux/avr32/sys/io.h              |   48 +++++++
 libc/sysdeps/linux/avr32/sys/procfs.h          |  123 ++++++++++++++++++
 libc/sysdeps/linux/avr32/sys/ucontext.h        |   94 ++++++++++++++
 libc/sysdeps/linux/avr32/sys/user.h            |   46 ++++++
 libc/sysdeps/linux/avr32/syscall.S             |   81 ++++++++++++
 libc/sysdeps/linux/avr32/vfork.S               |   55 ++++++++
 37 files changed, 1872 insertions(+)

Index: uClibc-0.9.28/extra/Configs/Config.avr32
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/extra/Configs/Config.avr32	2006-05-05 09:27:17.000000000 +0200
@@ -0,0 +1,38 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config HAVE_ELF
+	bool
+	default y
+
+config TARGET_ARCH
+	default "avr32"
+
+config ARCH_CFLAGS
+	string
+
+config ARCH_LDFLAGS
+	string
+
+config LIBGCC_CFLAGS
+	string
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+	bool
+	default y
+
+config UCLIBC_COMPLETELY_PIC
+	select FORCE_SHAREABLE_TEXT_SEGMENTS
+	bool
+	default y
+
+choice
+	prompt "Target CPU Type"
+	default CONFIG_AP7000
+
+config CONFIG_AP7000
+	bool "AP7000"
+
+endchoice
Index: uClibc-0.9.28/extra/Configs/Config.in
===================================================================
--- uClibc-0.9.28.orig/extra/Configs/Config.in	2006-04-19 12:47:48.000000000 +0200
+++ uClibc-0.9.28/extra/Configs/Config.in	2006-04-19 12:48:33.000000000 +0200
@@ -16,6 +16,9 @@ config TARGET_alpha
 config TARGET_arm
 	bool "arm"
 
+config TARGET_avr32
+	bool "avr32"
+
 config TARGET_bfin
 	bool "bfin"
 
@@ -83,6 +86,10 @@ if TARGET_arm
 source "extra/Configs/Config.arm"
 endif
 
+if TARGET_avr32
+source "extra/Configs/Config.avr32"
+endif
+
 if TARGET_bfin
 source "extra/Configs/Config.bfin"
 endif
Index: uClibc-0.9.28/include/elf.h
===================================================================
--- uClibc-0.9.28.orig/include/elf.h	2006-04-19 12:47:48.000000000 +0200
+++ uClibc-0.9.28/include/elf.h	2006-05-05 09:28:38.000000000 +0200
@@ -261,6 +261,8 @@ typedef struct
 #define EM_NIOS32	0xfebb		/* Altera Nios 32 */
 #define EM_ALTERA_NIOS2  0x9ee5	/* Altera Nios II */
 
+#define EM_AVR32	0x18ad
+
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850 0x9080
 
@@ -2687,6 +2689,55 @@ typedef Elf32_Addr Elf32_Conflict;
 /* Keep this the last entry.  */
 #define R_V850_NUM		25
 
+/* Atmel AVR32 relocations.  */
+#define R_AVR32_NONE		0
+#define R_AVR32_32		1
+#define R_AVR32_16		2
+#define R_AVR32_8		3
+#define R_AVR32_32_PCREL	4
+#define R_AVR32_16_PCREL	5
+#define R_AVR32_8_PCREL		6
+#define R_AVR32_DIFF32		7
+#define R_AVR32_DIFF16		8
+#define R_AVR32_DIFF8		9
+#define R_AVR32_GOT32		10
+#define R_AVR32_GOT16		11
+#define R_AVR32_GOT8		12
+#define R_AVR32_21S		13
+#define R_AVR32_16U		14
+#define R_AVR32_16S		15
+#define R_AVR32_8S		16
+#define R_AVR32_8S_EXT		17
+#define R_AVR32_22H_PCREL	18
+#define R_AVR32_18W_PCREL	19
+#define R_AVR32_16B_PCREL	20
+#define R_AVR32_16N_PCREL	21
+#define R_AVR32_14UW_PCREL	22
+#define R_AVR32_11H_PCREL	23
+#define R_AVR32_10UW_PCREL	24
+#define R_AVR32_9H_PCREL	25
+#define R_AVR32_9UW_PCREL	26
+#define R_AVR32_HI16		27
+#define R_AVR32_LO16		28
+#define R_AVR32_GOTPC		29
+#define R_AVR32_GOTCALL		30
+#define R_AVR32_LDA_GOT		31
+#define R_AVR32_GOT21S		32
+#define R_AVR32_GOT18SW		33
+#define R_AVR32_GOT16S		34
+#define R_AVR32_GOT7UW		35
+#define R_AVR32_32_CPENT	36
+#define R_AVR32_CPCALL		37
+#define R_AVR32_16_CP		38
+#define R_AVR32_9W_CP		39
+#define R_AVR32_RELATIVE	40
+#define R_AVR32_GLOB_DAT	41
+#define R_AVR32_JMP_SLOT	42
+#define R_AVR32_ALIGN		43
+#define R_AVR32_NUM		44
+
+/* AVR32 dynamic tags */
+#define DT_AVR32_GOTSZ		0x70000001 /* Total size of GOT in bytes */
 
 #define R_H8_NONE       0
 #define R_H8_DIR32      1
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/Makefile	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,93 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../../
+include $(TOPDIR)Rules.mak
+ASFLAGS=$(CFLAGS)
+
+CRT_SRC	= crt1.S
+CRT_OBJ = crt1.o
+SCRT_OBJ = $(patsubst %,S%, $(CRT_OBJ))
+CTOR_TARGETS=$(TOPDIR)lib/crti.o $(TOPDIR)lib/crtn.o
+
+SSRC=__longjmp.S setjmp.S bsd-setjmp.S vfork.S \
+	bsd-_setjmp.S sigrestorer.S syscall.S
+SOBJS=$(patsubst %.S,%.o, $(SSRC))
+
+CSRC=clone.c brk.c sigaction.c mmap.c
+COBJS=$(patsubst %.c,%.o, $(CSRC))
+
+OBJS=$(SOBJS) $(COBJS)
+
+OBJ_LIST=../../../obj.sysdeps.$(TARGET_ARCH)
+
+all: $(OBJ_LIST)
+
+$(OBJ_LIST): $(OBJS) $(CRT_OBJ) $(SCRT_OBJ) $(CTOR_TARGETS)
+	echo $(patsubst %, sysdeps/linux/$(TARGET_ARCH)/%, $(OBJS)) > $(OBJ_LIST)
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp $(CRT_OBJ) $(SCRT_OBJ) $(TOPDIR)lib/
+
+$(CRT_OBJ): $(CRT_SRC)
+	$(CC) $(ASFLAGS) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SCRT_OBJ): $(CRT_SRC)
+	$(CC) $(ASFLAGS) $(PIEFLAG) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SOBJS): %.o : %.S
+	$(CC) $(ASFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(COBJS): %.o : %.c
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+ifeq ($(strip $(UCLIBC_CTOR_DTOR)),y)
+crti.o: crti.S
+	$(CC) $(ASFLAGS) -c crti.S -o crti.o
+
+$(TOPDIR)lib/crti.o: crti.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crti.o $(TOPDIR)lib/
+
+crtn.o: crtn.S
+	$(CC) $(ASFLAGS) -c crtn.S -o crtn.o
+
+$(TOPDIR)lib/crtn.o: crtn.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crtn.o $(TOPDIR)lib/
+else
+$(TOPDIR)lib/crti.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crti.o
+$(TOPDIR)lib/crtn.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crtn.o
+endif
+
+
+headers:
+#	$(LN) -fs ../libc/sysdeps/linux/avr32/fpu_control.h $(TOPDIR)/include/
+
+clean:
+	$(RM) *.[oa] *~ core
+	$(RM) bits/sysnum.h
+	$(RM) gmon-start.S
+
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/__longjmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/__longjmp.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,17 @@
+/* longjmp for AVR32
+ *
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	.global	__longjmp
+	.type	__longjmp,"function"
+	.align	1
+__longjmp:
+	ldm	r12++, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
+	mov	r12, r11	/* get the return value right */
+	mustr	r8		/* restore status register (lower half) */
+	cp	r12, 0		/* can't return zero */
+	frs
+	moveq	r12, 1
+	mov	pc,lr
+	.size	__longjmp, . - __longjmp
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/_mmap.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/_mmap.c	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,33 @@
+/* Copyright (C) 2005 Atmel Norway
+
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Library General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+   details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+   Derived in part from the Linux-8086 C library, the GNU C Library, and several
+   other sundry sources.  Files within this library are copyright by their
+   respective copyright holders.
+ */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+#define __NR_mmap2 __NR_mmap
+
+static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot, int, flags, int, fd, __off_t, pgoff);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+	return mmap2(addr, len, prot, flags, fd, offset >> 12);
+}
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/atomicity.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/atomicity.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,86 @@
+/* Low-level functions for atomic operations.  AVR32 version.
+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ATOMICITY_H
+#define _ATOMICITY_H 1
+
+#include <inttypes.h>
+
+static inline int
+__attribute__((unused))
+exchange_and_add (volatile uint32_t *mem, int val)
+{
+	int tmp, result;
+
+	__asm__ __volatile__(
+		"/* Inline exchange and add */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %3\n"
+		"	add	%1, %0, %4\n"
+		"	stcond	%2, %1\n"
+		"	brne	1b"
+		: "=&r"(result), "=&r"(tmp), "=m"(*mem)
+		: "m"(*mem), "r"(val)
+		: "cc", "memory");
+
+	return result;
+}
+
+static inline void
+__attribute__((unused))
+atomic_add (volatile uin32_t *mem, int val)
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline atomic add */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %2\n"
+		"	add	%0, %3\n"
+		"	stcond	%2, %0\n"
+		"	brne	1b"
+		: "=&r"(result), "=m"(*mem)
+		: "m"(*mem), "r"(val)
+		: "cc", "memory");
+}
+
+static inline int
+__attribute__((unused))
+compare_and_swap(volatile long int *p, long int oldval, long int newval)
+{
+	long int result, tmp;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%1, %3\n"
+		"	cp.w	%1, %5\n"
+		"	sreq	%0\n"
+		"	brne	2f\n"
+		"	stcond	%2, %4\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=&r"(tmp), "=m"(*p)
+		: "m"(*p), "r"(newval), "r"(oldval)
+		: "cc", "memory");
+
+	return result;
+}
+
+#endif /* atomicity.h */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/byteswap.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/byteswap.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,80 @@
+/* Macros to swap the order of bytes in integer values.
+   Copyright (C) 2005 Atmel Norway.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+/* Swap bytes in 16 bit value.  */
+#if defined __GNUC__
+# define __bswap_16(x) (__extension__ __builtin_bswap_16(x))
+#else
+/* This is better than nothing.  */
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+	return ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8));
+}
+#endif
+
+/* Swap bytes in 32 bit value.  */
+#if defined __GNUC__
+# define __bswap_32(x) (__extension__ __builtin_bswap_32(x))
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |
+	  (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24));
+}
+#endif
+
+#if defined __GNUC__
+/* Swap bytes in 64 bit value.  */
+# define __bswap_constant_64(x)				\
+	((((x) & 0xff00000000000000ull) >> 56)		\
+	 | (((x) & 0x00ff000000000000ull) >> 40)	\
+	 | (((x) & 0x0000ff0000000000ull) >> 24)	\
+	 | (((x) & 0x000000ff00000000ull) >> 8)		\
+	 | (((x) & 0x00000000ff000000ull) << 8)		\
+	 | (((x) & 0x0000000000ff0000ull) << 24)	\
+	 | (((x) & 0x000000000000ff00ull) << 40)	\
+	 | (((x) & 0x00000000000000ffull) << 56))
+
+# define __bswap_64(x)							\
+	(__extension__							\
+	 ({								\
+		 union {						\
+			 __extension__ unsigned long long int __ll;	\
+			 unsigned int __l[2];				\
+		 } __w, __r;						\
+		 if (__builtin_constant_p(x))				\
+			 __r.__ll = __bswap_constant_64(x);		\
+		 else {							\
+			 __w.__ll = (x);				\
+			 __r.__l[0] = __bswap_32(__w.__l[1]);		\
+			 __r.__l[1] = __bswap_32(__w.__l[0]);		\
+		 }							\
+		 __r.__ll;						\
+	 }))
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/endian.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/endian.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,7 @@
+/* AVR32 is big-endian */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/fcntl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/fcntl.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ *
+ * This file is part of the Linux kernel
+ */
+#ifndef _FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	  0003
+#define O_RDONLY	    00
+#define O_WRONLY	    01
+#define O_RDWR		    02
+#define O_CREAT		  0100	/* not fcntl */
+#define O_EXCL		  0200	/* not fcntl */
+#define O_NOCTTY	  0400	/* not fcntl */
+#define O_TRUNC		 01000	/* not fcntl */
+#define O_APPEND	 02000
+#define O_NONBLOCK	 04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		010000
+#define O_ASYNC		020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	040000	/* must be a directory */
+# define O_NOFOLLOW	0100000	/* don't follow links */
+# define O_DIRECT	0200000	/* direct disk access */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5
+# define F_SETLK	6
+# define F_SETLKW	7
+#else
+# define F_GETLK	F_GETLK64
+# define F_SETLK	F_SETLK64
+# define F_SETLKW	F_SETLKW64
+#endif
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/*  for sockets. */
+# define F_GETOWN	9	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/*  for sockets. */
+# define F_GETSIG	11	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+#ifdef __USE_BSD
+/* operations for bsd flock(), also used by the kernel implementation */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock */
+# define LOCK_READ	64	/* ... Which allows concurrent
+				       read operations */
+# define LOCK_WRITE	128	/* ... Which allows concurrent
+				       write operations */
+# define LOCK_RW	192	/* ... Which allows concurrent
+				       read & write ops */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock {
+	short l_type;
+	short l_whence;
+#ifndef __USE_FILE_OFFSET64
+	__off_t l_start;
+	__off_t l_len;
+#else
+	__off64_t l_start;
+	__off64_t l_len;
+#endif
+	__pid_t l_pid;
+};
+
+#ifdef __USE_LARGEFILE64
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	__off64_t l_start;
+	__off64_t l_len;
+	__pid_t  l_pid;
+};
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+ *    BSD systems which did not managed to hide these kernel macros.  */
+#ifdef  __USE_BSD
+# define FAPPEND        O_APPEND
+# define FFSYNC         O_FSYNC
+# define FASYNC         O_ASYNC
+# define FNONBLOCK      O_NONBLOCK
+# define FNDELAY        O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL      0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM      1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL  2 /* Expect sequential page references.  */
+# define POSIX_FADV_WILLNEED    3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED    4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE     5 /* Data will be accessed once.  */
+#endif
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/kernel_stat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/kernel_stat.h	2006-05-05 09:28:32.000000000 +0200
@@ -0,0 +1,63 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+/*
+ * This file provides struct stat, taken from kernel 2.6.4
+ * (include/asm-avr32/stat.h revision 1.1).
+ */
+
+struct kernel_stat {
+        unsigned long st_dev;
+        unsigned long st_ino;
+        unsigned short st_mode;
+        unsigned short st_nlink;
+        unsigned short st_uid;
+        unsigned short st_gid;
+        unsigned long  st_rdev;
+        unsigned long  st_size;
+        unsigned long  st_blksize;
+        unsigned long  st_blocks;
+        unsigned long  st_atime;
+        unsigned long  st_atime_nsec;
+        unsigned long  st_mtime;
+        unsigned long  st_mtime_nsec;
+        unsigned long  st_ctime;
+        unsigned long  st_ctime_nsec;
+        unsigned long  __unused4;
+        unsigned long  __unused5;
+};
+
+#define STAT_HAVE_NSEC 1
+
+struct kernel_stat64 {
+	unsigned long long st_dev;
+
+	unsigned long long st_ino;
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long st_rdev;
+
+	long long	st_size;
+	unsigned long	__pad1;
+	unsigned long	st_blksize;
+
+	unsigned long long st_blocks;
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+};
+
+#endif /* _BITS_STAT_STRUCT_H */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/kernel_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/kernel_types.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,56 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts
+ * with the posix_types.h kernel header, and will ensure that
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ASM_AVR32_POSIX_TYPES_H
+#define __ASM_AVR32_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_dev_t;
+typedef unsigned long   __kernel_ino_t;
+typedef unsigned short  __kernel_mode_t;
+typedef unsigned short  __kernel_nlink_t;
+typedef long            __kernel_off_t;
+typedef int             __kernel_pid_t;
+typedef unsigned short  __kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned long	__kernel_size_t;
+typedef int             __kernel_ssize_t;
+typedef int             __kernel_ptrdiff_t;
+typedef long            __kernel_time_t;
+typedef long            __kernel_suseconds_t;
+typedef long            __kernel_clock_t;
+typedef int             __kernel_timer_t;
+typedef int             __kernel_clockid_t;
+typedef int             __kernel_daddr_t;
+typedef char *          __kernel_caddr_t;
+typedef unsigned short  __kernel_uid16_t;
+typedef unsigned short  __kernel_gid16_t;
+typedef unsigned int    __kernel_uid32_t;
+typedef unsigned int    __kernel_gid32_t;
+
+typedef unsigned short  __kernel_old_uid_t;
+typedef unsigned short  __kernel_old_gid_t;
+typedef unsigned short  __kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long       __kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__USE_ALL)
+    int     val[2];
+#else
+    int     __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ASM_AVR32_POSIX_TYPES_H */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/machine-gmon.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/machine-gmon.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,69 @@
+/* Machine-dependent definitions for profiling support.  AVR32 version.
+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define mcount_internal __mcount_internal
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+static void __attribute((used)) mcount_internal(unsigned long frompc, unsigned long selfpc)
+
+/*
+ * This mcount implementation expects to get called after the prologue
+ * has been run. It also expects that r7 contains a valid frame
+ * pointer.
+ *
+ * When profiling, the compiler should generate something like this at
+ * each function entry:
+ *
+ *	pushm	r0-r7,lr	// lr mandatory, others optional
+ *	mov	r7, sp
+ *	// rest of prologue goes here
+ *	mcall	pc[.LC1 - .]
+ *      // rest of function goes here
+ * .LC1:
+ *	.long	mcount
+ *
+ * or for PIC:
+ *
+ *	pushm	r0-r7,lr
+ *	mov	r7, sp
+ *	// rest of prologue goes here
+ *	lddpc	r0, .LC1
+ * .L1: rsub	r0, pc
+ *	mcall	r0[mcount@GOT]
+ *	// rest of function goes here
+ * .LC1:
+ *	.long	.L1 - _GLOBAL_OFFSET_TABLE_
+ *
+ * This way, when mcount() is called, r7 points to the calling
+ * function's return address. It is guaranteed that calling mcount
+ * will clobber no registers except LR, which is unavoidable.
+ */
+#define MCOUNT asm(				\
+	"	.align	4\n"			\
+	"	.global	_mcount\n"		\
+	"	.type	_mcount,@function\n"	\
+	"_mcount:\n"				\
+	"	pushm	r8-r12,lr\n"		\
+	"	mov	r11, lr\n"		\
+	"	ld.w	r12, r7[0]\n"		\
+	"	rcall	__mcount_internal\n"	\
+	"	popm	r8-r12,pc\n"		\
+	"	.size	_mcount, . - _mcount\n"	\
+	"	.weak	mcount\n"		\
+	"	mcount = _mcount");
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/mman.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/mman.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,95 @@
+/* Definitions for POSIX memory map interface.  Linux/AVR32 version.
+   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+# define MAP_NONBLOCK	0x10000		/* do not block on IO */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
+
+/* Advise to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/profil-counter.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/profil-counter.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,26 @@
+/* Low-level statistical profiling support function.  Linux/AVR32 version.
+   Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <signal.h>
+
+void
+profil_counter(int signo, siginfo_t *si, struct sigcontext *sc)
+{
+	profil_count((void *)sc->pc);
+}
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/setjmp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/setjmp.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2004-2005 Atmel Norway
+ */
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+/*
+ * The jump buffer contains r0-r7, sr, sp and lr. Other registers are
+ * not saved.
+ */
+typedef int __jmp_buf[11];
+#endif
+
+#define __JMP_BUF_SP	4
+
+/* Test if longjmp to JMPBUF would unwind the frame containing a local
+   variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *)(address) < (void *)(jmpbuf[__JMP_BUF_SP]))
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/syscalls.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/syscalls.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,143 @@
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/*
+ * This includes the `__NR_<name>' syscall numbers taken from the
+ * Linux kernel header files. It also defines the traditional
+ * `SYS_<name>' macros for older programs.
+ */
+#include <bits/sysnum.h>
+
+#ifndef __set_errno
+# define __set_errno(val) (*__errno_location()) = (val)
+#endif
+#ifndef SYS_ify
+# define SYS_ify(syscall_name) (__NR_##syscall_name)
+#endif
+
+#ifndef __ASSEMBLER__
+
+#undef _syscall0
+#define _syscall0(type,name)				\
+	type name(void)					\
+	{						\
+		return (type)(INLINE_SYSCALL(name, 0));	\
+	}
+
+#undef _syscall1
+#define _syscall1(type,name,type1,arg1)				\
+	type name(type1 arg1)					\
+	{							\
+		return (type)(INLINE_SYSCALL(name, 1, arg1));	\
+	}
+
+#undef _syscall2
+#define _syscall2(type,name,type1,arg1,type2,arg2)			\
+	type name(type1 arg1, type2 arg2)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 2, arg1, arg2));	\
+	}
+
+#undef _syscall3
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+	type name(type1 arg1, type2 arg2, type3 arg3)			\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 3, arg1,		\
+					     arg2, arg3));		\
+	}
+
+#undef _syscall4
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4)						\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)	\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 4, arg1, arg2,	\
+					     arg3, arg4));		\
+	}
+
+#undef _syscall5
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5)				\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5)						\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 5, arg1, arg2,	\
+					     arg3, arg4, arg5));	\
+	}
+
+#undef _syscall6
+#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5,type6,arg6)			\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5, type6 arg6)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 6, arg1, arg2, arg3,	\
+					     arg4, arg5, arg6));	\
+	}
+
+#undef unlikely
+#define unlikely(x) __builtin_expect((x), 0)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+	({								\
+		unsigned _sys_result = INTERNAL_SYSCALL(name, , nr, args); \
+		if (unlikely(INTERNAL_SYSCALL_ERROR_P(_sys_result, ))) { \
+			__set_errno(INTERNAL_SYSCALL_ERRNO(_sys_result, )); \
+			_sys_result = (unsigned int) -1;		\
+		}							\
+		(int) _sys_result;					\
+	})
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while(0)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)			\
+	({								\
+		register int _a1 asm ("r12");				\
+		register int _scno asm("r8") = SYS_ify(name);		\
+		LOAD_ARGS_##nr (args);					\
+		asm volatile ("scall	/* syscall " #name " */"	\
+			      : "=r" (_a1)				\
+			      : "r"(_scno) ASM_ARGS_##nr		\
+			      : "lr", "cc", "memory");			\
+		_a1;							\
+	})
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
+	((unsigned int)(val) >= 0xfffff001U)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, errr) (-(val))
+
+#define LOAD_ARGS_0() do { } while(0)
+#define ASM_ARGS_0
+#define LOAD_ARGS_1(a1)					\
+	_a1 = (int) (a1);				\
+	LOAD_ARGS_0()
+#define ASM_ARGS_1	ASM_ARGS_0, "r"(_a1)
+#define LOAD_ARGS_2(a1, a2)				\
+	register int _a2 asm("r11") = (int)(a2);	\
+	LOAD_ARGS_1(a1)
+#define ASM_ARGS_2	ASM_ARGS_1, "r"(_a2)
+#define LOAD_ARGS_3(a1, a2, a3)				\
+	register int _a3 asm("r10") = (int)(a3);	\
+	LOAD_ARGS_2(a1, a2)
+#define ASM_ARGS_3	ASM_ARGS_2, "r"(_a3)
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+	register int _a4 asm("r9") = (int)(a4);		\
+	LOAD_ARGS_3(a1, a2, a3)
+#define ASM_ARGS_4	ASM_ARGS_3, "r"(_a4)
+#define LOAD_ARGS_5(a1, a2, a3, a4, a5)			\
+	register int _a5 asm("r5") = (int)(a5);		\
+	LOAD_ARGS_4(a1, a2, a3, a4)
+#define ASM_ARGS_5	ASM_ARGS_4, "r"(_a5)
+#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
+	register int _a6 asm("r3") = (int)(a6);		\
+	LOAD_ARGS_5(a1, a2, a3, a4, a5)
+#define ASM_ARGS_6	ASM_ARGS_5, "r"(_a6)
+
+#endif /* __ASSEMBLER__ */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/wordsize.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bits/wordsize.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1 @@
+#define __WORDSIZE	32
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/brk.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/brk.c	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <sys/syscall.h>
+
+void *__curbrk = 0;
+
+int brk (void *addr)
+{
+	void *newbrk;
+
+	newbrk = INLINE_SYSCALL(brk, 1, addr);
+
+	__curbrk = newbrk;
+
+	if (newbrk < addr) {
+		__set_errno (ENOMEM);
+		return -1;
+	}
+
+	return 0;
+}
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bsd-_setjmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bsd-_setjmp.S	2006-05-05 09:26:42.000000000 +0200
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 0) */
+	.global	_setjmp
+	.type	_setjmp,"function"
+	.align	1
+_setjmp:
+	mov	r11, 0
+	bral	__sigsetjmp_internal
+	.size	_setjmp, . - _setjmp
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/bsd-setjmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/bsd-setjmp.S	2006-05-05 09:26:42.000000000 +0200
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 1) */
+	.global	setjmp
+	.type	setjmp,"function"
+	.align	1
+setjmp:
+	mov	r11, 1
+	bral	__sigsetjmp_internal
+	.size	setjmp, . - setjmp
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/clone.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/clone.c	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+/*
+ * I don't know if we can be absolutely certain that the fn and arg
+ * parameters are preserved when returning as the child. If the
+ * compiler stores them in registers (r0-r7), they should be.
+ */
+int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+{
+	register int (*_fn)(void *arg) = fn;
+	register void *_arg = arg;
+	int err;
+
+	/* Sanity check the arguments */
+	err = -EINVAL;
+	if (!fn)
+		goto syscall_error;
+	if (!child_stack)
+		goto syscall_error;
+
+	err = INLINE_SYSCALL(clone, 2, flags, child_stack);
+	if (err < 0)
+		goto syscall_error;
+	else if (err != 0)
+		return err;
+
+	_exit(_fn(_arg));
+
+syscall_error:
+	__set_errno (-err);
+	return -1;
+}
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/crt1.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/crt1.S	2006-05-05 09:28:23.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ *
+ * When we enter _start, the stack looks like this:
+ *	argc		argument counter
+ *	argv[0]		pointer to program name
+ *	argv[1..argc-1]	pointers to program args
+ *	NULL
+ *	env[0..N]	pointers to environment variables
+ *	NULL
+ *
+ * r12 contains a function pointer to be registered with `atexit'.
+ * This is how the dynamic linker arranges to have DT_FINI functions
+ * called for shared libraries that have been loaded before this
+ * code runs.
+ *
+ * We're going to call the following function:
+ * __uClibc_main(int (*main)(int, char **, char **), int argc,
+ *		 char **argv, void (*app_init)(void), void (*app_fini)(void),
+ *		 void (*rtld_fini)(void), void *stack_end)
+ *
+ * So we need to set up things as follows:
+ *	r12 = address of main
+ *	r11 = argc
+ *	r10 = &argv[0]
+ *	r9  = address of _init
+ *	r8  = address of _fini
+ *	sp[0] = whatever we got passed in r12
+ */
+
+#include <features.h>
+
+	.text
+	.global _start
+	.type	_start, @function
+_start:
+	/* Clear the frame pointer and link register since this is the outermost frame.  */
+	mov	r7, 0
+	mov	lr, 0
+
+	ld.w	r11, sp++		/* argc		*/
+	mov	r10, sp			/* &argv[0]	*/
+
+	st.w	--sp, r10		/* stack_end */
+	st.w	--sp, r12		/* rtld_fini */
+
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+.L_RGOT:
+	rsub	r6, pc
+	lda.w	r9, _init
+	lda.w	r8, _fini
+	lda.w	r12, main
+
+	/* Ok, now run uClibc's main() -- should not return */
+	call	__uClibc_main
+
+	.align	2
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+	lddpc	r9, __init_addr		/* app_init */
+	lddpc	r8, __fini_addr		/* app_fini */
+	lddpc	r12, __main_addr	/* main */
+
+	/* Ok, now run uClibc's main() -- should not return */
+	lddpc	pc, ___uClibc_main_addr
+
+	.align	2
+__init_addr:
+	.long	_init
+__fini_addr:
+	.long	_fini
+__main_addr:
+	.long	main
+___uClibc_main_addr:
+	.long	__uClibc_main
+#endif
+	.size	_start, . - _start
+
+	/*
+	 * The LSB says we need this.
+	 */
+	.section ".note.ABI-tag", "a"
+	.align	4
+	.long	2f - 1f		/* namesz */
+	.long	4f - 3f		/* descsz */
+	.long	1		/* type   */
+1:	.asciz	"GNU"		/* name */
+2:	.align	4
+3:	.long	0		/* Linux executable */
+	.long	2,6,0		/* Earliest compatible kernel */
+4:	.align	4
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/crti.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/crti.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,17 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+_init:
+	/* Use a four-byte instruction to avoid NOPs */
+	stm	--sp, r0-r7,lr
+	.align	2
+
+	.section .fini
+	.align	2
+	.global	_fini
+	.type	_fini, @function
+_fini:
+	stm	--sp, r0-r7,lr
+	.align	2
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/crtn.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/crtn.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,14 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+	ldm	sp++, r0-r7,pc
+	.size	_init, . - _init
+
+	.section .fini
+	.align	2
+	.global _fini
+	.type	_fini, @function
+	ldm	sp++, r0-r7,pc
+	.size	_fini, . - _fini
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/mmap.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/mmap.c	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2005 Atmel Norway
+
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Library General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+   details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+   Derived in part from the Linux-8086 C library, the GNU C Library, and several
+   other sundry sources.  Files within this library are copyright by their
+   respective copyright holders.
+ */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot, int, flags, int, fd, __off_t, pgoff);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+	return mmap2(addr, len, prot, flags, fd, offset >> 12);
+}
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/setjmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/setjmp.S	2006-05-05 09:28:28.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+	.text
+
+	.global	__sigsetjmp
+	.type	__sigsetjmp,"function"
+
+	/* Create a global, hidden symbol for use by setjmp() and _setjmp().
+	   If it's not hidden, the linker will complain about a relative
+	   jump to a dynamic symbol when building a shared library.
+
+	   Also, if a user overrides the __sigsetjmp function, he might not
+	   expect the setjmp() and _setjmp() function to effectively be
+	   overridden as well.  */
+	.global	__sigsetjmp_internal
+	.hidden	__sigsetjmp_internal
+	.type	__sigsetjmp_internal,"function"
+	.align	1
+__sigsetjmp:
+__sigsetjmp_internal:
+	mustr	r8
+	stm	r12, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
+
+	/* Make a tail call to __sigjmp_save; it takes the same args.  */
+#ifdef __PIC__
+	mov	r9, r6
+	lddpc	r6, .LG
+.L1:	rsub	r6, pc
+	ld.w	r8, r6[__sigjmp_save@got]
+	mov	r6, r9
+	mov	pc, r8
+
+	.align	2
+.LG:	.long	.L1 - _GLOBAL_OFFSET_TABLE_
+#else
+	rjmp	__sigjmp_save
+#endif
+	.size	__sigsetjmp, . - __sigsetjmp
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sigaction.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sigaction.c	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/kernel_sigaction.h>
+
+#define SA_RESTORER	0x04000000
+extern void __default_rt_sa_restorer(void);
+
+/*
+ * If act is not NULL, change the action for sig to *act.
+ * If oact is not NULL, put the old action for sig in *oact.
+ */
+int __libc_sigaction(int signum, const struct sigaction *act,
+		     struct sigaction *oldact)
+{
+	struct kernel_sigaction kact, koact;
+	int result;
+
+	if (act) {
+		kact.k_sa_handler = act->sa_handler;
+		memcpy(&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
+		kact.sa_flags = act->sa_flags;
+		if (kact.sa_flags & (SA_RESTORER | SA_ONSTACK))
+			kact.sa_restorer = act->sa_restorer;
+		else
+			kact.sa_restorer = __default_rt_sa_restorer;
+		kact.sa_flags |= SA_RESTORER;
+	}
+
+	result = __syscall_rt_sigaction(signum, act ? __ptrvalue(&kact) : NULL,
+					oldact ? __ptrvalue(&koact) : NULL,
+					_NSIG / 8);
+
+	if (oldact && result >= 0) {
+		oldact->sa_handler = koact.k_sa_handler;
+		memcpy(&oldact->sa_mask, &koact.sa_mask,
+		       sizeof(oldact->sa_mask));
+		oldact->sa_flags = koact.sa_flags;
+		oldact->sa_restorer = koact.sa_restorer;
+	}
+
+	return result;
+}
+
+weak_alias(__libc_sigaction, sigaction)
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sigrestorer.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sigrestorer.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2004 Atmel Norway AS
+ */
+#include <sys/syscall.h>
+
+	.global	__default_rt_sa_restorer
+	.type	__default_rt_sa_restorer,"function"
+	.align	1
+__default_rt_sa_restorer:
+	mov	r8, __NR_rt_sigreturn
+	scall
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/elf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/elf.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,26 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ELF_H
+#define _SYS_ELF_H	1
+
+#warning "This header is obsolete; use <sys/procfs.h> instead."
+
+#include <sys/procfs.h>
+
+#endif	/* sys/elf.h */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/io.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/io.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,48 @@
+/* Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+
+#define	_SYS_IO_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL is nonzero,
+   permission to access any I/O port is granted.  This call requires
+   root privileges. */
+extern int iopl (int __level) __THROW;
+
+/* The functions that actually perform reads and writes.  */
+extern unsigned char inb (unsigned long int port) __THROW;
+extern unsigned short int inw (unsigned long int port) __THROW;
+extern unsigned long int inl (unsigned long int port) __THROW;
+
+extern void outb (unsigned char value, unsigned long int port) __THROW;
+extern void outw (unsigned short value, unsigned long int port) __THROW;
+extern void outl (unsigned long value, unsigned long int port) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_IO_H */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/procfs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/procfs.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,123 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   user_regs' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+#define ELF_NGREG (sizeof (struct user_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+typedef struct user_fpregs elf_fpregset_t;
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/ucontext.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/ucontext.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,94 @@
+/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Linux/AVR32 ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	16
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15
+#define R15	R15
+};
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    fpregset_t fpregs;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+{
+    unsigned long     uc_flags;
+    struct ucontext  *uc_link;
+    stack_t           uc_stack;
+    struct sigcontext uc_mcontext;
+    sigset_t          uc_sigmask;   /* mask last for extensibility */
+} ucontext_t;
+
+#endif /* sys/ucontext.h */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/user.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/sys/user.h	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,46 @@
+#ifndef _SYS_USER_H
+#define _SYS_USER_H
+
+struct user_fpregs
+{
+
+};
+
+struct user_regs
+{
+	unsigned long sr;
+	unsigned long pc;
+	unsigned long lr;
+	unsigned long sp;
+	unsigned long r12;
+	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long r7;
+	unsigned long r6;
+	unsigned long r5;
+	unsigned long r4;
+	unsigned long r3;
+	unsigned long r2;
+	unsigned long r1;
+	unsigned long r0;
+	unsigned long r12_orig;
+};
+
+struct user
+{
+	struct user_regs	regs;		/* general registers */
+	size_t			u_tsize;	/* text size (pages) */
+	size_t			u_dsize;	/* data size (pages) */
+	size_t			u_ssize;	/* stack size (pages) */
+	unsigned long		start_code;	/* text starting address */
+	unsigned long		start_data;	/* data starting address */
+	unsigned long		start_stack;	/* stack starting address */
+	long int		signal;		/* signal causing core dump */
+	struct user_regs *	u_ar0;		/* help gdb find registers */
+	unsigned long		magic;		/* identifies a core file */
+	char			u_comm[32];	/* user command name */
+};
+
+#endif /* _SYS_USER_H */
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/syscall.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/syscall.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,81 @@
+/*
+ * syscall for AVR32/uClibc
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <features.h>
+
+	.text
+
+	/*
+	 * long int syscall(long int sysno, ...)
+	 */
+	.global	syscall
+	.type	syscall, @function
+	.align	2
+syscall:
+	stm	--sp, r3,r5,lr
+	sub	lr, sp, -12
+	mov	r8, r12
+	ldm	lr, r3,r5,r9-r12
+	scall
+	cp.w	r12, -4095
+	brlo	.Ldone
+
+#ifdef __PIC__
+	lddpc	r5, .Lgot
+.Lgotcalc:
+	rsub	r5, pc
+# ifdef __UCLIBC_HAS_THREADS__
+	mov	r3, r12
+	mcall	r5[__errno_location@got]
+	st.w	r12[0], r3
+# else
+	ld.w	r3, r5[errno@got]
+	st.w	r3[0], r12
+# endif
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+	mov	r3, r12
+	mcall	.Lerrno_location
+	st.w	r12[0], r3
+# else
+	lddpc	r3, .Lerrno
+	st.w	r3[0], r12
+# endif
+#endif
+	mov	r12, -1
+
+.Ldone:
+	ldm	sp++, r3,r5,pc
+
+	.align	2
+#ifdef __PIC__
+.Lgot:
+	.long	.Lgotcalc - _GLOBAL_OFFSET_TABLE_
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+.Lerrno_location:
+	.long	__errno_location
+# else
+.Lerrno:
+	.long	errno
+# endif
+#endif
+
+
+	.size	syscall, . - syscall
Index: uClibc-0.9.28/libc/sysdeps/linux/avr32/vfork.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libc/sysdeps/linux/avr32/vfork.S	2006-04-19 12:48:33.000000000 +0200
@@ -0,0 +1,55 @@
+	/*
+	 * vfork for uClibc
+	 *
+	 * Copyright (C) 2005 Atmel Norway
+	 */
+
+	/*
+	 * Clone the process without copying the address space.  The
+	 * calling process is suspended until the child either exits
+	 * or calls execve.
+	 *
+	 * This all means that we cannot rely on the stack to store
+	 * away registers, since they will be overwritten by the child
+	 * as soon as it makes another function call (e.g. execve()).
+	 * Fortunately, the Linux kernel preserves LR across system calls.
+	 */
+#include <features.h>
+#include <sys/syscall.h>
+
+	.global	__vfork
+	.type	__vfork,@function
+	.align	1
+__vfork:
+	mov	r8, __NR_vfork
+	scall
+	cp.w	r12, -4096
+	retls	r12
+
+	/* vfork failed, so we may use the stack freely */
+	pushm	r4-r7,lr
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+	rsub	r4, r12, 0
+.L_RGOT:
+	rsub	r6, pc
+	mcall	r6[__errno_location@got]
+#else
+	rsub	r4, r12, 0
+	mcall	.L__errno_location
+#endif
+	st.w	r12[0], r4
+	popm	r4-r7,pc,r12=-1
+
+	.align	2
+#ifdef __PIC__
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+.L__errno_location:
+	.long	__errno_location
+#endif
+	.size	__vfork, . - __vfork
+
+	.weak	vfork
+	vfork	= __vfork
Index: uClibc-0.9.28/Rules.mak
===================================================================
--- uClibc-0.9.28.orig/Rules.mak	2006-05-05 09:26:01.000000000 +0200
+++ uClibc-0.9.28/Rules.mak	2006-05-05 09:27:17.000000000 +0200
@@ -231,6 +231,10 @@ ifeq ($(strip $(TARGET_ARCH)),frv)
 	UCLIBC_LDSO=ld.so.1
 endif
 
+ifeq ($(strip $(TARGET_ARCH)),avr32)
+	CPU_CFLAGS-$(CONFIG_AP7000)	+= -mcpu=ap7000
+endif
+
 # Keep the check_gcc from being needlessly executed
 ifndef PIEFLAG
 ifneq ($(UCLIBC_BUILD_PIE),y)
From nobody Mon Sep 17 00:00:00 2001
Subject: [PATCH] Make linkrelax configurable
From: HÃ¥vard Skinnemoen <hskinnemoen@atmel.com>
Date: 1133951618 +0100

Add a linkrelax option to the configure system which will give
appropriate options to the compiler, assembler and linker to enable
link-time optimizations.

---

 Rules.mak                  |    2 ++
 extra/Configs/Config.avr32 |    4 ++++
 2 files changed, 6 insertions(+)

Index: uClibc-0.9.28/Rules.mak
===================================================================
--- uClibc-0.9.28.orig/Rules.mak	2006-02-08 17:58:53.000000000 +0100
+++ uClibc-0.9.28/Rules.mak	2006-02-08 17:59:07.000000000 +0100
@@ -233,6 +233,8 @@ endif
 
 ifeq ($(strip $(TARGET_ARCH)),avr32)
 	CPU_CFLAGS-$(CONFIG_AP7000)	+= -mcpu=ap7000
+	CPU_CFLAGS-$(LINKRELAX)		+= -masm-addr-pseudos -Wa,--pic,--linkrelax
+	CPU_LDFLAGS-$(LINKRELAX)	+= --relax
 endif
 
 # Keep the check_gcc from being needlessly executed
Index: uClibc-0.9.28/extra/Configs/Config.avr32
===================================================================
--- uClibc-0.9.28.orig/extra/Configs/Config.avr32	2006-02-08 17:58:53.000000000 +0100
+++ uClibc-0.9.28/extra/Configs/Config.avr32	2006-02-08 17:59:07.000000000 +0100
@@ -36,3 +36,7 @@ config CONFIG_AP7000
 	bool "AP7000"
 
 endchoice
+
+config LINKRELAX
+	bool "Enable linker optimizations"
+	default n
Subject: [PATCH] AVR32-optimized string operations

Add hand-optimized AVR32-specific string operations. Some of them
need a bit more testing, though.

---

 libc/string/avr32/Makefile      |   40 +++++++++++
 libc/string/avr32/bcopy.S       |   15 ++++
 libc/string/avr32/bzero.S       |   12 +++
 libc/string/avr32/memchr.S      |   62 +++++++++++++++++
 libc/string/avr32/memcmp.S      |   50 +++++++++++++
 libc/string/avr32/memcpy.S      |  110 ++++++++++++++++++++++++++++++
 libc/string/avr32/memmove.S     |  114 +++++++++++++++++++++++++++++++
 libc/string/avr32/memset.S      |   60 ++++++++++++++++
 libc/string/avr32/strcat.S      |   95 ++++++++++++++++++++++++++
 libc/string/avr32/strcmp.S      |   80 ++++++++++++++++++++++
 libc/string/avr32/strcpy.S      |   63 +++++++++++++++++
 libc/string/avr32/stringtest.c  |  144 ++++++++++++++++++++++++++++++++++++++++
 libc/string/avr32/strlen.S      |   52 ++++++++++++++
 libc/string/avr32/strncpy.S     |   77 +++++++++++++++++++++
 libc/string/avr32/test_memcpy.c |   66 ++++++++++++++++++
 15 files changed, 1040 insertions(+)

Index: uClibc-0.9.28-avr32/libc/string/avr32/bcopy.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/bcopy.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+	.text
+	.global bcopy
+	.type	bcopy, @function
+	.align	1
+bcopy:
+	/* Swap the first two arguments */
+	eor	r11, r12
+	eor	r12, r11
+	eor	r11, r12
+	rjmp	__memmove
+	.size	bcopy, . - bcopy
Index: uClibc-0.9.28-avr32/libc/string/avr32/bzero.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/bzero.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+	.text
+	.global bzero
+	.type	bzero, @function
+	.align	1
+bzero:
+	mov	r10, r11
+	mov	r11, 0
+	rjmp	__memset
Index: uClibc-0.9.28-avr32/libc/string/avr32/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/Makefile	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,40 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../
+include $(TOPDIR)Rules.mak
+
+SSRC	:= bcopy.S bzero.S memcmp.S memcpy.S memmove.S
+SSRC	+= memset.S strcmp.S strlen.S
+# memchr.S, strcat.S, strcpy.S, strncpy.S is broken
+SOBJS	:= $(patsubst %.S,%.o, $(SSRC))
+OBJS	:= $(SOBJS)
+
+OBJ_LIST:= ../../obj.string.$(TARGET_ARCH)
+
+all: $(OBJ_LIST)
+
+$(OBJ_LIST): $(OBJS)
+	echo $(addprefix string/$(TARGET_ARCH)/, $(OBJS)) > $@
+
+$(SOBJS): %.o: %.S
+	$(CC) $(ASFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $@
+
+clean:
+	$(RM) *.[oa] *~ core
Index: uClibc-0.9.28-avr32/libc/string/avr32/memchr.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/memchr.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define str r12
+#define chr r11
+#define len r10
+
+	.text
+	.global memchr
+	.type	memchr, @function
+memchr:
+	or	chr, chr, chr << 8
+	or	chr, chr, chr << 16
+
+	mov	r9, str
+	andl	r9, 3, COH
+	brne	.Lunaligned_str
+
+1:	sub	len, 4
+	brlt	2f
+	ld.w	r8, str++
+	psub.b	r9, r8, r11
+	tnbz	r9
+	brne	1b
+
+	sub	str, 4
+	bfextu	r9, r8, 24, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	bfextu	r9, r8, 16, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	bfextu	r9, r8, 8, 8
+	cp.b	r9, r11
+	reteq	str
+	sub	str, -1
+	retal	str
+
+2:	sub	len, -4
+	reteq	0
+
+3:	ld.ub	r8, str++
+	cp.w	r8, 0
+	reteq	str
+	sub	len, 1
+	brne	3b
+
+	retal	0
+
+.Lunaligned_str:
+1:	sub	len, 1
+	retlt	0
+	ld.ub	r8, str++
+	cp.b	r8, r11
+	reteq	str
+	sub	r9, 1
+	brge	1b
+
+	rjmp	.Laligned_search
Index: uClibc-0.9.28-avr32/libc/string/avr32/memcmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/memcmp.S	2006-10-20 10:42:09.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global memcmp
+	.type	memcmp, @function
+	.align	1
+memcmp:
+	sub	len, 4
+	brlt	.Lless_than_4
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	.Lfound_word
+	sub	len, 4
+	brge	1b
+
+.Lless_than_4:
+	sub	len, -4
+	reteq	0
+
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	sub	len, 1
+	brgt	1b
+
+	retal	0
+
+.Lfound_word:
+	psub.b	r9, r8, r9
+	bfextu	r8, r9, 24, 8
+	retne	r8
+	bfextu	r8, r9, 16, 8
+	retne	r8
+	bfextu	r8, r9, 8, 8
+	retne	r8
+	retal	r9
+
+	.size	memcmp, . - memcmp
+
+	.weak	bcmp
+	bcmp = memcmp
Index: uClibc-0.9.28-avr32/libc/string/avr32/memcpy.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/memcpy.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+/* Don't use r12 as dst since we must return it unmodified */
+#define dst r9
+#define src r11
+#define len r10
+
+	.text
+	.global	memcpy
+	.type	memcpy, @function
+
+	.global	__memcpy
+	.hidden	__memcpy
+	.type	__memcpy, @function
+memcpy:
+__memcpy:
+	pref	src[0]
+	mov	dst, r12
+
+	/* If we have less than 32 bytes, don't do anything fancy */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, src++
+	st.b	dst++, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, dst
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	ldm	src, r0-r7
+	sub	src, -32
+	stm	dst, r0-r7
+	sub	dst, -32
+	sub	len, 32
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	ldm	src, r0-r3
+	sub	src, -16
+	sub	len, 16
+	stm	dst, r0-r3
+	sub	dst, -16
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	neg	len
+	add	pc, pc, len << 2
+	.rept	15
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	rsub	r8, r8, 32
+	sub	len, r8
+1:	ld.ub	r0, src++
+	st.b	dst++, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[0]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, src++
+	st.w	dst++, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+	.size	memcpy, . - memcpy
Index: uClibc-0.9.28-avr32/libc/string/avr32/memmove.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/memmove.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define dst r12
+#define src r11
+#define len r10
+
+	.text
+	.global memmove
+	.type	memmove, @function
+
+	.global	__memmove
+	.hidden	__memmove
+	.type	__memmove, @function
+memmove:
+__memmove:
+	cp.w	src, dst
+	brge	__memcpy
+
+	add	dst, len
+	add	src, len
+	pref	src[-1]
+
+	/*
+	 * The rest is basically the same as in memcpy.S except that
+	 * the direction is reversed.
+	 */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, --src
+	st.b	--dst, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, r12
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	sub	src, 32
+	ldm	src, r0-r7
+	sub	dst, 32
+	sub	len, 32
+	stm	dst, r0-r7
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	sub	src, 16
+	ldm	src, r0-r3
+	sub	dst, 16
+	sub	len, 16
+	stm	dst, r0-r3
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	sub	len, -16
+	breq	2f
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	len, 1
+	brne	1b
+
+2:	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	sub	len, r8
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[-4]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, --src
+	st.w	--dst, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, --src
+	st.b	--dst, r0
+	.endr
+
+	popm	r0-r7, pc
Index: uClibc-0.9.28-avr32/libc/string/avr32/memset.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/memset.S	2006-10-20 10:42:15.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s r12
+#define c r11
+#define n r10
+
+	.text
+	.global memset
+	.type	memset, @function
+
+	.global	__memset
+	.hidden	__memset
+	.type	__memset, @function
+
+	.align	1
+memset:
+__memset:
+	cp.w	n, 32
+	mov	r9, s
+	brge	.Llarge_memset
+
+	sub	n, 1
+	retlt	s
+1:	st.b	s++, c
+	sub	n, 1
+	brge	1b
+
+	retal	r9
+
+.Llarge_memset:
+	mov	r8, r11
+	mov	r11, 3
+	bfins	r8, r8, 8, 8
+	bfins	r8, r8, 16, 16
+	tst	s, r11
+	breq	2f
+
+1:	st.b	s++, r8
+	sub	n, 1
+	tst	s, r11
+	brne	1b
+
+2:	mov	r11, r9
+	mov	r9, r8
+	sub	n, 8
+
+3:	st.d	s++, r8
+	sub	n, 8
+	brge	3b
+
+	/* If we are done, n == -8 and we'll skip all st.b insns below */
+	neg	n
+	lsl	n, 1
+	add	pc, n
+	.rept	7
+	st.b	s++, r8
+	.endr
+	retal	r11
Index: uClibc-0.9.28-avr32/libc/string/avr32/strcat.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/strcat.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define s1 r9
+#define s2 r11
+
+	.text
+	.global strcat
+	.type	strcat, @function
+	.align	1
+strcat:
+	mov	s1, r12
+
+	/* Make sure s1 is word-aligned */
+	mov	r10, s1
+	andl	r10, 3, COH
+	breq	2f
+
+	add	pc, pc, r10 << 3
+	sub	r0, r0, 0	/* 4-byte nop */
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	2f
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	3f
+	ld.ub	r8, s1++
+	sub	r8, r8, 0
+	breq	4f
+
+	/* Find the end of the first string */
+5:	ld.w	r8, s1++
+	tnbz	r8
+	brne	5b
+
+	sub	s1, 4
+
+	bfextu	r10, r8, 24, 8
+	cp.w	r10, 0
+	breq	1f
+	sub	s1, -1
+	bfextu	r10, r8, 16, 8
+	cp.w	r10, 0
+	breq	2f
+	sub	s1, -1
+	bfextu	r10, r8, 8, 8
+	cp.w	r10, 0
+	breq	3f
+	sub	s1, -1
+	rjmp	4f
+
+	/* Now, append s2 */
+1:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+2:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+3:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+4:	ld.ub	r8, s2++
+	st.b	s1++, r8
+	cp.w	r8, 0
+	reteq	r12
+
+	/* Copy one word at a time */
+	ld.w	r8, s2++
+	tnbz	r8
+	breq	2f
+1:	st.w	r8, s2++
+	ld.w	r8, s2++
+	tnbz	r8
+	brne	1b
+
+	/* Copy the remaining bytes */
+	bfextu	r10, r8, 24, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 16, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 8, 8
+	st.b	s1++, r10
+	cp.w	r10, 0
+	reteq	r12
+	st.b	s1++, r8
+	retal	r12
+	.size	strcat, . - strcat
Index: uClibc-0.9.28-avr32/libc/string/avr32/strcmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/strcmp.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2004 Atmel Norway.
+ */
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global strcmp
+	.type	strcmp, @function
+	.align	1
+strcmp:
+	mov	r8, 3
+	tst	s1, r8
+	brne	.Lunaligned_s1
+	tst	s2, r8
+	brne	.Lunaligned_s2
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	2f
+	tnbz	r8
+	brne	1b
+	retal	0
+
+2:	bfextu	r12, r8, 24, 8
+	bfextu	r11, r9, 24, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 16, 8
+	bfextu	r11, r9, 16, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 8, 8
+	bfextu	r11, r9, 8, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 0, 8
+	bfextu	r11, r9, 0, 8
+	sub	r12, r11
+	retal	r12
+
+.Lunaligned_s1:
+3:	tst	s1, r8
+	breq	4f
+	ld.ub	r10, s1++
+	ld.ub	r9, s2++
+	sub	r10, r9
+	retne	r10
+	cp.w	r9, 0
+	brne	3b
+	retal	r10
+
+4:	tst	s2, r8
+	breq	1b
+
+.Lunaligned_s2:
+	/*
+	 * s1 and s2 can't both be aligned, and unaligned word loads
+	 * can trigger spurious exceptions if we cross a page boundary.
+	 * Do it the slow way...
+	 */
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	cp.w	r9, 0
+	brne	1b
+	retal	0
+
+	.weak	strcoll
+	strcoll	= strcmp
Index: uClibc-0.9.28-avr32/libc/string/avr32/strcpy.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/strcpy.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * To reduce the size, this one might simply call strncpy with len = -1.
+ */
+
+#define dst r9
+#define src r11
+
+	.text
+	.global strcpy
+	.type	strcpy, @function
+strcpy:
+	mov	dst, r12
+
+	pref	src[0]
+
+	/*
+	 * Check alignment. If src is aligned but dst isn't, we can't
+	 * do much about it...
+	 */
+	mov	r8, src
+	andl	r8, 3 COH
+	brne	.Lunaligned_src
+
+.Laligned_copy:
+1:	ld.w	r8, src++
+	tnbz	r8
+	breq	2f
+	st.w	dst++, r8
+	rjmp	1b
+
+2:	/*
+	 * Ok, r8 now contains the terminating '\0'. Copy the
+	 * remaining bytes individually.
+	 */
+	bfextu	r10, r8, 24, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 16, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	bfextu	r10, r8, 8, 8
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+	st.b	dst++, r8
+	retal	r12
+
+.Lunaligned_src:
+	/* Copy bytes until we're aligned */
+	rsub	r8, r8, 4
+	add	pc, pc, r8 << 3
+	nop
+	nop
+	ld.ub	r10, src++
+	st.b	dst++, r10
+	cp.w	r10, 0
+	reteq	r12
+
+	rjmp	.Laligned_copy
Index: uClibc-0.9.28-avr32/libc/string/avr32/stringtest.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/stringtest.c	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,144 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <sys/mman.h>
+
+#define BUF_SIZE (8 * 1024)
+
+static char *buf1;
+static char *buf1_ref;
+static char *buf2;
+
+extern void *optimized_memcpy(void *dest, void *src, size_t len);
+extern void *optimized_memmove(void *dest, void *src, size_t len);
+extern char *optimized_strcpy(char *dest, char *src);
+extern char *optimized_strncpy(char *dest, char *src, size_t len);
+
+void dump_mismatch(char *buf, char *ref, size_t len)
+{
+	int i, j;
+
+	for (i = 0; i < len; i += 16) {
+		if (memcmp(buf + i, ref + i, 16) == 0)
+			continue;
+
+		printf("%4x buf:", i);
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", buf[j]);
+		printf("\n     ref:");
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", ref[j]);
+		printf("\n");
+	}
+}
+
+static void test_memcpy(int src_offset, int dst_offset, int len)
+{
+	clock_t start, old, new;
+	int i;
+
+	memset(buf1, 0x55, BUF_SIZE);
+	memset(buf1_ref, 0x55, BUF_SIZE);
+	memset(buf2, 0xaa, BUF_SIZE);
+
+	printf("Testing memcpy with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	start = clock();
+	for (i = 0; i < 8192; i++)
+		optimized_memcpy(buf1 + dst_offset, buf2 + src_offset, len);
+	new = clock() - start;
+	start = clock();
+	for ( i = 0; i < 8192; i++)
+		memcpy(buf1_ref + dst_offset, buf2 + src_offset, len);
+	old = clock() - start;
+
+	if (memcmp(buf1, buf1_ref, BUF_SIZE) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, BUF_SIZE);
+	}
+	printf("CPU time used: %d vs. %d\n", new, old);
+}
+
+static void test_memmove(int src_offset, int dst_offset, int len)
+{
+	clock_t start, old, new;
+
+	memset(buf1, 0x55, BUF_SIZE);
+	memset(buf1_ref, 0x55, BUF_SIZE);
+	memset(buf2, 0xaa, BUF_SIZE);
+
+	printf("Testing memmove with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	start = clock();
+	optimized_memmove(buf1 + dst_offset, buf2 + src_offset, len);
+	new = clock() - start;
+	start = clock();
+	memmove(buf1_ref + dst_offset, buf2 + src_offset, len);
+	old = clock() - start;
+
+	if (memcmp(buf1, buf1_ref, BUF_SIZE) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, BUF_SIZE);
+	}
+	printf("CPU time used: %d vs. %d\n", new, old);
+}
+
+int main(int argc, char *argv[])
+{
+	buf2 = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf2 == MAP_FAILED) {
+		perror("Failed to allocate memory for buf2");
+		return 1;
+	}
+	buf1 = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf1 == MAP_FAILED) {
+		perror("Failed to allocate memory for buf1");
+		return 1;
+	}
+	buf1_ref = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	if (buf1_ref == MAP_FAILED) {
+		perror("Failed to allocate memory for buf1_ref");
+		return 1;
+	}
+	printf("\n === MEMCPY ===\n\n");
+
+	test_memcpy(0, 0, BUF_SIZE - 32);
+	test_memcpy(0, 0, 1);
+	test_memcpy(0, 0, 31);
+	test_memcpy(0, 0, 32);
+	test_memcpy(0, 0, 127);
+	test_memcpy(0, 0, 128);
+	test_memcpy(4, 4, BUF_SIZE - 32 - 4);
+	test_memcpy(1, 1, BUF_SIZE - 32 - 1);
+	test_memcpy(1, 1, 126);
+	test_memcpy(0, 3, 128);
+	test_memcpy(1, 4, 128);
+	test_memcpy(0, 0, 0);
+
+	printf("\n === MEMMOVE ===\n\n");
+
+	test_memmove(0, 0, BUF_SIZE - 32);
+	test_memmove(0, 0, 1);
+	test_memmove(0, 0, 31);
+	test_memmove(0, 0, 32);
+	test_memmove(0, 0, BUF_SIZE - 33);
+	test_memmove(0, 0, 128);
+	test_memmove(4, 4, BUF_SIZE - 32 - 4);
+	test_memmove(1, 1, BUF_SIZE - 32 - 1);
+	test_memmove(1, 1, BUF_SIZE - 130);
+	test_memmove(0, 3, BUF_SIZE - 128);
+	test_memmove(1, 4, BUF_SIZE - 128);
+	test_memmove(0, 0, 0);
+
+	return 0;
+}
Index: uClibc-0.9.28-avr32/libc/string/avr32/strlen.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/strlen.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define str r12
+
+	.text
+	.global strlen
+	.type	strlen, @function
+strlen:
+	mov	r11, r12
+
+	mov	r9, str
+	andl	r9, 3, COH
+	brne	.Lunaligned_str
+
+1:	ld.w	r8, str++
+	tnbz	r8
+	brne	1b
+
+	sub	r12, r11
+	bfextu	r9, r8, 24, 8
+	cp.w	r9, 0
+	subeq	r12, 4
+	reteq	r12
+	bfextu	r9, r8, 16, 8
+	cp.w	r9, 0
+	subeq	r12, 3
+	reteq	r12
+	bfextu	r9, r8, 8, 8
+	cp.w	r9, 0
+	subeq	r12, 2
+	reteq	r12
+	sub	r12, 1
+	retal	r12
+
+.Lunaligned_str:
+	add	pc, pc, r9 << 3
+	sub	r0, r0, 0	/* 4-byte nop */
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	brne	1b
+
+1:	sub	r12, 1
+	sub	r12, r11
+	retal	r12
Index: uClibc-0.9.28-avr32/libc/string/avr32/strncpy.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/strncpy.S	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define dst r9
+#define src r11
+
+	.text
+	.global strcpy
+	.type	strncpy, @function
+strncpy:
+	mov	dst, r12
+
+	pref	src[0]
+	mov	dst, r12
+
+	/*
+	 * Check alignment. If src is aligned but dst isn't, we can't
+	 * do much about it...
+	 */
+	mov	r8, src
+	andl	r8, 3 COH
+	brne	.Lunaligned_src
+
+.Laligned_copy:
+	sub	r10, 4
+	brlt	3f
+1:	ld.w	r8, src++
+	tnbz	r8
+	breq	2f
+	st.w	dst++, r8
+	sub	r10, 4
+	brne	1b
+
+3:	sub	r10, -4
+	reteq	r12
+
+	/* This is safe as long as src is word-aligned and r10 > 0 */
+	ld.w	r8, src++
+
+2:	/*
+	 * Ok, r8 now contains the terminating '\0'. Copy the
+	 * remaining bytes individually.
+	 */
+	bfextu	r11, r8, 24, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	bfextu	r11, r8, 16, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	bfextu	r11, r8, 8, 8
+	st.b	dst++, r11
+	cp.w	r11, 0
+	reteq	r12
+	sub	r10, 1
+	reteq	r12
+	st.b	dst++, r8
+	retal	r12
+
+.Lunaligned_src:
+	/* Copy bytes until we're aligned */
+	min	r8, r8, r10
+	sub	r10, r8
+	sub	r8, 1
+	retlt	r12
+1:	ld.ub	r10, src++
+	st.b	dst++, r10
+	sub	r8, 1
+	brge	1b
+
+	rjmp	.Laligned_copy
Index: uClibc-0.9.28-avr32/libc/string/avr32/test_memcpy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28-avr32/libc/string/avr32/test_memcpy.c	2006-10-19 15:05:52.000000000 +0200
@@ -0,0 +1,66 @@
+
+#include <stdio.h>
+#include <string.h>
+
+#define BUF_SIZE 32768
+
+static char buf1[BUF_SIZE] __attribute__((aligned(32)));
+static char buf1_ref[BUF_SIZE] __attribute__((aligned(32)));
+static char buf2[BUF_SIZE] __attribute__((aligned(32)));
+
+extern void *new_memcpy(void *dest, void *src, size_t len);
+
+void dump_mismatch(char *buf, char *ref, size_t len)
+{
+	int i, j;
+
+	for (i = 0; i < len; i += 16) {
+		if (memcmp(buf + i, ref + i, 16) == 0)
+			continue;
+
+		printf("% 4x buf:", i);
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", buf[j]);
+		printf("\n     ref:");
+		for (j = i; j < (i + 16); j++)
+			printf(" %02x", ref[j]);
+		printf("\n");
+	}
+}
+
+void test(int src_offset, int dst_offset, int len)
+{
+	memset(buf1, 0x55, sizeof(buf1));
+	memset(buf1_ref, 0x55, sizeof(buf1_ref));
+	memset(buf2, 0xaa, sizeof(buf2));
+
+	printf("Testing with offsets %d => %d and len %d...",
+	       src_offset, dst_offset, len);
+
+	new_memcpy(buf1 + dst_offset, buf2 + src_offset, len);
+	memcpy(buf1_ref + dst_offset, buf2 + src_offset, len);
+
+	if (memcmp(buf1, buf1_ref, sizeof(buf1)) == 0)
+		printf("OK\n");
+	else {
+		printf("FAILED\n");
+		dump_mismatch(buf1, buf1_ref, sizeof(buf1));
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	test(0, 0, BUF_SIZE);
+	test(0, 0, 1);
+	test(0, 0, 31);
+	test(0, 0, 32);
+	test(0, 0, 127);
+	test(0, 0, 128);
+	test(4, 4, BUF_SIZE - 4);
+	test(1, 1, BUF_SIZE - 1);
+	test(1, 1, 126);
+	test(0, 3, 128);
+	test(1, 4, 128);
+
+	return 0;
+}
Subject: [PATCH] Don't include create_module() for AVR32

The create_module() system call is obsolete in Linux 2.6, so the
AVR32 kernel doesn't even have it.

Come to think about it, this should be completely unnecessary as the
create_module function is only a stub when __NR_create_module is
undefined.
---

 libc/sysdeps/linux/common/create_module.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

Index: uClibc-0.9.28/libc/sysdeps/linux/common/create_module.c
===================================================================
--- uClibc-0.9.28.orig/libc/sysdeps/linux/common/create_module.c	2006-02-07 16:48:38.000000000 +0100
+++ uClibc-0.9.28/libc/sysdeps/linux/common/create_module.c	2006-02-07 17:17:14.000000000 +0100
@@ -61,7 +61,8 @@ unsigned long create_module(const char *
 {
   return __create_module(name, size, 0, 0);
 }
-#else
+/* create_module is obsolete in Linux 2.6, so AVR32 doesn't have it */
+#elif !defined(__avr32__)
 /* Sparc, MIPS, etc don't mistake return values for errors. */ 
 _syscall2(unsigned long, create_module, const char *, name, size_t, size);
 #endif
Subject: [PATCH] ldso: Always inline _dl_memcpy()

On some gcc versions, inline is merely a hint. AVR32 depends on this
function actually getting inlined, so we need to use __always_inline
instead of just inline.

---

 ldso/include/dl-string.h |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: uClibc-0.9.28/ldso/include/dl-string.h
===================================================================
--- uClibc-0.9.28.orig/ldso/include/dl-string.h	2006-02-07 17:01:28.000000000 +0100
+++ uClibc-0.9.28/ldso/include/dl-string.h	2006-02-07 17:03:02.000000000 +0100
@@ -134,7 +134,7 @@ static inline char * _dl_strstr(const ch
     } while (1);
 }
 
-static inline void * _dl_memcpy(void * dst, const void * src, size_t len)
+static __always_inline void * _dl_memcpy(void * dst, const void * src, size_t len)
 {
 	register char *a = dst-1;
 	register const char *b = src-1;
Subject: [PATCH] ldso: Define MAP_FAILED for _dl_mmap()

When using mmap2() to emulate mmap(), _dl_mmap() uses MAP_FAILED to
indicate failure. MAP_FAILED is not defined anywhere, so this patch
defines it.

---

 ldso/include/dl-syscall.h |    1 +
 1 file changed, 1 insertion(+)

Index: uClibc-0.9.28/ldso/include/dl-syscall.h
===================================================================
--- uClibc-0.9.28.orig/ldso/include/dl-syscall.h	2006-02-07 16:49:27.000000000 +0100
+++ uClibc-0.9.28/ldso/include/dl-syscall.h	2006-02-07 17:07:06.000000000 +0100
@@ -132,6 +132,7 @@ static inline _syscall6(__ptr_t, __sysca
 		size_t, len, int, prot, int, flags, int, fd, off_t, offset);
 /*always 12, even on architectures where PAGE_SHIFT != 12 */
 #define MMAP2_PAGE_SHIFT 12
+#define MAP_FAILED ((void *) -1)
 static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
 		int flags, int fd, unsigned long offset)
 {
Subject: [PATCH] ldso: Always inline system calls

Some versions of gcc consider inline merely a hint. AVR32 depends on
the system calls actually being inlined, so we need to use
__always_inline instead of just inline.

---

 ldso/include/dl-syscall.h |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)

Index: uClibc-0.9.28/ldso/include/dl-syscall.h
===================================================================
--- uClibc-0.9.28.orig/ldso/include/dl-syscall.h	2006-02-07 17:07:06.000000000 +0100
+++ uClibc-0.9.28/ldso/include/dl-syscall.h	2006-02-07 17:08:47.000000000 +0100
@@ -60,59 +60,59 @@
    dynamic linking at all, so we cannot return any error codes.
    We just punt if there is an error. */
 #define __NR__dl_exit __NR_exit
-static inline _syscall1(void, _dl_exit, int, status);
+static __always_inline _syscall1(void, _dl_exit, int, status);
 
 #define __NR__dl_close __NR_close
-static inline _syscall1(int, _dl_close, int, fd);
+static __always_inline _syscall1(int, _dl_close, int, fd);
 
 #define __NR__dl_open __NR_open
-static inline _syscall3(int, _dl_open, const char *, fn, int, flags, __kernel_mode_t, mode);
+static __always_inline _syscall3(int, _dl_open, const char *, fn, int, flags, __kernel_mode_t, mode);
 
 #define __NR__dl_write __NR_write
-static inline _syscall3(unsigned long, _dl_write, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_write, int, fd,
 	    const void *, buf, unsigned long, count);
 
 #define __NR__dl_read __NR_read
-static inline _syscall3(unsigned long, _dl_read, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_read, int, fd,
 	    const void *, buf, unsigned long, count);
 
 #define __NR__dl_mprotect __NR_mprotect
-static inline _syscall3(int, _dl_mprotect, const void *, addr, unsigned long, len, int, prot);
+static __always_inline _syscall3(int, _dl_mprotect, const void *, addr, unsigned long, len, int, prot);
 
 #define __NR__dl_stat __NR_stat
-static inline _syscall2(int, _dl_stat, const char *, file_name, struct stat *, buf);
+static __always_inline _syscall2(int, _dl_stat, const char *, file_name, struct stat *, buf);
 
 #define __NR__dl_munmap __NR_munmap
-static inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
+static __always_inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
 
 #define __NR__dl_getuid __NR_getuid
-static inline _syscall0(uid_t, _dl_getuid);
+static __always_inline _syscall0(uid_t, _dl_getuid);
 
 #define __NR__dl_geteuid __NR_geteuid
-static inline _syscall0(uid_t, _dl_geteuid);
+static __always_inline _syscall0(uid_t, _dl_geteuid);
 
 #define __NR__dl_getgid __NR_getgid
-static inline _syscall0(gid_t, _dl_getgid);
+static __always_inline _syscall0(gid_t, _dl_getgid);
 
 #define __NR__dl_getegid __NR_getegid
-static inline _syscall0(gid_t, _dl_getegid);
+static __always_inline _syscall0(gid_t, _dl_getegid);
 
 #define __NR__dl_getpid __NR_getpid
-static inline _syscall0(gid_t, _dl_getpid);
+static __always_inline _syscall0(gid_t, _dl_getpid);
 
 #define __NR__dl_readlink __NR_readlink
-static inline _syscall3(int, _dl_readlink, const char *, path, char *, buf, size_t, bufsiz);
+static __always_inline _syscall3(int, _dl_readlink, const char *, path, char *, buf, size_t, bufsiz);
 
 #ifdef __NR_mmap
 #ifdef MMAP_HAS_6_ARGS
 #define __NR__dl_mmap __NR_mmap
-static inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
+static __always_inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
 		int, prot, int, flags, int, fd, off_t, offset);
 #else
 #define __NR__dl_mmap_real __NR_mmap
-static inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
+static __always_inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
 
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
 		int flags, int fd, unsigned long offset)
 {
 	unsigned long buffer[6];
@@ -128,12 +128,12 @@ static inline void * _dl_mmap(void * add
 #endif
 #elif defined __NR_mmap2
 #define __NR___syscall_mmap2       __NR_mmap2
-static inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr,
+static __always_inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr,
 		size_t, len, int, prot, int, flags, int, fd, off_t, offset);
 /*always 12, even on architectures where PAGE_SHIFT != 12 */
 #define MMAP2_PAGE_SHIFT 12
 #define MAP_FAILED ((void *) -1)
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
 		int flags, int fd, unsigned long offset)
 {
     if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
Subject: [PATCH] ldso: AVR32 support

This implements the AVR32-specific parts of the dynamic linker.

---

 ldso/ldso/avr32/dl-debug.h    |   45 +++++++++
 ldso/ldso/avr32/dl-startup.h  |  110 ++++++++++++++++++++++++
 ldso/ldso/avr32/dl-syscalls.h |    5 +
 ldso/ldso/avr32/dl-sysdep.h   |  103 ++++++++++++++++++++++
 ldso/ldso/avr32/elfinterp.c   |  191 ++++++++++++++++++++++++++++++++++++++++++
 ldso/ldso/avr32/resolve.S     |   28 ++++++
 6 files changed, 482 insertions(+)

Index: uClibc-0.9.28/ldso/ldso/avr32/dl-debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/dl-debug.h	2006-05-05 09:30:43.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * AVR32 ELF shared libary loader support
+ *
+ * Copyright (C) 2005 Atmel Norway
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static const char *_dl_reltypes_tab[] = {
+    "R_AVR32_NONE",
+    "R_AVR32_32", "R_AVR32_16", "R_AVR32_8",
+    "R_AVR32_32_PCREL", "R_AVR32_16_PCREL", "R_AVR32_8_PCREL",
+    "R_AVR32_DIFF32", "R_AVR32_DIFF16", "R_AVR32_DIFF8",
+    "R_AVR32_GOT32", "R_AVR32_GOT16", "R_AVR32_GOT8",
+    "R_AVR32_21S", "R_AVR32_16U", "R_AVR32_16S", "R_AVR32_8S", "R_AVR32_8S_EXT",
+    "R_AVR32_22H_PCREL", "R_AVR32_18W_PCREL", "R_AVR32_16B_PCREL",
+    "R_AVR32_16N_PCREL", "R_AVR32_14UW_PCREL", "R_AVR32_11H_PCREL",
+    "R_AVR32_10UW_PCREL", "R_AVR32_9H_PCREL", "R_AVR32_9UW_PCREL",
+    "R_AVR32_HI16", "R_AVR32_LO16",
+    "R_AVR32_GOTPC", "R_AVR32_GOTCALL", "R_AVR32_LDA_GOT",
+    "R_AVR32_GOT21S", "R_AVR32_GOT18SW", "R_AVR32_GOT16S", "R_AVR32_GOT7UW",
+    "R_AVR32_32_CPENT", "R_AVR32_CPCALL", "R_AVR32_16_CP", "R_AVR32_9W_CP",
+    "R_AVR32_RELATIVE", "R_AVR32_GLOB_DAT", "R_AVR32_JMP_SLOT",
+    "R_AVR32_ALIGN",
+};
Index: uClibc-0.9.28/ldso/ldso/avr32/dl-startup.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/dl-startup.h	2006-05-05 09:29:45.000000000 +0200
@@ -0,0 +1,110 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Architecture specific code used by dl-startup.c
+ * Copyright (C) 2005 Atmel Norway
+ */
+
+/* This is the library loader's main entry point. Let _dl_boot2 do its
+ * initializations and jump to the application's entry point
+ * afterwards. */
+asm(	"	.text\n"
+	"	.global	_start\n"
+	"	.type	_start,@function\n"
+	"_start:\n"
+	/* All arguments are on the stack initially */
+	"	mov	r12, sp\n"
+	"	rcall	_dl_start\n"
+	/* Returns user entry point in r12. Save it. */
+	"	mov	r0, r12\n"
+	/* We're PIC, so get the Global Offset Table */
+	"	lddpc	r6, .L_GOT\n"
+	".L_RGOT:\n"
+	"	rsub	r6, pc\n"
+	/* Adjust argc and argv according to _dl_skip_args */
+	"	ld.w	r1, r6[_dl_skip_args@got]\n"
+	"	ld.w	r1, r1[0]\n"
+	"	ld.w	r2, sp++\n"
+	"	sub	r2, r1\n"
+	"	add	sp, sp, r1 << 2\n"
+	"	st.w	--sp, r2\n"
+	/* Load the finalizer function */
+	"	ld.w	r12, r6[_dl_fini@got]\n"
+	/* Jump to the user's entry point */
+	"	mov	pc, r0\n\n"
+
+	"	.align	2\n"
+	".L_GOT:"
+	"	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_\n"
+	"	.size	_start, . - _start\n"
+	"	.previous\n");
+
+/* Get a pointer to the argv array.  On many platforms this can be just
+ * the address if the first argument, on other platforms we need to
+ * do something a little more subtle here. */
+#define GET_ARGV(ARGVP, ARGS) ARGVP = ((unsigned long *)ARGS + 1)
+
+
+/* We can't call functions before the GOT has been initialized */
+#define NO_FUNCS_BEFORE_BOOTSTRAP
+
+/*
+ * Relocate the GOT during dynamic loader bootstrap.  This will add
+ * the load address to all entries in the GOT, which is necessary
+ * because the linker doesn't generate R_AVR32_RELATIVE relocs for the
+ * GOT.
+ */
+static __always_inline
+void PERFORM_BOOTSTRAP_GOT(struct elf_resolve *tpnt)
+{
+	Elf32_Addr i, nr_got;
+	register Elf32_Addr *__r6 __asm__("r6");
+	Elf32_Addr *got = __r6;
+
+	nr_got = tpnt->dynamic_info[DT_AVR32_GOTSZ_IDX] / sizeof(*got);
+	for (i = 2; i < nr_got; i++)
+		got[i] += tpnt->loadaddr;
+}
+
+#define PERFORM_BOOTSTRAP_GOT(tpnt) PERFORM_BOOTSTRAP_GOT(tpnt)
+
+/* Handle relocation of the symbols in the dynamic loader. */
+static __always_inline
+void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
+			     unsigned long symbol_addr,
+			     unsigned long load_addr, Elf32_Sym *symtab)
+{
+	switch(ELF32_R_TYPE(rpnt->r_info)) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr;
+		break;
+	case R_AVR32_RELATIVE:
+		SEND_STDERR_DEBUG("Applying RELATIVE relocation: ");
+		SEND_ADDRESS_STDERR_DEBUG(load_addr, 0);
+		SEND_STDERR_DEBUG(" + ");
+		SEND_ADDRESS_STDERR_DEBUG(rpnt->r_addend, 1);
+		*reloc_addr = load_addr + rpnt->r_addend;
+		break;
+	default:
+		SEND_STDERR("BOOTSTRAP_RELOC: unhandled reloc_type ");
+		SEND_NUMBER_STDERR(ELF32_R_TYPE(rpnt->r_info), 1);
+		SEND_STDERR("REL, SYMBOL, LOAD: ");
+		SEND_ADDRESS_STDERR(reloc_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(symbol_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(load_addr, 1);
+		_dl_exit(1);
+	}
+}
+
+/* Transfer control to the user's application, once the dynamic loader
+ * is done. This routine has to exit the current function, then call
+ * the _dl_elf_main function.
+ *
+ * Since our _dl_boot will simply call whatever is returned by
+ * _dl_boot2, we can just return the address we're supposed to
+ * call.  */
+#define START()	return _dl_elf_main;
Index: uClibc-0.9.28/ldso/ldso/avr32/dl-syscalls.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/dl-syscalls.h	2006-05-05 09:29:25.000000000 +0200
@@ -0,0 +1,5 @@
+/* We can't use the real errno in ldso, since it has not yet
+ * been dynamicly linked in yet. */
+extern int _dl_errno;
+#define __set_errno(X) {(_dl_errno) = (X);}
+#include "sys/syscall.h"
Index: uClibc-0.9.28/ldso/ldso/avr32/dl-sysdep.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/dl-sysdep.h	2006-05-05 09:30:43.000000000 +0200
@@ -0,0 +1,103 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Various assembly language/system dependent hacks that are required
+ * so that we can minimize the amount of platform specific code.
+ * Copyright (C) 2004-2005 Atmel Norway
+ */
+
+/* Define this if the system uses RELOCA. */
+#define ELF_USES_RELOCA
+
+#include <elf.h>
+
+#define ARCH_NUM 1
+#define DT_AVR32_GOTSZ_IDX	(DT_NUM + OS_NUM)
+
+#define ARCH_DYNAMIC_INFO(dpnt, dynamic, debug_addr)			\
+	do {								\
+		if (dpnt->d_tag == DT_AVR32_GOTSZ)			\
+			dynamic[DT_AVR32_GOTSZ_IDX] = dpnt->d_un.d_val;	\
+	} while (0)
+
+/* Initialization sequence for the application/library GOT. */
+#define INIT_GOT(GOT_BASE,MODULE)					\
+	do {								\
+		unsigned long i, nr_got;				\
+									\
+		GOT_BASE[0] = (unsigned long) _dl_linux_resolve;	\
+		GOT_BASE[1] = (unsigned long) MODULE;			\
+									\
+		/* Add load address displacement to all GOT entries */	\
+		nr_got = MODULE->dynamic_info[DT_AVR32_GOTSZ_IDX] / 4;	\
+		for (i = 2; i < nr_got; i++)				\
+			GOT_BASE[i] += (unsigned long)MODULE->loadaddr;	\
+	} while (0)
+
+#define do_rem(result, n, base)	((result) = (n) % (base))
+
+/* Here we define the magic numbers that this dynamic loader should accept */
+#define MAGIC1 EM_AVR32
+#undef MAGIC2
+
+/* Used for error messages */
+#define ELF_TARGET "AVR32"
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got);
+
+/* 4096 bytes alignment */
+#define PAGE_ALIGN 0xfffff000
+#define ADDR_ALIGN 0xfff
+#define OFFS_ALIGN 0x7ffff000
+
+#define elf_machine_type_class(type)				\
+	((type == R_AVR32_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)
+
+/* AVR32 doesn't need any COPY relocs */
+#define DL_NO_COPY_RELOCS
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+	register Elf32_Addr *got asm ("r6");
+	return *got;
+}
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+	extern void __dl_start asm("_dl_start");
+	Elf32_Addr got_addr = (Elf32_Addr) &__dl_start;
+	Elf32_Addr pcrel_addr;
+
+	asm   ("	lddpc	%0, 2f\n"
+	       "1:	add	%0, pc\n"
+	       "	rjmp	3f\n"
+	       "	.align	2\n"
+	       "2:	.long	_dl_start - 1b\n"
+	       "3:\n"
+	       : "=r"(pcrel_addr) : : "cc");
+
+	return pcrel_addr - got_addr;
+}
+
+/*
+ * Perform any RELATIVE relocations specified by DT_RELCOUNT.
+ * Currently, we don't use that tag, but we might in the future as
+ * this would reduce the startup time somewhat (although probably not by much).
+ */
+static inline void
+elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
+		      Elf32_Word relative_count)
+{
+	Elf32_Rela *rpnt = (void *)rel_addr;
+
+	do {
+		Elf32_Addr *reloc_addr;
+		reloc_addr = (void *)(load_off + (rpnt++)->r_offset);
+		*reloc_addr = load_off + rpnt->r_addend;
+	} while (--relative_count);
+}
Index: uClibc-0.9.28/ldso/ldso/avr32/elfinterp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/elfinterp.c	2006-05-05 09:30:43.000000000 +0200
@@ -0,0 +1,191 @@
+/*
+ * AVR32 ELF shared library loader suppport
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got)
+{
+	struct elf_resolve *tpnt = (struct elf_resolve *)got[1];
+	Elf32_Sym *sym;
+	unsigned long local_gotno;
+	unsigned long gotsym;
+	unsigned long new_addr;
+	char *strtab, *symname;
+	unsigned long *entry;
+	unsigned long sym_index = got_offset / 4;
+
+#if 0
+	local_gotno = tpnt->dynamic_info[DT_AVR32_LOCAL_GOTNO];
+	gotsym = tpnt->dynamic_info[DT_AVR32_GOTSYM];
+
+	sym = ((Elf32_Sym *)(tpnt->dynamic_info[DT_SYMTAB] + tpnt->loadaddr))
+		+ sym_index;
+	strtab = (char *)(tpnt->dynamic_info[DT_STRTAB] + tpnt->loadaddr);
+	symname = strtab + sym->st_name;
+
+#if 0
+	new_addr = (unsigned long) _dl_find_hash(strtab + sym->st_name,
+						 tpnt->symbol_scope, tpnt,
+						 resolver);
+#endif
+
+	entry = (unsigned long *)(got + local_gotno + sym_index - gotsym);
+	*entry = new_addr;
+#endif
+
+	return new_addr;
+}
+
+static int
+_dl_parse(struct elf_resolve *tpnt, struct dyn_elf *scope,
+	  unsigned long rel_addr, unsigned long rel_size,
+	  int (*reloc_func)(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			    Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab))
+{
+	Elf32_Sym *symtab;
+	Elf32_Rela *rpnt;
+	char *strtab;
+	int i;
+
+	rpnt = (Elf32_Rela *)rel_addr;
+	rel_size /= sizeof(Elf32_Rela);
+	symtab = (Elf32_Sym *)tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+
+	for (i = 0; i < rel_size; i++, rpnt++) {
+		int symtab_index, res;
+
+		symtab_index = ELF32_R_SYM(rpnt->r_info);
+
+		debug_sym(symtab, strtab, symtab_index);
+		debug_reloc(symtab, strtab, rpnt);
+
+		res = reloc_func(tpnt, scope, rpnt, symtab, strtab);
+
+		if (res == 0)
+			continue;
+
+		_dl_dprintf(2, "\n%s: ", _dl_progname);
+
+		if (symtab_index)
+			_dl_dprintf(2, "symbol '%s': ",
+				    strtab + symtab[symtab_index].st_name);
+
+		if (res < 0) {
+			int reloc_type = ELF32_R_TYPE(rpnt->r_info);
+#if defined(__SUPPORT_LD_DEBUG__)
+			_dl_dprintf(2, "can't handle reloc type %s\n",
+				    _dl_reltypes(reloc_type));
+#else
+			_dl_dprintf(2, "can't handle reloc type %x\n",
+				    reloc_type);
+#endif
+			_dl_exit(-res);
+		} else {
+			_dl_dprintf(2, "can't resolve symbol\n");
+			return res;
+		}
+	}
+
+	return 0;
+}
+
+static int _dl_do_reloc(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab)
+{
+	int reloc_type;
+	int symtab_index;
+	char *symname;
+	unsigned long *reloc_addr;
+	unsigned long symbol_addr;
+#if defined(__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+
+	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
+	reloc_type = ELF32_R_TYPE(rpnt->r_info);
+	symtab_index = ELF32_R_SYM(rpnt->r_info);
+	symbol_addr = 0;
+	symname = strtab + symtab[symtab_index].st_name;
+
+	if (symtab_index) {
+		symbol_addr = (unsigned long)
+			_dl_find_hash(strtab + symtab[symtab_index].st_name,
+				      tpnt->symbol_scope, tpnt,
+				      elf_machine_type_class(reloc_type));
+
+		/* Allow undefined references to weak symbols */
+		if (!symbol_addr &&
+		    ELF32_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
+			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n",
+				    _dl_progname, symname);
+			return 0;
+		}
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	old_val = *reloc_addr;
+#endif
+	switch (reloc_type) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr + rpnt->r_addend;
+		break;
+	case R_AVR32_RELATIVE:
+		*reloc_addr = (unsigned long)tpnt->loadaddr
+			+ rpnt->r_addend;
+		break;
+	default:
+		return -1;
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
+			    old_val, *reloc_addr);
+#endif
+
+	return 0;
+}
+
+void _dl_parse_lazy_relocation_information(struct dyn_elf *rpnt,
+					   unsigned long rel_addr,
+					   unsigned long rel_size)
+{
+	/* TODO: Might want to support this in order to get faster
+	 * startup times... */
+}
+
+int _dl_parse_relocation_information(struct dyn_elf *rpnt,
+				     unsigned long rel_addr,
+				     unsigned long rel_size)
+{
+	return _dl_parse(rpnt->dyn, rpnt->dyn->symbol_scope, rel_addr, rel_size,
+			 _dl_do_reloc);
+}
Index: uClibc-0.9.28/ldso/ldso/avr32/resolve.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/ldso/ldso/avr32/resolve.S	2006-05-05 09:29:25.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * Linux dynamic resolving code for AVR32. Fixes up the GOT entry as
+ * indicated in register r12 and jumps to the resolved address.
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ *
+ * Copyright (C) 2004 Atmel Norway
+ */
+
+#define ip r5
+
+	.text
+	.global	_dl_linux_resolve
+	.type	_dl_linux_resolve,@function
+_dl_linux_resolve:
+	/* The PLT code pushed r8 for us. It contains the address of this
+	   function's GOT entry, that is entry 0. ip contains the address
+	   of the GOT entry of the function we wanted to call. */
+	stm	--sp, r9-r12, lr
+	mov	r11, r8
+	sub	r12, ip, r8
+	rcall	_dl_linux_resolver
+	mov	ip, r12
+	popm	r8-r12,lr
+	mov	pc, ip
+	.size	_dl_linux_resolve, . - _dl_linux_resolve
Subject: [PATCH] ldso: AVR32 needs CONSTANT_STRING_GOT_FIXUP

Add AVR32 to the list of architectures needing CONSTANT_STRING_GOT_FIXUP.

---

 ldso/include/dl-string.h |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

Index: uClibc-0.9.28/ldso/include/dl-string.h
===================================================================
--- uClibc-0.9.28.orig/ldso/include/dl-string.h	2006-02-07 16:58:58.000000000 +0100
+++ uClibc-0.9.28/ldso/include/dl-string.h	2006-02-07 16:59:28.000000000 +0100
@@ -271,7 +271,8 @@ static __always_inline char * _dl_simple
 /* On some arches constant strings are referenced through the GOT.
  * This requires that load_addr must already be defined... */
 #if defined(mc68000) || defined(__arm__) || defined(__mips__)	\
-                     || defined(__sh__) ||  defined(__powerpc__)
+                     || defined(__sh__) ||  defined(__powerpc__) \
+		     || defined(__avr32__)
 # define CONSTANT_STRING_GOT_FIXUP(X) \
 	if ((X) < (const char *) load_addr) (X) += load_addr
 # define NO_EARLY_SEND_STDERR
Subject: [PATCH] ldso: AVR32 startup hack

AVR32 needs to do both PERFORM_BOOTSTRAP_GOT and a full relocation of
the GOT. I don't quite remember why, but I think it's because some GOT
entries just need the load address added to them, while the rest need
the full relocation code.

This patch should be revisited to figure out whether we're processing
relocations against undefined symbols and whether that's something we
should be doing...

---

 ldso/ldso/dl-startup.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

Index: uClibc-0.9.28/ldso/ldso/dl-startup.c
===================================================================
--- uClibc-0.9.28.orig/ldso/ldso/dl-startup.c	2006-02-07 16:49:27.000000000 +0100
+++ uClibc-0.9.28/ldso/ldso/dl-startup.c	2006-02-07 17:12:09.000000000 +0100
@@ -217,7 +217,9 @@ static void * __attribute_used__ _dl_sta
 	/* some arches (like MIPS) we have to tweak the GOT before relocations */
 	PERFORM_BOOTSTRAP_GOT(tpnt);
 
-#else
+#endif
+
+#if !defined(PERFORM_BOOTSTRAP_GOT) || defined(__avr32__)
 
 	/* OK, now do the relocations.  We do not do a lazy binding here, so
 	   that once we are done, we have considerably more flexibility. */
@@ -259,7 +261,7 @@ static void * __attribute_used__ _dl_sta
 				rel_addr += relative_count * sizeof(ELF_RELOC);;
 			}
 
-			rpnt = (ELF_RELOC *) (rel_addr + load_addr);
+			rpnt = (ELF_RELOC *) (rel_addr /* + load_addr */);
 			for (i = 0; i < rel_size; i += sizeof(ELF_RELOC), rpnt++) {
 				reloc_addr = (unsigned long *) (load_addr + (unsigned long) rpnt->r_offset);
 				symtab_index = ELF_R_SYM(rpnt->r_info);
Subject: [PATCH] ldd: AVR32 support

Add AVR32-specific definitions to ldd.

---

 utils/ldd.c |    5 +++++
 1 file changed, 5 insertions(+)

Index: uClibc-0.9.28/utils/ldd.c
===================================================================
--- uClibc-0.9.28.orig/utils/ldd.c	2006-02-07 16:48:02.000000000 +0100
+++ uClibc-0.9.28/utils/ldd.c	2006-02-07 17:13:00.000000000 +0100
@@ -56,6 +56,11 @@
 #define ELFCLASSM	ELFCLASS32
 #endif
 
+#if defined(__avr32__)
+#define MATCH_MACHINE(x) (x == EM_AVR32)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #if defined(__s390__)
 #define MATCH_MACHINE(x) (x == EM_S390)
 #define ELFCLASSM	ELFCLASS32
Subject: [PATCH] libpthread: AVR32 support

Implement pt-machine.h for AVR32.
---

 libpthread/linuxthreads/sysdeps/avr32/pt-machine.h |   92 +++++++++++++++++++++
 1 file changed, 92 insertions(+)

Index: uClibc-0.9.28/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.28/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h	2006-02-07 17:14:47.000000000 +0100
@@ -0,0 +1,92 @@
+/* Machine-dependent pthreads configuration and inline functions.
+
+   Copyright (C) 2005 Atmel Norway
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+static inline int
+_test_and_set (int *p, int v) __THROW
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline test and set */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%0, %2\n"
+		"	tst	%0, %3\n"
+		"	breq	2f\n"
+		"	stcond	%1, %3\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=m"(*p)
+		: "m"(*p), "r"(v)
+		: "memory", "cc");
+
+	return result;
+}
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+	return _test_and_set(spinlock, 1);
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("sp");
+
+/* Compare-and-swap for semaphores. */
+
+#define HAS_COMPARE_AND_SWAP
+PT_EI int
+__compare_and_swap(long int *p, long int oldval, long int newval)
+{
+	long int result, tmp;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%1, %3\n"
+		"	cp.w	%1, %5\n"
+		"	sreq	%0\n"
+		"	brne	2f\n"
+		"	stcond	%2, %4\n"
+		"	brne	1b\n"
+		"2:"
+		: "=&r"(result), "=&r"(tmp), "=m"(*p)
+		: "m"(*p), "r"(newval), "r"(oldval)
+		: "cc", "memory");
+
+	return result;
+}
+
+#endif /* pt-machine.h */
---
 libc/sysdeps/linux/avr32/bits/fcntl.h |   33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

Index: uClibc-0.9.28-avr32/libc/sysdeps/linux/avr32/bits/fcntl.h
===================================================================
--- uClibc-0.9.28-avr32.orig/libc/sysdeps/linux/avr32/bits/fcntl.h	2006-11-23 17:38:30.000000000 +0100
+++ uClibc-0.9.28-avr32/libc/sysdeps/linux/avr32/bits/fcntl.h	2006-11-23 17:52:15.000000000 +0100
@@ -11,28 +11,29 @@
 
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
-#define O_ACCMODE	  0003
-#define O_RDONLY	    00
-#define O_WRONLY	    01
-#define O_RDWR		    02
-#define O_CREAT		  0100	/* not fcntl */
-#define O_EXCL		  0200	/* not fcntl */
-#define O_NOCTTY	  0400	/* not fcntl */
-#define O_TRUNC		 01000	/* not fcntl */
-#define O_APPEND	 02000
-#define O_NONBLOCK	 04000
+#define O_ACCMODE	00000003
+#define O_RDONLY	00000000
+#define O_WRONLY	00000001
+#define O_RDWR		00000002
+#define O_CREAT		00000100	/* not fcntl */
+#define O_EXCL		00000200	/* not fcntl */
+#define O_NOCTTY	00000400	/* not fcntl */
+#define O_TRUNC		00001000	/* not fcntl */
+#define O_APPEND	00002000
+#define O_NONBLOCK	00004000
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		010000
-#define O_ASYNC		020000
+#define O_SYNC		00010000
+#define O_ASYNC		00020000
 
 #ifdef __USE_GNU
-# define O_DIRECTORY	040000	/* must be a directory */
-# define O_NOFOLLOW	0100000	/* don't follow links */
-# define O_DIRECT	0200000	/* direct disk access */
+# define O_DIRECT	00040000	/* must be a directory */
+# define O_DIRECTORY	00200000	/* direct disk access */
+# define O_NOFOLLOW	00400000	/* don't follow links */
+# define O_NOATIME	01000000	/* don't set atime */
 #endif
 
 #ifdef __USE_LARGEFILE64
-# define O_LARGEFILE	0400000
+# define O_LARGEFILE	00100000
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
