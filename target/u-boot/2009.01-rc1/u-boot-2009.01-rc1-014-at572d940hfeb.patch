diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/at572d940hfeb.c u-boot-2009.01-rc1/board/atmel/at572d940hfeb/at572d940hfeb.c
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/at572d940hfeb.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/at572d940hfeb.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,277 @@
+/* (C) 2008 Copyright Atmel Corporation
+ *
+ * Antonio R. Costa <antonio.costa <at> atmel.com>
+ * <costa.antonior <at> gmail.com>
+ *
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at572d940hf.h>
+#include <asm/arch/at572d940hf_matrix.h>
+#include <asm/arch/at572d940hf_mc.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+#include <asm/arch/at91_aic.h>
+#include <asm/arch/interrupts.h>
+#if defined(CONFIG_RESET_PHY_R) && defined(CONFIG_MACB)
+#include <net.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+	* Miscelaneous platform dependent initialisations
+	*/
+
+static void AT572D940HFEB_serial_hw_init(void)
+{
+#ifdef CONFIG_USART0
+	at91_set_A_periph(AT91_PIN_PA8, 1); /* TXD0 */
+	at91_set_A_periph(AT91_PIN_PA7, 0); /* RXD0 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US0);
+#endif
+
+#ifdef CONFIG_USART1
+	at91_set_A_periph(AT91_PIN_PC10, 1); /* TXD1 */
+	at91_set_A_periph(AT91_PIN_PC9, 0); /* RXD1 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US1);
+#endif
+
+#ifdef CONFIG_USART2
+	at91_set_A_periph(AT91_PIN_PC15, 1); /* TXD2 */
+	at91_set_A_periph(AT91_PIN_PC14, 0); /* RXD2 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US2);
+#endif
+
+#ifdef CONFIG_USART3 /* DBGU */
+	at91_set_A_periph(AT91_PIN_PC30, 0); /* DRXD */
+	at91_set_A_periph(AT91_PIN_PC31, 1); /* DTXD */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_SYS);
+#endif
+}
+
+#ifdef CONFIG_CMD_NAND
+static void AT572D940HFEB_nand_hw_init(void)
+{
+	unsigned long csa;
+
+	/* Enable CS3 */
+	csa = at91_sys_read(AT91_MATRIX_EBICSA);
+	at91_sys_write(AT91_MATRIX_EBICSA,
+	csa | AT91_MATRIX_CS3A_SMC_SMARTMEDIA);
+
+	/* Configure SMC CS3 for NAND/SmartMedia */
+	at91_sys_write(AT91_SMC_SETUP(3),
+	AT91_SMC_NWESETUP_(0) | AT91_SMC_NCS_WRSETUP_(0) |
+	AT91_SMC_NRDSETUP_(0) | AT91_SMC_NCS_RDSETUP_(0));
+	at91_sys_write(AT91_SMC_PULSE(3),
+	AT91_SMC_NWEPULSE_(3) | AT91_SMC_NCS_WRPULSE_(3) |
+	AT91_SMC_NRDPULSE_(3) | AT91_SMC_NCS_RDPULSE_(3));
+	at91_sys_write(AT91_SMC_CYCLE(3),
+	AT91_SMC_NWECYCLE_(5) | AT91_SMC_NRDCYCLE_(5));
+	at91_sys_write(AT91_SMC_MODE(3),
+	AT91_SMC_READMODE | AT91_SMC_WRITEMODE |
+	AT91_SMC_EXNWMODE_DISABLE |
+	AT91_SMC_DBW_8 | AT91_SMC_TDF_(2));
+
+	at91_sys_write(AT91_PMC_PCER, 1 << AT572D940HF_ID_PIOC);
+
+	/* Configure RDY/BSY */
+	at91_set_gpio_input(AT91_PIN_PC16, 1);
+
+	/* Enable NandFlash */
+	/* By DIP switch on AT572D940HFEB */
+	at91_set_gpio_output(AT91_PIN_PC14, 1);
+}
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+static void AT572D940HFEB_spi_hw_init(void)
+{
+	at91_set_A_periph(AT91_PIN_PA3, 0); /* SPI0_NPCS0 */
+	at91_set_A_periph(AT91_PIN_PA4, 0); /* SPI0_NPCS1 */
+
+	at91_set_A_periph(AT91_PIN_PA0, 0); /* SPI0_MISO */
+	at91_set_A_periph(AT91_PIN_PA1, 0); /* SPI0_MOSI */
+	at91_set_A_periph(AT91_PIN_PA2, 0); /* SPI0_SPCK */
+
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT572D940HF_ID_SPI0);
+}
+#endif
+
+#ifdef CONFIG_MACB
+static void AT572D940HFEB_macb_hw_init(void)
+{
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT572D940HF_ID_EMAC);
+
+	/* Need to reset PHY -> 500ms reset */
+#if 0
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+		(AT91_RSTC_ERSTL & (0x0D << 8)) |
+		AT91_RSTC_URSTEN);
+
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_EXTRST);
+
+	/* Wait for end hardware reset */
+	while (!(at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_NRSTL));
+
+	/* Restore NRST value */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+		(AT91_RSTC_ERSTL & (0x0 << 8)) |
+		AT91_RSTC_URSTEN);
+#endif
+
+	at91_set_A_periph(AT91_PIN_PA16, 0); /* ETXCK_EREFCK */
+	at91_set_A_periph(AT91_PIN_PA17, 0); /* ERXDV */
+	at91_set_A_periph(AT91_PIN_PA18, 0); /* ERX0 */
+	at91_set_A_periph(AT91_PIN_PA19, 0); /* ERX1 */
+	at91_set_A_periph(AT91_PIN_PA20, 0); /* ERXER */
+	at91_set_A_periph(AT91_PIN_PA23, 0); /* ETXEN */
+	at91_set_A_periph(AT91_PIN_PA21, 0); /* ETX0 */
+	at91_set_A_periph(AT91_PIN_PA22, 0); /* ETX1 */
+	at91_set_A_periph(AT91_PIN_PA13, 0); /* EMDIO */
+	at91_set_A_periph(AT91_PIN_PA14, 0); /* EMDC */
+	at91_set_A_periph(AT91_PIN_PA15, 0); /* EFCE100 */
+}
+#endif
+
+#ifdef CONFIG_MMC
+static void AT572D940HFEB_mci_hw_init(void)
+{
+	at91_sys_write(AT91_PMC_PCER, (1 << AT572D940HF_ID_MCI));
+
+	at91_set_A_periph(AT91_PIN_PC22,0);
+	at91_set_A_periph(AT91_PIN_PC23,0);
+	at91_set_A_periph(AT91_PIN_PC24,0);
+	at91_set_A_periph(AT91_PIN_PC25,0);
+	at91_set_A_periph(AT91_PIN_PC26,0);
+	at91_set_A_periph(AT91_PIN_PC27,0);
+}
+#endif
+
+#ifdef CONFIG_USBH
+static void AT572D940HFEB_usbh_hw_init(void)
+{
+	at91_sys_write(AT91_PMC_PCER, (1 << AT572D940HF_ID_UHP));
+	at91_sys_write(AT91_PMC_SCER, AT572D940HF_PMC_UHP);
+}
+
+int rstc_init(void)
+{
+	/* Reads the SR to clean from
+	* previous resets
+	*/
+	at91_sys_read(AT91_RSTC_SR);
+
+	/* Disble the USR_RST line,
+	* enable USR_RST_INT and
+	* sets the EXT_RST length to 2^14
+	* (500ms needed by the phy)
+	*/
+	at91_sys_write(AT91_RSTC_MR, (0xa5<<24) | (13<<8) | AT91_RSTC_URSTIEN);
+	return 0;
+}
+
+int board_init(void)
+{
+
+	/* Init the reset controller */
+	rstc_init();
+
+	/* Init interrupts */
+	interrupts_init();
+
+	/* Enable Ctrlc */
+	console_init_f();
+
+	/* arch number of AT572D940HFEB-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_AT572D940HFEB;
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM +	0x100;
+
+	AT572D940HFEB_serial_hw_init();
+
+#ifdef CONFIG_CMD_NAND
+	AT572D940HFEB_nand_hw_init();
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+	AT572D940HFEB_spi_hw_init();
+#endif
+
+#ifdef CONFIG_MACB
+	AT572D940HFEB_macb_hw_init();
+#endif
+
+#ifdef CONFIG_MMC
+	AT572D940HFEB_mci_hw_init();
+#endif
+
+#ifdef CONFIG_USBH
+	AT572D940HFEB_usbh_hw_init();
+#endif
+
+#endif
+	gd->flags |= GD_FLG_RELOC;
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_CMD_NET
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+#ifdef CONFIG_MACB
+	/*
+	* Initialize ethernet HW addr prior to starting Linux,
+	* needed for nfsroot
+	*/
+	eth_init(gd->bd);
+#endif /* CONFIG_MACB */
+}
+#endif /* CONFIG_RESET_PHY_R */
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_MACB
+	rc = at572d940hf_eth_initialize(bis);
+#endif
+	return rc;
+}
+
+#endif /* CONFIG_CMD_NET */
+
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/config.mk u-boot-2009.01-rc1/board/atmel/at572d940hfeb/config.mk
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/config.mk	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1 @@
+TEXT_BASE = 0x23f00000
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/flash.c u-boot-2009.01-rc1/board/atmel/at572d940hfeb/flash.c
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/flash.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,507 @@
+/*
+ * (C) Copyright 2002
+ * Lineo, Inc. <www.lineo.com>
+ * Bernhard Kuhn <bkuhn@li...>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sy...>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush(void);
+
+
+/* Flash Organization Structure */
+typedef struct OrgDef
+{
+	unsigned int sector_number;
+	unsigned int sector_size;
+} OrgDef;
+
+
+/* Flash Organizations */
+
+OrgDef OrgAT49BV642D[] =
+{
+	{ 8, 4*1024 },
+	{ 58, 32*1024 },
+};
+
+OrgDef OrgAT49BV16x4[] =
+{
+	{ 8, 8*1024 }, /* 8 * 8 kBytes sectors */
+	{ 2, 32*1024 }, /* 2 * 32 kBytes sectors */
+	{ 30, 64*1024 }, /* 30 * 64 kBytes sectors */
+};
+
+OrgDef OrgAT49BV16x4A[] =
+{
+	{ 8, 8*1024 }, /* 8 * 8 kBytes sectors */
+	{ 31, 64*1024 }, /* 31 * 64 kBytes sectors */
+};
+
+OrgDef OrgAT49BV6416[] =
+{
+	{ 8, 8*1024 }, /* 8 * 8 kBytes sectors */
+	{ 127, 64*1024 }, /* 127 * 64 kBytes sectors */
+};
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+/* AT49BV1614A Codes */
+#define FLASH_CODE1 0xAA
+#define FLASH_CODE2 0x55
+#define ID_IN_CODE 0x90
+#define ID_OUT_CODE 0xF0
+
+
+#define CMD_READ_ARRAY 0x00F0
+#define CMD_UNLOCK1 0x00AA
+#define CMD_UNLOCK2 0x0055
+#define CMD_ERASE_SETUP 0x0080
+#define CMD_ERASE_CONFIRM 0x0030
+#define CMD_PROGRAM 0x00A0
+#define CMD_UNLOCK_BYPASS 0x0020
+#define CMD_SECTOR_UNLOCK 0x0070
+
+#define MEM_FLASH_ADDR1 (*(volatile u16 *)(CONFIG_SYS_FLASH_BASE +	(0x00005555<<1)))
+#define MEM_FLASH_ADDR2 (*(volatile u16 *)(CONFIG_SYS_FLASH_BASE +	(0x00002AAA<<1)))
+
+#define BIT_ERASE_DONE 0x0080
+#define BIT_RDY_MASK 0x0080
+#define BIT_PROGRAM_ERROR 0x0020
+#define BIT_TIMEOUT 0x80000000 /* our flag */
+
+#define READY 1
+#define ERR 2
+#define TMO 4
+
+/*-----------------------------------------------------------------------
+	*/
+void flash_identification (flash_info_t * info)
+{
+	volatile u16 manuf_code, device_code, add_device_code;
+
+	MEM_FLASH_ADDR1 = FLASH_CODE1;
+	MEM_FLASH_ADDR2 = FLASH_CODE2;
+	MEM_FLASH_ADDR1 = ID_IN_CODE;
+
+	manuf_code = *(volatile u16 *) CONFIG_SYS_FLASH_BASE;
+	device_code = *(volatile u16 *) (CONFIG_SYS_FLASH_BASE +	2);
+	add_device_code = *(volatile u16 *) (CONFIG_SYS_FLASH_BASE +	(3 << 1));
+
+	MEM_FLASH_ADDR1 = FLASH_CODE1;
+	MEM_FLASH_ADDR2 = FLASH_CODE2;
+	MEM_FLASH_ADDR1 = ID_OUT_CODE;
+
+	/* Vendor type */
+	info->flash_id = ATM_MANUFACT & FLASH_VENDMASK;
+	printf ("Atmel: ");
+
+	if ((device_code & FLASH_TYPEMASK) == (ATM_ID_BV1614 & FLASH_TYPEMASK)) {
+
+		if ((add_device_code & FLASH_TYPEMASK) ==
+		(ATM_ID_BV1614A & FLASH_TYPEMASK)) {
+			info->flash_id |= ATM_ID_BV1614A & FLASH_TYPEMASK;
+			printf ("AT49BV1614A (16Mbit)\n");
+		} else { /* AT49BV1614 Flash */
+			info->flash_id |= ATM_ID_BV1614 & FLASH_TYPEMASK;
+			printf ("AT49BV1614 (16Mbit)\n");
+		}
+
+	} else if ((device_code & FLASH_TYPEMASK) == (ATM_ID_BV6416 & FLASH_TYPEMASK)) {
+		info->flash_id |= ATM_ID_BV6416 & FLASH_TYPEMASK;
+		printf ("AT49BV6416 (64Mbit)\n");
+	}
+}
+
+ushort flash_number_sector(OrgDef *pOrgDef, unsigned int nb_blocks)
+{
+	int i, nb_sectors = 0;
+
+	for (i=0; i<nb_blocks; i++){
+		nb_sectors += pOrgDef[i].sector_number;
+	}
+
+	return nb_sectors;
+}
+
+void flash_unlock_sector(flash_info_t * info, unsigned int sector)
+{
+	volatile u16 *addr = (volatile u16 *) (info->start[sector]);
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	*addr = CMD_SECTOR_UNLOCK;
+}
+
+
+ulong flash_init (void)
+{
+	int i, j, k;
+	unsigned int flash_nb_blocks, sector;
+	unsigned int start_address;
+	OrgDef *pOrgDef;
+
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_identification (&flash_info[i]);
+
+		if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
+			(ATM_ID_BV1614 & FLASH_TYPEMASK)) {
+
+			pOrgDef = OrgAT49BV16x4;
+			flash_nb_blocks = sizeof (OrgAT49BV16x4) / sizeof (OrgDef);
+		} else if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
+			(ATM_ID_BV1614A & FLASH_TYPEMASK)){ /* AT49BV1614A Flash */
+
+			pOrgDef = OrgAT49BV16x4A;
+			flash_nb_blocks = sizeof (OrgAT49BV16x4A) / sizeof (OrgDef);
+	} else if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
+		(ATM_ID_BV6416 & FLASH_TYPEMASK)){ /* AT49BV6416 Flash */
+
+	pOrgDef = OrgAT49BV6416;
+	flash_nb_blocks = sizeof (OrgAT49BV6416) / sizeof (OrgDef);
+	} else {
+	flash_nb_blocks = 0;
+	pOrgDef = OrgAT49BV16x4;
+	}
+
+	flash_info[i].sector_count = flash_number_sector(pOrgDef, flash_nb_blocks);
+	memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+	if (i == 0)
+		flashbase = PHYS_FLASH_1;
+	else
+		panic ("configured too many flash banks!\n");
+
+		sector = 0;
+		start_address = flashbase;
+		flash_info[i].size = 0;
+
+		for (j = 0; j < flash_nb_blocks; j++) {
+			for (k = 0; k < pOrgDef[j].sector_number; k++) {
+			flash_info[i].start[sector++] = start_address;
+			start_address += pOrgDef[j].sector_size;
+			flash_info[i].size += pOrgDef[j].sector_size;
+			}
+		}
+
+		size += flash_info[i].size;
+
+		if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
+			(ATM_ID_BV6416 & FLASH_TYPEMASK)){ /* AT49BV6416 Flash */
+
+			/* Unlock all sectors at reset */
+			for (j=0; j<flash_info[i].sector_count; j++){
+				flash_unlock_sector(&flash_info[i], j);
+			}
+		}
+	}
+
+	/* Protect binary boot image */
+	flash_protect (FLAG_PROTECT_SET,
+		CONFIG_SYS_FLASH_BASE,
+		CONFIG_SYS_FLASH_BASE +	CONFIG_SYS_BOOT_SIZE - 1, &flash_info[0]);
+
+	/* Protect environment variables */
+	flash_protect (FLAG_PROTECT_SET,
+		CONFIG_ENV_ADDR,
+		CONFIG_ENV_ADDR +	CONFIG_ENV_SIZE - 1, &flash_info[0]);
+
+	/* Protect U-Boot gzipped image */
+	flash_protect (FLAG_PROTECT_SET,
+		CONFIG_SYS_U_BOOT_BASE,
+		CONFIG_SYS_U_BOOT_BASE +	CONFIG_SYS_U_BOOT_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------*/
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (ATM_MANUFACT & FLASH_VENDMASK):
+		printf ("Atmel: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (ATM_ID_BV1614 & FLASH_TYPEMASK):
+		printf ("AT49BV1614 (16Mbit)\n");
+		break;
+	case (ATM_ID_BV1614A & FLASH_TYPEMASK):
+	printf ("AT49BV1614A (16Mbit)\n");
+		break;
+	case (ATM_ID_BV6416 & FLASH_TYPEMASK):
+		printf ("AT49BV6416 (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		return;
+	}
+
+	printf (" Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf (" Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n ");
+		}
+		printf (" %08lX%s", info->start[i],
+		info->protect[i] ? " (RO)" : " ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------*/
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ulong result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip1;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(ATM_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) { /* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip1 = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip1 = TMO;
+					break;
+				}
+
+				if (!chip1 && (result & 0xFFFF) & BIT_ERASE_DONE)
+				chip1 = READY;
+
+			} while (!chip1);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip1 == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip1 == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else { /* it was protected */
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+	printf ("User Interrupt!\n");
+
+outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+	* Copy memory to flash
+	*/
+
+static int write_word (flash_info_t * info, ulong dest, ulong data)
+{
+	volatile u16 *addr = (volatile u16 *) dest;
+	ulong result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip1;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip1 = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			chip1 = ERR | TMO;
+			break;
+		}
+		if (!chip1 && ((result & 0x80) == (data & 0x80)))
+			chip1 = READY;
+
+	} while (!chip1);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip1 == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+	* Copy memory to flash.
+	*/
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong wp, data;
+	int rc;
+
+	if (addr & 1) {
+		printf ("unaligned destination not supported\n");
+		return ERR_ALIGN;
+	};
+
+	if ((int) src & 1) {
+		printf ("unaligned source not supported\n");
+		return ERR_ALIGN;
+	};
+
+	wp = addr;
+
+	while (cnt >= 2) {
+		data = *((volatile u16 *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 1) {
+		data = (*((volatile u8 *) src)) | (*((volatile u8 *) (wp +	1)) << 8);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 1;
+		wp += 1;
+		cnt -= 1;
+	};
+
+	return ERR_OK;
+}
+
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/interrupts.c u-boot-2009.01-rc1/board/atmel/at572d940hfeb/interrupts.c
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/interrupts.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/interrupts.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,83 @@
+/*
+ * board/atmel/at572d940hfeb/interrupts.c
+ * Copyright 2008 (C) ATMEL
+ * Antonio R. Costa <antonio.costa <at> atmel.com>
+ * <costa.antonior <at> gmail.com>
+ *
+ * Advanced Interrupt Controller (AIC).
+ * Based on AT572D940HF datasheet.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <common.h>
+#include <asm/arch/at572d940hf.h>
+#include <asm/arch/io.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/at91_aic.h>
+#include <asm/arch/interrupts.h>
+
+irq_handler_t handler_reset(void)
+{
+	unsigned long rstc_sr=0;
+
+	rstc_sr = at91_sys_read(AT91_RSTC_SR);
+	if(rstc_sr & AT91_RSTC_URSTS) {
+		while(!(at91_sys_read(AT91_RSTC_SR) & (1<<16)));
+		reset_cpu(1);
+	};
+}
+
+irq_handler_t handler_ext1(void)
+{
+	puts("--- EXT1 IRQ ---\n");
+}
+
+
+int reset_irqs(void) {
+	unsigned long ul = 0;
+	volatile unsigned long * psrc = _armboot_start;
+	volatile unsigned long * pdest = 0x0;
+
+	/*
+	 * Relocates U-Boot ARM IRQ vectors to 0
+	 * This is an ugly way to do it.
+	 * More support must be offered by start.S
+	 * on symbols and macros performing partial relocation
+	 */
+
+	while(ul++	< 16)
+		*pdest++	= *psrc++;
+
+
+	/* Reset IRQ vectors */
+	for(ul=0;ul<32;ul++)
+		RESET_IRQ_HANDLER(ul);
+	return 0;
+}
+
+int interrupts_init(void)
+{
+	reset_irqs();
+	SET_IRQ_HANDLER(1 ,0x27,handler_reset);
+	SET_IRQ_HANDLER(30,0x27,handler_ext1);
+	return 0;
+}
+
+
+void do_irq(struct pt_regs* pregs) {
+
+	unsigned long int ivr = AIC_REG(AIC_IVR);
+	unsigned long int isr = AIC_REG(AIC_ISR);
+	void (*irq_handler)(unsigned long int) = (void(*)(unsigned long int)) ivr;
+
+	irq_handler(isr);
+
+	/* Acknowledges irq */
+	IRQ_ACKNOWLEDGE(ivr);
+
+	return;
+};
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/Makefile u-boot-2009.01-rc1/board/atmel/at572d940hfeb/Makefile
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/Makefile	2009-01-04 22:03:38.000000000 +0100
@@ -0,0 +1,60 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd <at> denx.de.
+#
+#
+#
+#
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB = $(obj)lib$(BOARD).a
+
+COBJS-y += at572d940hfeb.o
+#COBJS-y	+= led.o
+COBJS-y += partition.o
+#COBJS-y += flash.o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+#COBJS-$(CONFIG_CMD_MMC) += atmel_mci.o
+COBJS-$(CONFIG_USE_IRQ) += interrupts.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/nand.c u-boot-2009.01-rc1/board/atmel/at572d940hfeb/nand.c
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/nand.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/nand.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9g20.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pio.h>
+
+#include <nand.h>
+
+/*
+ *	hardware specific access to control-lines
+ */
+#define	MASK_ALE	(1 << 21)	/* our ALE is AD21 */
+#define	MASK_CLE	(1 << 22)	/* our CLE is AD22 */
+
+static void at572d940hfeb_nand_hwcontrol(struct mtd_info *mtd,
+					 int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(MASK_ALE | MASK_CLE);
+
+		if (ctrl & NAND_CLE)
+			IO_ADDR_W |= MASK_CLE;
+		if (ctrl & NAND_ALE)
+			IO_ADDR_W |= MASK_ALE;
+
+		at91_set_gpio_value(AT91_PIN_PC14, !(ctrl & NAND_NCE));
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+static int at572d940hfeb_nand_ready(struct mtd_info *mtd)
+{
+	return at91_get_gpio_value(AT91_PIN_PC13);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->ecc.mode = NAND_ECC_SOFT;
+#ifdef CONFIG_SYS_NAND_DBW_16
+	nand->options = NAND_BUSWIDTH_16;
+#endif
+	nand->cmd_ctrl = at572d940hfeb_nand_hwcontrol;
+	nand->dev_ready = at572d940hfeb_nand_ready;
+	nand->chip_delay = 20;
+
+	return 0;
+}
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/partition.c u-boot-2009.01-rc1/board/atmel/at572d940hfeb/partition.c
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/partition.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/partition.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+	*
+	* This program is free software; you can redistribute it and/or
+	* modify it under the terms of the GNU General Public License as
+	* published by the Free Software Foundation; either version 2 of
+	* the License, or (at your option) any later version.
+	*
+	* This program is distributed in the hope that it will be useful,
+	* but WITHOUT ANY WARRANTY; without even the implied warranty of
+	* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+	* GNU General Public License for more details.
+	*
+	* You should have received a copy of the GNU General Public License
+	* along with this program; if not, write to the Free Software
+	* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+	* MA 02111-1307 USA
+	*
+	*/
+#include <common.h>
+#include <config.h>
+#include <asm/hardware.h>
+#include <dataflash.h>
+
+AT91S_DATAFLASH_INFO dataflash_info[CONFIG_SYS_MAX_DATAFLASH_BANKS];
+
+struct dataflash_addr cs[CONFIG_SYS_MAX_DATAFLASH_BANKS] = {
+	{CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS0, 0}, /* Logical adress, CS */
+	{CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS1, 1}
+};
+
+/*define the area offsets*/
+dataflash_protect_t area_list[NB_DATAFLASH_AREA] = {
+	{0x00000000, 0x000041FF, FLAG_PROTECT_SET,	0, "Bootstrap"},
+	{0x00004200, 0x000083FF, FLAG_PROTECT_CLEAR,	0, "Environment"},
+	{0x00008400, 0x00041FFF, FLAG_PROTECT_SET,	0, "U-Boot"},
+	{0x00042000, 0x00251FFF, FLAG_PROTECT_CLEAR,	0, "Kernel"},
+	{0x00252000, 0xFFFFFFFF, FLAG_PROTECT_CLEAR,	0, "FS"},
+};
+
diff -urN u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/u-boot.lds u-boot-2009.01-rc1/board/atmel/at572d940hfeb/u-boot.lds
--- u-boot-2009.01-rc1-0rig//board/atmel/at572d940hfeb/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/board/atmel/at572d940hfeb/u-boot.lds	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+	* (C) Copyright 2002
+	* Gary Jennejohn, DENX Software Engineering, <gj <at> denx.de>
+	*
+	* See file CREDITS for list of people who contributed to this
+	* project.
+	*
+	* This program is free software; you can redistribute it and/or
+	* modify it under the terms of the GNU General Public License as
+	* published by the Free Software Foundation; either version 2 of
+	* the License, or (at your option) any later version.
+	*
+	* This program is distributed in the hope that it will be useful,
+	* but WITHOUT ANY WARRANTY; without even the implied warranty of
+	* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+	* GNU General Public License for more details.
+	*
+	* You should have received a copy of the GNU General Public License
+	* along with this program; if not, write to the Free Software
+	* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+	* MA 02111-1307 USA
+	*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/config.mk u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/config.mk
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/config.mk	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,3 @@
+PLATFORM_CPPFLAGS += -march=armv5te
+PLATFORM_CPPFLAGS += $(call cc-option,-mtune=arm926ejs,)
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/ether.c u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/ether.c
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/ether.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/ether.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+#if defined(CONFIG_MACB) && defined(CONFIG_CMD_NET)
+void at572d940hf_eth_initialize(bd_t *bi)
+{
+	macb_eth_initialize(0, (void *)AT91_BASE_EMAC, 0x00);
+}
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/lowlevel_init.S u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/lowlevel_init.S
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/lowlevel_init.S	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * AT91CAP9/SAM9 setup stuff
+ *
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+
+	.globl lowlevel_init
+
+lowlevel_init:
+
+/*
+ * Clocks/SDRAM initialization is handled by at91bootstrap,
+ * no need to do it here...
+ */
+	mov pc, lr
+
+	.ltorg
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/Makefile u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/Makefile
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/Makefile	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2000-2008
+# Wolfgang Denk, DENX Software Engineering, wd <at> denx.de.
+#
+#
+#
+#
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS-y += ether.o
+COBJS-y += timer.o
+COBJS-$(CONFIG_HAS_DATAFLASH) +=spi.o
+COBJS-y += usb.o
+SOBJS = lowlevel_init.o
+
+SRCS := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS := $(addprefix $(obj),$(SOBJS) $(COBJS-y))
+
+all: $(obj).depend $(LIB)
+
+$(LIB): $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/spi.c u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/spi.c
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/spi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/spi.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,158 @@
+/*
+ * Driver for ATMEL DataFlash support
+ * Author : Hamid Ikdoumi (Atmel)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/at91_spi.h>
+
+#include <dataflash.h>
+
+#define AT91_SPI_PCS0_DATAFLASH_CARD 0xE /* Chip Select 0: NPCS0%1110 */
+#define AT91_SPI_PCS1_DATAFLASH_CARD 0xD /* Chip Select 0: NPCS0%1101 */
+#define AT91_SPI_PCS3_DATAFLASH_CARD 0x7 /* Chip Select 3: NPCS3%0111 */
+
+void AT91F_SpiInit(void)
+{
+	/* Reset the SPI */
+	writel(AT91_SPI_SWRST, AT91_BASE_SPI + AT91_SPI_CR);
+
+	/* Configure SPI in Master Mode with No CS selected !!! */
+	writel(AT91_SPI_MSTR | AT91_SPI_MODFDIS | AT91_SPI_PCS,
+		AT91_BASE_SPI + AT91_SPI_MR);
+
+	/* Configure CS0 */
+	writel(AT91_SPI_NCPHA |
+		(AT91_SPI_DLYBS & DATAFLASH_TCSS) |
+		(AT91_SPI_DLYBCT & DATAFLASH_TCHS) |
+		((AT91_MASTER_CLOCK / AT91_SPI_CLK) << 8),
+		AT91_BASE_SPI + AT91_SPI_CSR(0));
+
+#ifdef CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS1
+	/* Configure CS1 */
+	writel(AT91_SPI_NCPHA |
+		(AT91_SPI_DLYBS & DATAFLASH_TCSS) |
+		(AT91_SPI_DLYBCT & DATAFLASH_TCHS) |
+		((AT91_MASTER_CLOCK / AT91_SPI_CLK) << 8),
+		AT91_BASE_SPI + AT91_SPI_CSR(1));
+#endif
+
+#ifdef CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS3
+	/* Configure CS3 */
+	writel(AT91_SPI_NCPHA |
+		(AT91_SPI_DLYBS & DATAFLASH_TCSS) |
+		(AT91_SPI_DLYBCT & DATAFLASH_TCHS) |
+		((AT91_MASTER_CLOCK / AT91_SPI_CLK) << 8),
+		AT91_BASE_SPI + AT91_SPI_CSR(3));
+#endif
+
+	/* SPI_Enable */
+	writel(AT91_SPI_SPIEN, AT91_BASE_SPI + AT91_SPI_CR);
+
+	while (!(readl(AT91_BASE_SPI + AT91_SPI_SR) & AT91_SPI_SPIENS));
+
+/*
+ * Add tempo to get SPI in a safe state.
+ * Should not be needed for new silicon (Rev B)
+ */
+	udelay(500000);
+	readl(AT91_BASE_SPI + AT91_SPI_SR);
+	readl(AT91_BASE_SPI + AT91_SPI_RDR);
+
+}
+
+void AT91F_SpiEnable(int cs)
+{
+	unsigned long mode;
+
+	switch (cs) {
+	case 0: /* Configure SPI CS0 for Serial DataFlash AT45DBxx */
+		mode = readl(AT91_BASE_SPI + AT91_SPI_MR);
+		mode &= 0xFFF0FFFF;
+		writel(mode | ((AT91_SPI_PCS0_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
+		AT91_BASE_SPI + AT91_SPI_MR);
+		break;
+	case 1: /* Configure SPI CS1 for Serial DataFlash AT45DBxx */
+		mode = readl(AT91_BASE_SPI + AT91_SPI_MR);
+		mode &= 0xFFF0FFFF;
+		writel(mode | ((AT91_SPI_PCS1_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
+		AT91_BASE_SPI + AT91_SPI_MR);
+		break;
+	case 3:
+		mode = readl(AT91_BASE_SPI + AT91_SPI_MR);
+		mode &= 0xFFF0FFFF;
+		writel(mode | ((AT91_SPI_PCS3_DATAFLASH_CARD<<16) & AT91_SPI_PCS),
+		AT91_BASE_SPI + AT91_SPI_MR);
+		break;
+	}
+
+	/* SPI_Enable */
+	writel(AT91_SPI_SPIEN, AT91_BASE_SPI + AT91_SPI_CR);
+}
+
+unsigned int AT91F_SpiWrite1(AT91PS_DataflashDesc pDesc);
+
+unsigned int AT91F_SpiWrite(AT91PS_DataflashDesc pDesc)
+{
+	unsigned int timeout;
+
+	pDesc->state = BUSY;
+
+	writel(AT91_SPI_TXTDIS + AT91_SPI_RXTDIS, AT91_BASE_SPI + AT91_SPI_PTCR);
+
+	/* Initialize the Transmit and Receive Pointer */
+	writel((unsigned int)pDesc->rx_cmd_pt, AT91_BASE_SPI + AT91_SPI_RPR);
+	writel((unsigned int)pDesc->tx_cmd_pt, AT91_BASE_SPI + AT91_SPI_TPR);
+
+	/* Intialize the Transmit and Receive Counters */
+	writel(pDesc->rx_cmd_size, AT91_BASE_SPI + AT91_SPI_RCR);
+	writel(pDesc->tx_cmd_size, AT91_BASE_SPI + AT91_SPI_TCR);
+
+	if (pDesc->tx_data_size != 0) {
+		/* Initialize the Next Transmit and Next Receive Pointer */
+		writel((unsigned int)pDesc->rx_data_pt, AT91_BASE_SPI + AT91_SPI_RNPR);
+		writel((unsigned int)pDesc->tx_data_pt, AT91_BASE_SPI + AT91_SPI_TNPR);
+
+		/* Intialize the Next Transmit and Next Receive Counters */
+		writel(pDesc->rx_data_size, AT91_BASE_SPI + AT91_SPI_RNCR);
+		writel(pDesc->tx_data_size, AT91_BASE_SPI + AT91_SPI_TNCR);
+	}
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked();
+	timeout = 0;
+
+	writel(AT91_SPI_TXTEN + AT91_SPI_RXTEN, AT91_BASE_SPI + AT91_SPI_PTCR);
+	while (!(readl(AT91_BASE_SPI + AT91_SPI_SR) & AT91_SPI_RXBUFF) &&
+		((timeout = get_timer_masked()) < CONFIG_SYS_SPI_WRITE_TOUT));
+	writel(AT91_SPI_TXTDIS + AT91_SPI_RXTDIS, AT91_BASE_SPI + AT91_SPI_PTCR);
+	pDesc->state = IDLE;
+
+	if (timeout >= CONFIG_SYS_SPI_WRITE_TOUT) {
+		printf("Error Timeout\n\r");
+		return DATAFLASH_ERROR;
+	}
+
+	return DATAFLASH_OK;
+}
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/timer.c u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/timer.c
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/timer.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,293 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Author: Antonio R. Costa
+ * based upon AT91
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/at572d940hf.h>
+#include <asm/arch/at572d940hf_mc.h>
+#include <asm/arch/memory-map.h>
+#include <asm/arch/at91_pit.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/io.h>
+
+/*
+ * We're using the AT91CAP9/SAM9 PITC in 32 bit mode, by
+ * setting the 20 bit counter period to its maximum (0xfffff).
+ */
+#define TIMER_LOAD_VAL 0xfffff
+#define READ_RESET_TIMER at91_sys_read(AT91_PIT_PIVR)
+#define READ_TIMER at91_sys_read(AT91_PIT_PIIR)
+#define TIMER_FREQ (AT91_MASTER_CLOCK << 4)
+#define TICKS_TO_USEC(ticks) ((ticks) / 6)
+
+ulong get_timer_masked(void);
+ulong resettime;
+
+int sys_get_freq(unsigned long mode, unsigned long *pfreq)
+{
+	unsigned long mckr = (unsigned long) -1;
+	unsigned long clksrc=0;
+	unsigned long clkpre=0;
+	unsigned long clkdiv=0;
+	unsigned long main_clock=0;
+	unsigned long tmode = mode;
+
+
+	/*!This function checks for \c AT91_CLK_DELAY_CYCLES cycles if the main clock is ready.
+	 * If it is not it exits with \c -EIO.
+	 * Otherwise, assuming a slow clock of \c CONFIG_SLOW_CLK Hz (default 32768 Hz), it computes
+	 * the number of main clock cycles occurring in 16 slow clock cycles.
+	 * This number multiplied by (_GNAM_SLOW_CLK / 16) results in the
+	 * actual frequency of the main clock.
+	 */
+	{
+		long tmp = AT91_CLK_DELAY_CYCLES;
+		while(!(at91_sys_read(AT91_CKGR_MCFR) & AT91_PMC_MAINRDY) && (tmp-- > 0));
+		if(tmp <= 0) {
+			*pfreq = 0;
+			return -EIO;
+		}
+	}
+
+	main_clock = (at91_sys_read(AT91_CKGR_MCFR) & AT91_PMC_MAINF) * (CONFIG_SLOW_CLK / 16);
+
+	/*!Depending on the \c mode parameter, this function returns frequencies
+	 * for the <b>slow clock</b>, <b>main clock</b>, \b PLLA, \b PLLB or <b>master clock</b>.
+	 */
+
+	/*!In the last case the function reads the PMC to find which source
+	 * has been selected for the master clock and perform the relevant
+	 * computations.
+	 */
+
+	if(AT91_SLOW_FREQ == mode) {
+		*pfreq = CONFIG_SLOW_CLK;
+		return 0;
+	}
+
+	/* Little trick: master clock depends on another source,
+	 * so here it checks for the selected source and
+	 * change the mode param to the master clock source
+	 */
+	if((AT91_SYS_FREQ == mode) | (AT91_PROC_FREQ == mode)) {
+		mckr = at91_sys_read(AT91_PMC_MCKR);
+		clksrc = (mckr & AT91_PMC_CSS ) ;
+		clkpre = (mckr & AT91_PMC_PRES) >> 2;
+		clkdiv = (mckr & AT91_PMC_MDIV) >> 8;
+		tmode = clksrc;
+	}
+
+	if(AT91_PMC_CSS_MAIN == tmode)
+		*pfreq = main_clock;
+
+	if(AT91_PMC_CSS_PLLA == tmode) {
+		unsigned long pllar = at91_sys_read(AT91_CKGR_PLLAR);
+		unsigned long mula = (pllar & AT91_PMC_MUL) >> 16;
+		unsigned long diva = (pllar & AT91_PMC_DIV);
+		*pfreq = (diva != 0) ? ((main_clock / diva) * ++mula) : 0;
+	}
+
+	if(AT91_PMC_CSS_PLLB == tmode) {
+		unsigned long pllbr = at91_sys_read(AT91_CKGR_PLLBR);
+		unsigned long mulb = (pllbr & AT91_PMC_MUL) >> 16;
+		unsigned long divb = (pllbr & AT91_PMC_DIV);
+
+		*pfreq = (divb != 0) ? ((main_clock / divb) * ++mulb) : 0;
+	}
+
+	/* If the mode selected is different of
+	 * _GNAM_SYS_FREQ or AT91_PROC_FREQ
+	 * all is done and frequency can be returned.
+	 */
+	if((AT91_SYS_FREQ != mode) & (AT91_PROC_FREQ != mode))
+		return 0;
+
+	/* Here it divides the frequency
+	 * by the prescaler factor
+	 */
+	*pfreq = *pfreq >> clkpre;
+
+	/* If the selected frequency is AT91_SYS_FREQ
+	 * then it must be selected by the clkdiv factor
+	 */
+	if(AT91_SYS_FREQ == mode)
+	*pfreq = *pfreq >> clkdiv;
+
+	return 0;
+}
+
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int timer_init(void)
+{
+	/*
+	 * Enable PITC Clock
+	 * The clock is already enabled for system controller in boot
+	 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_SYS);
+
+	/* Enable PITC */
+	at91_sys_write(AT91_PIT_MR, TIMER_LOAD_VAL | AT91_PIT_PITEN);
+
+	reset_timer_masked();
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+
+static inline ulong get_timer_raw(void)
+{
+	ulong now = READ_TIMER;
+
+	if (now >= resettime)
+		return now - resettime;
+	else
+	return 0xFFFFFFFFUL - (resettime - now) ;
+}
+
+void reset_timer_masked(void)
+{
+	resettime = READ_TIMER;
+}
+
+ulong get_timer_masked(void)
+{
+	return TICKS_TO_USEC(get_timer_raw());
+
+}
+
+void udelay_masked(unsigned long usec)
+{
+	ulong tmp;
+
+	tmp = get_timer(0);
+	while (get_timer(tmp) < usec) /* our timer works in usecs */
+	; /* NOP */
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	ulong now = get_timer_masked();
+
+	if (now >= base)
+		return now - base;
+	else
+		return TICKS_TO_USEC(0xFFFFFFFFUL) - (base - now) ;
+}
+
+void udelay(unsigned long usec)
+{
+	udelay_masked(usec);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	ulong tbclk;
+
+	tbclk = CONFIG_SYS_HZ;
+	return tbclk;
+}
+
+/*
+ * Reset the cpu by setting up the watchdog timer and let him time out.
+ */
+void reset_cpu(ulong ignored)
+{
+	/* at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY | (0x3u << 8) | 0x01); */
+
+	/*
+	 * ARC:
+	 * This code must be executed in internal RAM
+	 * cause the SDRAM is under reset
+	 */
+
+	/*
+	 * ARC:
+	 * Reset SDRAM in safe way
+	 */
+	unsigned long reg = at91_sys_read(AT91_SDRAMC_LPR);
+	at91_sys_write(AT91_SDRAMC_LPR, reg | AT91_SDRAMC_LPCB_SELF_REFRESH);
+	at91_sys_write(AT91_SDRAMC_MR, AT91_SDRAMC_MODE_NORMAL);
+	*(volatile unsigned long *) AT572D940_SDRAM_BASE = 0x0;
+
+	/*
+	 * ARC
+	 * Waits until the reset button has been released.
+	 * Unusefull if checked previously.
+	 */
+
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_EXTRST);
+
+
+	while(!(at91_sys_read(AT91_RSTC_SR) & (1<<16)));
+
+	{
+	/*
+	 * ARC:
+	 * i should be register cause SDRAM has been reset
+	 */
+		volatile register unsigned int i = 1000000;
+		while(i-->0);
+	};
+
+
+	/* this is the way Linux does it */
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY |
+		AT91_RSTC_PROCRST |
+		/* AT91_RSTC_EXTRST */
+		AT91_RSTC_PERRST);
+	return;
+	while (1);
+	/* Never reached */
+}
+
diff -urN u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/usb.c u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/usb.c
--- u-boot-2009.01-rc1-0rig//cpu/arm926ejs/at572d940hf/usb.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/cpu/arm926ejs/at572d940hf/usb.c	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+ * (C) Copyright 2006
+ * DENX Software Engineering <mk <at> denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_USB_OHCI_NEW) && defined(CONFIG_SYS_USB_OHCI_CPU_INIT)
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/io.h>
+#include <asm/arch/at91_pmc.h>
+
+int usb_cpu_init(void)
+{
+	/* Enable USB host clock. */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_UHP);
+	at91_sys_write(AT91_PMC_SCER, AT91_PMC_UHP);
+
+	return 0;
+}
+
+int usb_cpu_stop(void)
+{
+	/* Disable USB host clock. */
+	at91_sys_write(AT91_PMC_PCDR, 1 << AT91_ID_UHP);
+	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_UHP);
+	return 0;
+}
+
+int usb_cpu_init_fail(void)
+{
+	return usb_cpu_stop();
+}
+
+#endif /* defined(CONFIG_USB_OHCI) && defined(CONFIG_SYS_USB_OHCI_CPU_INIT) */
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,148 @@
+/*
+ * include/asm-arm/arch-at91/AT572D940HFhf.h
+ *
+ * (C) 2008 Antonio R. Costa
+ *
+ * Common definitions.
+ * Based on AT572D940HFHF datasheet rev A.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT572D940HFHF_H
+#define AT572D940HFHF_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ 0			/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS 1			/* System Peripherals */
+#define AT572D940HF_ID_PIOA 2		/* Parallel IO Controller A */
+#define AT572D940HF_ID_PIOB 3		/* Parallel IO Controller B */
+#define AT572D940HF_ID_PIOC 4		/* Parallel IO Controller C */
+#define AT572D940HF_ID_EMAC 5		/* Ethernet */
+#define AT572D940HF_ID_US0 6		/* USART 0 */
+#define AT572D940HF_ID_US1 7		/* USART 1 */
+#define AT572D940HF_ID_US2 8		/* USART 2 */
+#define AT572D940HF_ID_MCI 9		/* Multimedia Card Interface */
+#define AT572D940HF_ID_UDP 10		/* USB Device Port */
+#define AT572D940HF_ID_TWI 11		/* Two-Wire Interface */
+#define AT572D940HF_ID_TWI0 11		/* Two-Wire Interface */
+#define AT572D940HF_ID_SPI0 12		/* Serial Peripheral Interface 0 */
+#define AT572D940HF_ID_SPI1 13		/* Serial Peripheral Interface 1 */
+#define AT572D940HF_ID_SSC 14		/* Serial Synchronous Controller */
+#define AT572D940HF_ID_SSC0 14		/* Serial Synchronous Controller */
+#define AT572D940HF_ID_SSC1 15		/* Serial Synchronous Controller */
+#define AT572D940HF_ID_SSC2 16		/* Serial Synchronous Controller */
+#define AT572D940HF_ID_TC0 17		/* Timer Counter 0 */
+#define AT572D940HF_ID_TC1 18		/* Timer Counter 1 */
+#define AT572D940HF_ID_TC2 19		/* Timer Counter 2 */
+#define AT572D940HF_ID_UHP 20		/* USB Host port */
+#define AT572D940HF_ID_SSC3 21		/* Serial Synchronous Controller */
+#define AT572D940HF_ID_TWI1 22		/* Two-Wire Interface */
+#define AT572D940HF_ID_CAN0 23		/* CAN Controller */
+#define AT572D940HF_ID_CAN1 24		/* CAN Controller */
+#define AT572D940HF_ID_mHALT 25		/* mAgicV DSP halt int */
+#define AT572D940HF_ID_mSIRQ1 26	/* mAgicV DSP SIRQ1 int */
+#define AT572D940HF_ID_mEXC 27		/* mAgicV DSP Exception int */
+#define AT572D940HF_ID_mEDMA 28		/* mAgicV DSP end of DMA transfer int */
+#define AT572D940HF_ID_IRQ0 29		/* Advanced Interrupt Controller (IRQ0) */
+#define AT572D940HF_ID_IRQ1 30		/* Advanced Interrupt Controller (IRQ1) */
+#define AT572D940HF_ID_IRQ2 31		/* Advanced Interrupt Controller (IRQ2) */
+
+#define AT91_ID_US0 AT572D940HF_ID_US0
+#define AT91_ID_US1 AT572D940HF_ID_US1
+#define AT91_ID_US2 AT572D940HF_ID_US2
+#define AT91_ID_US3 AT572D940HF_ID_US3
+
+#define AT91_ID_UHP AT572D940HF_ID_UHP
+#define AT91_PMC_UHP AT572D940HF_ID_UHP
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT572D940HF_BASE_TCB0 0xfffa0000
+#define AT572D940HF_BASE_TC0 0xfffa0000
+#define AT572D940HF_BASE_TC1 0xfffa0040
+#define AT572D940HF_BASE_TC2 0xfffa0080
+#define AT572D940HF_BASE_UDP 0xfffa4000
+#define AT572D940HF_BASE_MCI 0xfffa8000
+#define AT572D940HF_BASE_TWI 0xfffac000
+#define AT572D940HF_BASE_US0 0xfffb0000
+#define AT572D940HF_BASE_US1 0xfffb4000
+#define AT572D940HF_BASE_US2 0xfffb8000
+#define AT572D940HF_BASE_SSC 0xfffbc000
+#define AT572D940HF_BASE_ISI 0xfffc0000
+#define AT572D940HF_BASE_EMAC 0xfffd8000
+#define AT572D940HF_BASE_SPI0 0xfffc8000
+#define AT572D940HF_BASE_SPI1 0xfffcc000
+#define AT572D940HF_BASE_US3 0xfffd0000
+#define AT572D940HF_BASE_US4 0xfffd4000
+#define AT572D940HF_BASE_US5 0xfffd8000
+#define AT572D940HF_BASE_TCB1 0xfffdc000
+#define AT572D940HF_BASE_TC3 0xfffdc000
+#define AT572D940HF_BASE_TC4 0xfffdc040
+#define AT572D940HF_BASE_TC5 0xfffdc080
+#define AT572D940HF_BASE_ADC 0xfffe0000
+#define AT572D940HF_BASE_RSTC 0xfffffd00
+#define AT91_BASE_SYS 0xffffea00
+
+#define AT91_BASE_EMAC AT572D940HF_BASE_EMAC
+#define AT91_BASE_SPI AT572D940HF_BASE_SPI0
+#define MMCI_BASE AT572D940HF_BASE_MCI
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_ECC (0xffffe800 - AT91_BASE_SYS)
+#define AT91_SDRAMC (0xffffea00 - AT91_BASE_SYS)
+#define AT91_SMC (0xffffec00 - AT91_BASE_SYS)
+#define AT91_MATRIX (0xffffee00 - AT91_BASE_SYS)
+#define AT91_CCFG (0xffffef10 - AT91_BASE_SYS)
+#define AT91_AIC (0xfffff000 - AT91_BASE_SYS)
+#define AT91_DBGU (0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOA (0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOB (0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOC (0xfffff800 - AT91_BASE_SYS)
+#define AT91_PMC (0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC (0xfffffd00 - AT91_BASE_SYS)
+#define AT91_SHDWC (0xfffffd10 - AT91_BASE_SYS)
+#define AT91_RTT (0xfffffd20 - AT91_BASE_SYS)
+#define AT91_PIT (0xfffffd30 - AT91_BASE_SYS)
+#define AT91_WDT (0xfffffd40 - AT91_BASE_SYS)
+#define AT91_GPBR (0xfffffd50 - AT91_BASE_SYS)
+
+#define AT91_USART0 AT572D940HF_BASE_US0
+#define AT91_USART1 AT572D940HF_BASE_US1
+#define AT91_USART2 AT572D940HF_BASE_US2
+#define AT91_USART3 AT572D940HF_BASE_US3
+#define AT91_USART4 AT572D940HF_BASE_US4
+#define AT91_USART5 AT572D940HF_BASE_US5
+
+/*
+ * Internal Memory.
+ */
+#define AT572D940HF_ROM_BASE 0x00400000		/* Internal ROM base address */
+#define AT572D940HF_ROM_SIZE SZ_32K		/* Internal ROM size (32Kb) */
+
+#define AT572D940HF_SRAM0_BASE 0x00100000	/* Internal SRAM 0 base address */
+#define AT572D940HF_SRAM0_SIZE SZ_16K		/* Internal SRAM 0 size (4Kb) */
+#define AT572D940HF_SRAM1_BASE 0x00200000	/* Internal SRAM 0 base address */
+#define AT572D940HF_SRAM1_SIZE SZ_16K		/* Internal SRAM 0 size (4Kb) */
+#define AT572D940HF_SRAM2_BASE 0x00300000	/* Internal SRAM 1 base address */
+#define AT572D940HF_SRAM2_SIZE SZ_16K		/* Internal SRAM 1 size (4Kb) */
+
+/* SDRAM */
+#define AT572D940HF_SDRAM_BASE 0x20000000
+
+/* USB Host */
+#define AT572D940HF_UHP_BASE 0x00500000		/* USB Host controller */
+
+#define AT91SAM9XE_FLASH_BASE 0x00200000	/* Internal FLASH base address */
+#define AT91SAM9XE_SRAM_BASE 0x00300000		/* Internal SRAM base address */
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf_matrix.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf_matrix.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf_matrix.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf_matrix.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9260_matrix.h
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9260 datasheet revision B.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9260_MATRIX_H
+#define AT91SAM9260_MATRIX_H
+
+#define AT91_MATRIX_MCFG0 (AT91_MATRIX + 0x00)		/* Master Configuration Register 0 */
+#define AT91_MATRIX_MCFG1 (AT91_MATRIX + 0x04)		/* Master Configuration Register 1 */
+#define AT91_MATRIX_MCFG2 (AT91_MATRIX + 0x08)		/* Master Configuration Register 2 */
+#define AT91_MATRIX_MCFG3 (AT91_MATRIX + 0x0C)		/* Master Configuration Register 3 */
+#define AT91_MATRIX_MCFG4 (AT91_MATRIX + 0x10)		/* Master Configuration Register 4 */
+#define AT91_MATRIX_MCFG5 (AT91_MATRIX + 0x14)		/* Master Configuration Register 5 */
+#define AT91_MATRIX_ULBT (7 << 0)			/* Undefined Length Burst Type */
+#define AT91_MATRIX_ULBT_INFINITE (0 << 0)
+#define AT91_MATRIX_ULBT_SINGLE (1 << 0)
+#define AT91_MATRIX_ULBT_FOUR (2 << 0)
+#define AT91_MATRIX_ULBT_EIGHT (3 << 0)
+#define AT91_MATRIX_ULBT_SIXTEEN (4 << 0)
+
+#define AT91_MATRIX_SCFG0 (AT91_MATRIX + 0x40)		/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1 (AT91_MATRIX + 0x44)		/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2 (AT91_MATRIX + 0x48)		/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3 (AT91_MATRIX + 0x4C)		/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4 (AT91_MATRIX + 0x50)		/* Slave Configuration Register 4 */
+#define AT91_MATRIX_SLOT_CYCLE (0xff << 0)		/* Maximum Number of Allowed Cycles for a Burst */
+#define AT91_MATRIX_DEFMSTR_TYPE (3 << 16)		/* Default Master Type */
+#define AT91_MATRIX_DEFMSTR_TYPE_NONE (0 << 16)
+#define AT91_MATRIX_DEFMSTR_TYPE_LAST (1 << 16)
+#define AT91_MATRIX_DEFMSTR_TYPE_FIXED (2 << 16)
+#define AT91_MATRIX_FIXED_DEFMSTR (7 << 18)		/* Fixed Index of Default Master */
+#define AT91_MATRIX_ARBT (3 << 24)			/* Arbitration Type */
+#define AT91_MATRIX_ARBT_ROUND_ROBIN (0 << 24)
+#define AT91_MATRIX_ARBT_FIXED_PRIORITY (1 << 24)
+
+#define AT91_MATRIX_PRAS0 (AT91_MATRIX + 0x80)		/* Priority Register A for Slave 0 */
+#define AT91_MATRIX_PRAS1 (AT91_MATRIX + 0x88)		/* Priority Register A for Slave 1 */
+#define AT91_MATRIX_PRAS2 (AT91_MATRIX + 0x90)		/* Priority Register A for Slave 2 */
+#define AT91_MATRIX_PRAS3 (AT91_MATRIX + 0x98)		/* Priority Register A for Slave 3 */
+#define AT91_MATRIX_PRAS4 (AT91_MATRIX + 0xA0)		/* Priority Register A for Slave 4 */
+#define AT91_MATRIX_M0PR (3 << 0)			/* Master 0 Priority */
+#define AT91_MATRIX_M1PR (3 << 4)			/* Master 1 Priority */
+#define AT91_MATRIX_M2PR (3 << 8)			/* Master 2 Priority */
+#define AT91_MATRIX_M3PR (3 << 12)			/* Master 3 Priority */
+#define AT91_MATRIX_M4PR (3 << 16)			/* Master 4 Priority */
+#define AT91_MATRIX_M5PR (3 << 20)			/* Master 5 Priority */
+
+#define AT91_MATRIX_MRCR (AT91_MATRIX + 0x100)		/* Master Remap Control Register */
+#define AT91_MATRIX_RCB0 (1 << 0)			/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define AT91_MATRIX_RCB1 (1 << 1)			/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+
+#define AT91_MATRIX_EBICSA (AT91_MATRIX + 0x11C)	/* EBI Chip Select Assignment Register */
+#define AT91_MATRIX_CS1A (1 << 1)			/* Chip Select 1 Assignment */
+#define AT91_MATRIX_CS1A_SMC (0 << 1)
+#define AT91_MATRIX_CS1A_SDRAMC (1 << 1)
+#define AT91_MATRIX_CS3A (1 << 3)			/* Chip Select 3 Assignment */
+#define AT91_MATRIX_CS3A_SMC (0 << 3)
+#define AT91_MATRIX_CS3A_SMC_SMARTMEDIA (1 << 3)
+#define AT91_MATRIX_CS4A (1 << 4)			/* Chip Select 4 Assignment */
+#define AT91_MATRIX_CS4A_SMC (0 << 4)
+#define AT91_MATRIX_CS4A_SMC_CF1 (1 << 4)
+#define AT91_MATRIX_CS5A (1 << 5)			/* Chip Select 5 Assignment */
+#define AT91_MATRIX_CS5A_SMC (0 << 5)
+#define AT91_MATRIX_CS5A_SMC_CF2 (1 << 5)
+#define AT91_MATRIX_DBPUC (1 << 8)			/* Data Bus Pull-up Configuration */
+#define AT91_MATRIX_VDDIOMSEL (1 << 16)			/* Memory voltage selection */
+#define AT91_MATRIX_VDDIOMSEL_1_8V (0 << 16)
+#define AT91_MATRIX_VDDIOMSEL_3_3V (1 << 16)
+
+#endif
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf_mc.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf_mc.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at572d940hf_mc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at572d940hf_mc.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,140 @@
+/*
+ * include/asm-arm/arch-at91/at91sam926x_mc.h
+ *
+ * Memory Controllers (SMC, SDRAMC) - System peripherals registers.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+*/
+
+#ifndef AT91SAM926x_MC_H
+#define AT91SAM926x_MC_H
+
+/* SDRAM Controller (SDRAMC) registers	*/
+#define AT91_SDRAMC_MR (AT91_SDRAMC + 0x00)		/* SDRAM Controller Mode Register */
+#define AT91_SDRAMC_MODE (0xf << 0)			/* Command Mode */
+#define AT91_SDRAMC_MODE_NORMAL 0
+#define AT91_SDRAMC_MODE_NOP 1
+#define AT91_SDRAMC_MODE_PRECHARGE 2
+#define AT91_SDRAMC_MODE_LMR 3
+#define AT91_SDRAMC_MODE_REFRESH 4
+#define AT91_SDRAMC_MODE_EXT_LMR 5
+#define AT91_SDRAMC_MODE_DEEP 6
+
+#define AT91_SDRAMC_TR (AT91_SDRAMC + 0x04)		/* SDRAM Controller Refresh Timer Register */
+#define AT91_SDRAMC_COUNT (0xfff << 0)			/* Refresh Timer Counter */
+
+#define AT91_SDRAMC_CR (AT91_SDRAMC + 0x08)		/* SDRAM Controller Configuration Register */
+#define AT91_SDRAMC_NC (3 << 0)				/* Number of Column Bits */
+#define AT91_SDRAMC_NC_8 (0 << 0)
+#define AT91_SDRAMC_NC_9 (1 << 0)
+#define AT91_SDRAMC_NC_10 (2 << 0)
+#define AT91_SDRAMC_NC_11 (3 << 0)
+#define AT91_SDRAMC_NR (3 << 2)				/* Number of Row Bits */
+#define AT91_SDRAMC_NR_11 (0 << 2)
+#define AT91_SDRAMC_NR_12 (1 << 2)
+#define AT91_SDRAMC_NR_13 (2 << 2)
+#define AT91_SDRAMC_NB (1 << 4)				/* Number of Banks */
+#define AT91_SDRAMC_NB_2 (0 << 4)
+#define AT91_SDRAMC_NB_4 (1 << 4)
+#define AT91_SDRAMC_CAS (3 << 5)			/* CAS Latency */
+#define AT91_SDRAMC_CAS_1 (1 << 5)
+#define AT91_SDRAMC_CAS_2 (2 << 5)
+#define AT91_SDRAMC_CAS_3 (3 << 5)
+#define AT91_SDRAMC_DBW (1 << 7)			/* Data Bus Width */
+#define AT91_SDRAMC_DBW_32 (0 << 7)
+#define AT91_SDRAMC_DBW_16 (1 << 7)
+#define AT91_SDRAMC_TWR (0xf << 8)			/* Write Recovery Delay */
+#define AT91_SDRAMC_TRC (0xf << 12)			/* Row Cycle Delay */
+#define AT91_SDRAMC_TRP (0xf << 16)			/* Row Precharge Delay */
+#define AT91_SDRAMC_TRCD (0xf << 20)			/* Row to Column Delay */
+#define AT91_SDRAMC_TRAS (0xf << 24)			/* Active to Precharge Delay */
+#define AT91_SDRAMC_TXSR (0xf << 28)			/* Exit Self Refresh to Active Delay */
+
+#define AT91_SDRAMC_LPR (AT91_SDRAMC + 0x10)		/* SDRAM Controller Low Power Register */
+#define AT91_SDRAMC_LPCB (3 << 0)			/* Low-power Configurations */
+#define AT91_SDRAMC_LPCB_DISABLE 0
+#define AT91_SDRAMC_LPCB_SELF_REFRESH 1
+#define AT91_SDRAMC_LPCB_POWER_DOWN 2
+#define AT91_SDRAMC_LPCB_DEEP_POWER_DOWN 3
+#define AT91_SDRAMC_PASR (7 << 4)			/* Partial Array Self Refresh */
+#define AT91_SDRAMC_TCSR (3 << 8)			/* Temperature Compensated Self Refresh */
+#define AT91_SDRAMC_DS (3 << 10)			/* Drive Strenght */
+#define AT91_SDRAMC_TIMEOUT (3 << 12)			/* Time to define when Low Power Mode is enabled */
+#define AT91_SDRAMC_TIMEOUT_0_CLK_CYCLES (0 << 12)
+#define AT91_SDRAMC_TIMEOUT_64_CLK_CYCLES (1 << 12)
+#define AT91_SDRAMC_TIMEOUT_128_CLK_CYCLES (2 << 12)
+
+#define AT91_SDRAMC_IER (AT91_SDRAMC + 0x14)		/* SDRAM Controller Interrupt Enable Register */
+#define AT91_SDRAMC_IDR (AT91_SDRAMC + 0x18)		/* SDRAM Controller Interrupt Disable Register */
+#define AT91_SDRAMC_IMR (AT91_SDRAMC + 0x1C)		/* SDRAM Controller Interrupt Mask Register */
+#define AT91_SDRAMC_ISR (AT91_SDRAMC + 0x20)		/* SDRAM Controller Interrupt Status Register */
+#define AT91_SDRAMC_RES (1 << 0)			/* Refresh Error Status */
+
+#define AT91_SDRAMC_MDR (AT91_SDRAMC + 0x24)		/* SDRAM Memory Device Register */
+#define AT91_SDRAMC_MD (3 << 0)				/* Memory Device Type */
+#define AT91_SDRAMC_MD_SDRAM 0
+#define AT91_SDRAMC_MD_LOW_POWER_SDRAM 1
+
+/* Static Memory Controller (SMC) registers */
+#define AT91_SMC_SETUP(n) (AT91_SMC + 0x00 + ((n)*0x10))/* Setup Register for CS n */
+#define AT91_SMC_NWESETUP (0x3f << 0)			/* NWE Setup Length */
+#define AT91_SMC_NWESETUP_(x) ((x) << 0)
+#define AT91_SMC_NCS_WRSETUP (0x3f << 8)		/* NCS Setup Length in Write Access */
+#define AT91_SMC_NCS_WRSETUP_(x) ((x) << 8)
+#define AT91_SMC_NRDSETUP (0x3f << 16)			/* NRD Setup Length */
+#define AT91_SMC_NRDSETUP_(x) ((x) << 16)
+#define AT91_SMC_NCS_RDSETUP (0x3f << 24)		/* NCS Setup Length in Read Access */
+#define AT91_SMC_NCS_RDSETUP_(x) ((x) << 24)
+
+#define AT91_SMC_PULSE(n) (AT91_SMC + 0x04 + ((n)*0x10))/* Pulse Register for CS n */
+#define AT91_SMC_NWEPULSE (0x7f << 0)			/* NWE Pulse Length */
+#define AT91_SMC_NWEPULSE_(x) ((x) << 0)
+#define AT91_SMC_NCS_WRPULSE (0x7f << 8)		/* NCS Pulse Length in Write Access */
+#define AT91_SMC_NCS_WRPULSE_(x)((x) << 8)
+#define AT91_SMC_NRDPULSE (0x7f << 16)			/* NRD Pulse Length */
+#define AT91_SMC_NRDPULSE_(x) ((x) << 16)
+#define AT91_SMC_NCS_RDPULSE (0x7f << 24)		/* NCS Pulse Length in Read Access */
+#define AT91_SMC_NCS_RDPULSE_(x)((x) << 24)
+
+#define AT91_SMC_CYCLE(n) (AT91_SMC + 0x08 + ((n)*0x10))/* Cycle Register for CS n */
+#define AT91_SMC_NWECYCLE (0x1ff << 0 )			/* Total Write Cycle Length */
+#define AT91_SMC_NWECYCLE_(x) ((x) << 0)
+#define AT91_SMC_NRDCYCLE (0x1ff << 16)			/* Total Read Cycle Length */
+#define AT91_SMC_NRDCYCLE_(x) ((x) << 16)
+
+#define AT91_SMC_MODE(n) (AT91_SMC + 0x0c + ((n)*0x10))	/* Mode Register for CS n */
+#define AT91_SMC_READMODE (1 << 0)			/* Read Mode */
+#define AT91_SMC_WRITEMODE (1 << 1)			/* Write Mode */
+#define AT91_SMC_EXNWMODE (3 << 4)			/* NWAIT Mode */
+#define AT91_SMC_EXNWMODE_DISABLE (0 << 4)
+#define AT91_SMC_EXNWMODE_FROZEN (2 << 4)
+#define AT91_SMC_EXNWMODE_READY (3 << 4)
+#define AT91_SMC_BAT (1 << 8)				/* Byte Access Type */
+#define AT91_SMC_BAT_SELECT (0 << 8)
+#define AT91_SMC_BAT_WRITE (1 << 8)
+#define AT91_SMC_DBW (3 << 12)				/* Data Bus Width */
+#define AT91_SMC_DBW_8 (0 << 12)
+#define AT91_SMC_DBW_16 (1 << 12)
+#define AT91_SMC_DBW_32 (2 << 12)
+#define AT91_SMC_TDF (0xf << 16)			/* Data Float Time. */
+#define AT91_SMC_TDF_(x) ((x) << 16)
+#define AT91_SMC_TDFMODE (1 << 20)			/* TDF Optimization - Enabled */
+#define AT91_SMC_PMEN (1 << 24)				/* Page Mode Enabled */
+#define AT91_SMC_PS (3 << 28)				/* Page Size */
+#define AT91_SMC_PS_4 (0 << 28)
+#define AT91_SMC_PS_8 (1 << 28)
+#define AT91_SMC_PS_16 (2 << 28)
+#define AT91_SMC_PS_32 (3 << 28)
+
+#if defined(AT91_SMC1)					/* The AT91SAM9263 has 2 Static Memory contollers */
+#define AT91_SMC1_SETUP(n) (AT91_SMC1 + 0x00 + ((n)*0x10))	/* Setup Register for CS n */
+#define AT91_SMC1_PULSE(n) (AT91_SMC1 + 0x04 + ((n)*0x10))	/* Pulse Register for CS n */
+#define AT91_SMC1_CYCLE(n) (AT91_SMC1 + 0x08 + ((n)*0x10))	/* Cycle Register for CS n */
+#define AT91_SMC1_MODE(n)  (AT91_SMC1 + 0x0c + ((n)*0x10))	/* Mode Register for CS n */
+#endif
+
+#endif
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_aic.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_aic.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_aic.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_aic.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ * include/asm-arm/arch-at572d940/at91_aic.h
+ *
+ * Copyright (C) ATMEL
+ *
+ * Advanced Interrupt Controller (AIC).
+ * Based on AT572D940 datasheet.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define AIC_BASE 0xfffff000
+
+#define AIC_SMR0 0x0
+#define AIC_SVR0 0x80
+#define AIC_IVR 0x100
+#define AIC_FIQ 0x104
+#define AIC_ISR 0x108
+#define AIC_IPR 0x10c
+#define AIC_IMR 0x110
+#define AIC_ICR 0x114
+#define AIC_IECR 0x120
+#define AIC_IDCR 0x124
+#define AIC_ICCR 0x128
+#define AIC_ISCR 0x12c
+#define AIC_EOICR 0x130
+#define AIC_SPU 0x134
+
+#define AIC_SMR(n) \
+	((unsigned long) (((unsigned long*) AIC_SMR0) + (n)))
+#define AIC_SVR(n) \
+	((unsigned long) (((unsigned long*) AIC_SVR0) + (n)))
+
+#define AIC_WRITE(reg,value) \
+	(*((volatile unsigned long*) (AIC_BASE + (reg))) = value)
+#define AIC_READ(reg,value) \
+	(value = *((volatile unsigned long*) (AIC_BASE + (reg))))
+
+#define AIC_REG(reg) \
+	(*((volatile unsigned long*) (AIC_BASE + (reg))))
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pio.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pio.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pio.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * include/asm-arm/arch-at91/at91_pio.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Parallel I/O Controller (PIO) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PIO_H
+#define AT91_PIO_H
+
+#include <asm/arch/at572d940hf.h>
+
+#define PIO_PER 0x00		/* Enable Register			*/
+#define PIO_PDR 0x04		/* Disable Register			*/
+#define PIO_PSR 0x08		/* Status Register			*/
+#define PIO_OER 0x10		/* Output Enable Register		*/
+#define PIO_ODR 0x14		/* Output Disable Register		*/
+#define PIO_OSR 0x18		/* Output Status Register		*/
+#define PIO_IFER 0x20		/* Glitch Input Filter Enable		*/
+#define PIO_IFDR 0x24		/* Glitch Input Filter Disable		*/
+#define PIO_IFSR 0x28		/* Glitch Input Filter Status		*/
+#define PIO_SODR 0x30		/* Set Output Data Register		*/
+#define PIO_CODR 0x34		/* Clear Output Data Register		*/
+#define PIO_ODSR 0x38		/* Output Data Status Register		*/
+#define PIO_PDSR 0x3c		/* Pin Data Status Register		*/
+#define PIO_IER 0x40		/* Interrupt Enable Register		*/
+#define PIO_IDR 0x44		/* Interrupt Disable Register		*/
+#define PIO_IMR 0x48		/* Interrupt Mask Register		*/
+#define PIO_ISR 0x4c		/* Interrupt Status Register		*/
+#define PIO_MDER 0x50		/* Multi-driver Enable Register		*/
+#define PIO_MDDR 0x54		/* Multi-driver Disable Register	*/
+#define PIO_MDSR 0x58		/* Multi-driver Status Register		*/
+#define PIO_PUDR 0x60		/* Pull-up Disable Register		*/
+#define PIO_PUER 0x64		/* Pull-up Enable Register		*/
+#define PIO_PUSR 0x68		/* Pull-up Status Register		*/
+#define PIO_ASR 0x70		/* Peripheral A Select Register		*/
+#define PIO_BSR 0x74		/* Peripheral B Select Register		*/
+#define PIO_ABSR 0x78		/* AB Status Register			*/
+#define PIO_OWER 0xa0		/* Output Write Enable Register		*/
+#define PIO_OWDR 0xa4		/* Output Write Disable Register	*/
+#define PIO_OWSR 0xa8		/* Output Write Status Register		*/
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pit.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pit.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pit.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pit.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * include/asm-arm/arch-at91/at91_pit.h
+ *
+ * Periodic Interval Timer (PIT) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PIT_H
+#define AT91_PIT_H
+
+#define AT91_PIT_MR (AT91_PIT + 0x00)		/* Mode Register */
+#define AT91_PIT_PITIEN (1 << 25)		/* Timer Interrupt Enable */
+#define AT91_PIT_PITEN (1 << 24)		/* Timer Enabled */
+#define AT91_PIT_PIV (0xfffff)			/* Periodic Interval Value */
+
+#define AT91_PIT_SR (AT91_PIT + 0x04)		/* Status Register */
+#define AT91_PIT_PITS (1 << 0)			/* Timer Status */
+
+#define AT91_PIT_PIVR (AT91_PIT + 0x08)		/* Periodic Interval Value Register */
+#define AT91_PIT_PIIR (AT91_PIT + 0x0c)		/* Periodic Interval Image Register */
+#define AT91_PIT_PICNT (0xfff << 20)		/* Interval Counter */
+#define AT91_PIT_CPIV (0xfffff)			/* Inverval Value */
+
+#endif
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pmc.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pmc.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_pmc.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ * include/asm-arm/arch-at91/at91_pmc.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Power Management Controller (PMC) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PMC_H
+#define AT91_PMC_H
+
+#define AT91_PMC_SCER (AT91_PMC + 0x00)		/* System Clock Enable Register */
+#define AT91_PMC_SCDR (AT91_PMC + 0x04)		/* System Clock Disable Register */
+
+#define AT91_PMC_SCSR (AT91_PMC + 0x08)		/* System Clock Status Register */
+#define AT91_PMC_PCK (1 << 0)			/* Processor Clock */
+#define AT91RM9200_PMC_UDP (1 << 1)		/* USB Devcice Port Clock [AT91RM9200 only] */
+#define AT91RM9200_PMC_MCKUDP (1 << 2)		/* USB Device Port Master Clock Automatic Disable on Suspend [AT91RM9200 only] */
+#define AT91RM9200_PMC_UHP (1 << 4)		/* USB Host Port Clock [AT91RM9200 only] */
+#define AT91SAM926x_PMC_UHP (1 << 6)		/* USB Host Port Clock [AT91SAM926x only] */
+#define AT91CAP9_PMC_UHP (1 << 6)		/* USB Host Port Clock [AT91CAP9 only] */
+#define AT572D940HF_PMC_UHP (1 << 6)		/* USB Host Port Clock [AT572D940HF] */
+#define AT572D940HF_PMC_UDP (1 << 7)		/* USB Device Port Clock [AT572D940HF] */
+#define AT91SAM926x_PMC_UDP (1 << 7)		/* USB Decice Port Clock [AT91SAM926x only] */
+#define AT91_PMC_PCK0 (1 << 8)			/* Programmable Clock 0 */
+#define AT91_PMC_PCK1 (1 << 9)			/* Programmable Clock 1 */
+#define AT91_PMC_PCK2 (1 << 10)			/* Programmable Clock 2 */
+#define AT91_PMC_PCK3 (1 << 11)			/* Programmable Clock 3 */
+#define AT91_PMC_HCK0 (1 << 16)			/* AHB Clock (USB host) [AT91SAM9261 only] */
+#define AT91_PMC_HCK1 (1 << 17)			/* AHB Clock (LCD) [AT91SAM9261 only] */
+
+#define AT91_PMC_PCER (AT91_PMC + 0x10)		/* Peripheral Clock Enable Register */
+#define AT91_PMC_PCDR (AT91_PMC + 0x14)		/* Peripheral Clock Disable Register */
+#define AT91_PMC_PCSR (AT91_PMC + 0x18)		/* Peripheral Clock Status Register */
+
+#define AT91_CKGR_UCKR (AT91_PMC + 0x1C)	/* UTMI Clock Register [SAM9RL, CAP9] */
+
+#define AT91_CKGR_MOR (AT91_PMC + 0x20)		/* Main Oscillator Register [not on SAM9RL] */
+#define AT91_PMC_MOSCEN (1 << 0)		/* Main Oscillator Enable */
+#define AT91_PMC_OSCBYPASS (1 << 1)		/* Oscillator Bypass [AT91SAM926x only] */
+#define AT91_PMC_OSCOUNT (0xff << 8)		/* Main Oscillator Start-up Time */
+
+#define AT91_CKGR_MCFR (AT91_PMC + 0x24)	/* Main Clock Frequency Register */
+#define AT91_PMC_MAINF (0xffff << 0)		/* Main Clock Frequency */
+#define AT91_PMC_MAINRDY (1 << 16)		/* Main Clock Ready */
+
+#define AT91_CKGR_PLLAR (AT91_PMC + 0x28)	/* PLL A Register */
+#define AT91_CKGR_PLLBR (AT91_PMC + 0x2c)	/* PLL B Register */
+#define AT91_PMC_DIV (0xff << 0)		/* Divider */
+#define AT91_PMC_PLLCOUNT (0x3f << 8)		/* PLL Counter */
+#define AT91_PMC_OUT (3 << 14)			/* PLL Clock Frequency Range */
+#define AT91_PMC_MUL (0x7ff << 16)		/* PLL Multiplier */
+#define AT91_PMC_USBDIV (3 << 28)		/* USB Divisor (PLLB only) */
+#define AT91_PMC_USBDIV_1 (0 << 28)
+#define AT91_PMC_USBDIV_2 (1 << 28)
+#define AT91_PMC_USBDIV_4 (2 << 28)
+#define AT91_PMC_USB96M (1 << 28)		/* Divider by 2 Enable (PLLB only) */
+
+#define AT91_PMC_MCKR (AT91_PMC + 0x30)		/* Master Clock Register */
+#define AT91_PMC_CSS (3 << 0)			/* Master Clock Selection */
+#define AT91_PMC_CSS_SLOW (0 << 0)
+#define AT91_PMC_CSS_MAIN (1 << 0)
+#define AT91_PMC_CSS_PLLA (2 << 0)
+#define AT91_PMC_CSS_PLLB (3 << 0)
+#define AT91_PMC_PRES (7 << 2)			/* Master Clock Prescaler */
+#define AT91_PMC_PRES_1 (0 << 2)
+#define AT91_PMC_PRES_2 (1 << 2)
+#define AT91_PMC_PRES_4 (2 << 2)
+#define AT91_PMC_PRES_8 (3 << 2)
+#define AT91_PMC_PRES_16 (4 << 2)
+#define AT91_PMC_PRES_32 (5 << 2)
+#define AT91_PMC_PRES_64 (6 << 2)
+#define AT91_PMC_MDIV (3 << 8)			/* Master Clock Division */
+#define AT91_PMC_MDIV_1 (0 << 8)
+#define AT91_PMC_MDIV_2 (1 << 8)
+#define AT91_PMC_MDIV_3 (2 << 8)
+#define AT91_PMC_MDIV_4 (3 << 8)
+
+#define AT91_PMC_PCKR(n) (AT91_PMC + 0x40 + ((n) * 4)) /* Programmable Clock 0-3 Registers */
+
+#define AT91_PMC_IER (AT91_PMC + 0x60)		/* Interrupt Enable Register */
+#define AT91_PMC_IDR (AT91_PMC + 0x64)		/* Interrupt Disable Register */
+#define AT91_PMC_SR (AT91_PMC + 0x68)		/* Status Register */
+#define AT91_PMC_MOSCS (1 << 0)			/* MOSCS Flag */
+#define AT91_PMC_LOCKA (1 << 1)			/* PLLA Lock */
+#define AT91_PMC_LOCKB (1 << 2)			/* PLLB Lock */
+#define AT91_PMC_MCKRDY (1 << 3)		/* Master Clock */
+#define AT91_PMC_PCK0RDY (1 << 8)		/* Programmable Clock 0 */
+#define AT91_PMC_PCK1RDY (1 << 9)		/* Programmable Clock 1 */
+#define AT91_PMC_PCK2RDY (1 << 10)		/* Programmable Clock 2 */
+#define AT91_PMC_PCK3RDY (1 << 11)		/* Programmable Clock 3 */
+#define AT91_PMC_IMR (AT91_PMC + 0x6c)		/* Interrupt Mask Register */
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_rstc.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_rstc.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_rstc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_rstc.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91/at91_rstc.h
+ *
+ * Reset Controller (RSTC) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_RSTC_H
+#define AT91_RSTC_H
+
+#define AT91_RSTC_CR (AT91_RSTC + 0x00)		/* Reset Controller Control Register */
+#define AT91_RSTC_PROCRST (1 << 0)		/* Processor Reset */
+#define AT91_RSTC_PERRST (1 << 2)		/* Peripheral Reset */
+#define AT91_RSTC_EXTRST (1 << 3)		/* External Reset */
+#define AT91_RSTC_KEY (0xa5 << 24)		/* KEY Password */
+
+#define AT91_RSTC_SR (AT91_RSTC + 0x04)		/* Reset Controller Status Register */
+#define AT91_RSTC_URSTS (1 << 0)		/* User Reset Status */
+#define AT91_RSTC_RSTTYP (7 << 8)		/* Reset Type */
+#define AT91_RSTC_RSTTYP_GENERAL (0 << 8)
+#define AT91_RSTC_RSTTYP_WAKEUP (1 << 8)
+#define AT91_RSTC_RSTTYP_WATCHDOG (2 << 8)
+#define AT91_RSTC_RSTTYP_SOFTWARE (3 << 8)
+#define AT91_RSTC_RSTTYP_USER (4 << 8)
+#define AT91_RSTC_NRSTL (1 << 16)		/* NRST Pin Level */
+#define AT91_RSTC_SRCMP (1 << 17)		/* Software Reset Command in Progress */
+
+#define AT91_RSTC_MR (AT91_RSTC + 0x08)		/* Reset Controller Mode Register */
+#define AT91_RSTC_URSTEN (1 << 0)		/* User Reset Enable */
+#define AT91_RSTC_URSTIEN (1 << 4)		/* User Reset Interrupt Enable */
+#define AT91_RSTC_ERSTL (0xf << 8)		/* External Reset Length */
+
+#endif
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_spi.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_spi.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/at91_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/at91_spi.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * include/asm-arm/arch-at91/at91_spi.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Serial Peripheral Interface (SPI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_SPI_H
+#define AT91_SPI_H
+
+#define AT91_SPI_CR 0x00		/* Control Register */
+#define AT91_SPI_SPIEN (1 << 0)		/* SPI Enable */
+#define AT91_SPI_SPIDIS (1 << 1)	/* SPI Disable */
+#define AT91_SPI_SWRST (1 << 7)		/* SPI Software Reset */
+#define AT91_SPI_LASTXFER (1 << 24)	/* Last Transfer [SAM9261 only] */
+
+#define AT91_SPI_MR 0x04		/* Mode Register */
+#define AT91_SPI_MSTR (1 << 0)		/* Master/Slave Mode */
+#define AT91_SPI_PS (1 << 1)		/* Peripheral Select */
+#define AT91_SPI_PS_FIXED (0 << 1)
+#define AT91_SPI_PS_VARIABLE (1 << 1)
+#define AT91_SPI_PCSDEC (1 << 2)	/* Chip Select Decode */
+#define AT91_SPI_DIV32 (1 << 3)		/* Clock Selection [AT91RM9200 only] */
+#define AT91_SPI_MODFDIS (1 << 4)	/* Mode Fault Detection */
+#define AT91_SPI_LLB (1 << 7)		/* Local Loopback Enable */
+#define AT91_SPI_PCS (0xf << 16)	/* Peripheral Chip Select */
+#define AT91_SPI_DLYBCS (0xff << 24)	/* Delay Between Chip Selects */
+
+#define AT91_SPI_RDR 0x08		/* Receive Data Register */
+#define AT91_SPI_RD (0xffff << 0)	/* Receive Data */
+#define AT91_SPI_PCS (0xf << 16)	/* Peripheral Chip Select */
+
+#define AT91_SPI_TDR 0x0c		/* Transmit Data Register */
+#define AT91_SPI_TD (0xffff << 0)	/* Transmit Data */
+#define AT91_SPI_PCS (0xf << 16)	/* Peripheral Chip Select */
+#define AT91_SPI_LASTXFER (1 << 24)	/* Last Transfer [SAM9261 only] */
+
+#define AT91_SPI_SR 0x10		/* Status Register */
+#define AT91_SPI_RDRF (1 << 0)		/* Receive Data Register Full */
+#define AT91_SPI_TDRE (1 << 1)		/* Transmit Data Register Full */
+#define AT91_SPI_MODF (1 << 2)		/* Mode Fault Error */
+#define AT91_SPI_OVRES (1 << 3)		/* Overrun Error Status */
+#define AT91_SPI_ENDRX (1 << 4)		/* End of RX buffer */
+#define AT91_SPI_ENDTX (1 << 5)		/* End of TX buffer */
+#define AT91_SPI_RXBUFF (1 << 6)	/* RX Buffer Full */
+#define AT91_SPI_TXBUFE (1 << 7)	/* TX Buffer Empty */
+#define AT91_SPI_NSSR (1 << 8)		/* NSS Rising [SAM9261 only] */
+#define AT91_SPI_TXEMPTY (1 << 9)	/* Transmission Register Empty [SAM9261 only] */
+#define AT91_SPI_SPIENS (1 << 16)	/* SPI Enable Status */
+
+#define AT91_SPI_IER 0x14		/* Interrupt Enable Register */
+#define AT91_SPI_IDR 0x18		/* Interrupt Disable Register */
+#define AT91_SPI_IMR 0x1c		/* Interrupt Mask Register */
+
+#define AT91_SPI_CSR(n) (0x30 + ((n) * 4))/* Chip Select Registers 0-3 */
+#define AT91_SPI_CPOL (1 << 0)		/* Clock Polarity */
+#define AT91_SPI_NCPHA (1 << 1)		/* Clock Phase */
+#define AT91_SPI_CSAAT (1 << 3)		/* Chip Select Active After Transfer [SAM9261 only] */
+#define AT91_SPI_BITS (0xf << 4)	/* Bits Per Transfer */
+#define AT91_SPI_BITS_8 (0 << 4)
+#define AT91_SPI_BITS_9 (1 << 4)
+#define AT91_SPI_BITS_10 (2 << 4)
+#define AT91_SPI_BITS_11 (3 << 4)
+#define AT91_SPI_BITS_12 (4 << 4)
+#define AT91_SPI_BITS_13 (5 << 4)
+#define AT91_SPI_BITS_14 (6 << 4)
+#define AT91_SPI_BITS_15 (7 << 4)
+#define AT91_SPI_BITS_16 (8 << 4)
+#define AT91_SPI_SCBR (0xff << 8)	/* Serial Clock Baud Rate */
+#define AT91_SPI_DLYBS (0xff << 16)	/* Delay before SPCK */
+#define AT91_SPI_DLYBCT (0xff << 24)	/* Delay between Consecutive Transfers */
+
+#define AT91_SPI_RPR 0x0100		/* Receive Pointer Register */
+
+#define AT91_SPI_RCR 0x0104		/* Receive Counter Register */
+
+#define AT91_SPI_TPR 0x0108		/* Transmit Pointer Register */
+
+#define AT91_SPI_TCR 0x010c		/* Transmit Counter Register */
+
+#define AT91_SPI_RNPR 0x0110		/* Receive Next Pointer Register */
+
+#define AT91_SPI_RNCR 0x0114		/* Receive Next Counter Register */
+
+#define AT91_SPI_TNPR 0x0118		/* Transmit Next Pointer Register */
+
+#define AT91_SPI_TNCR 0x011c		/* Transmit Next Counter Register */
+
+#define AT91_SPI_PTCR 0x0120		/* PDC Transfer Control Register */
+#define AT91_SPI_RXTEN (0x1 << 0)	/* Receiver Transfer Enable */
+#define AT91_SPI_RXTDIS (0x1 << 1)	/* Receiver Transfer Disable */
+#define AT91_SPI_TXTEN (0x1 << 8)	/* Transmitter Transfer Enable */
+#define AT91_SPI_TXTDIS (0x1 << 9)	/* Transmitter Transfer Disable */
+
+#define AT91_SPI_PTSR 0x0124		/* PDC Transfer Status Register */
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/clk.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/clk.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/clk.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/clk.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+ * (C) Copyright 2007
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_ARM_ARCH_CLK_H__
+#define __ASM_ARM_ARCH_CLK_H__
+
+#include <asm/arch/hardware.h>
+
+static inline unsigned long get_macb_pclk_rate(unsigned int dev_id)
+{
+	return AT91_MASTER_CLOCK;
+}
+
+static inline unsigned long get_usart_clk_rate(unsigned int dev_id)
+{
+	return AT91_MASTER_CLOCK;
+}
+
+static inline unsigned long get_mci_clk_rate(void)
+{
+	return AT91_MASTER_CLOCK;
+}
+
+#endif /* __ASM_ARM_ARCH_CLK_H__ */
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/gpio.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/gpio.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/gpio.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,367 @@
+/*
+ * include/asm-arm/arch-at91/gpio.h
+ *
+ * Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91_GPIO_H
+#define __ASM_ARCH_AT91_GPIO_H
+
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/at91_pio.h>
+
+#define PIN_BASE 32
+
+#define MAX_GPIO_BANKS 5
+
+/* these pin numbers double as IRQ numbers, like AT91xxx_ID_* values */
+
+#define AT91_PIN_PA0 (PIN_BASE + 0x00 + 0)
+#define AT91_PIN_PA1 (PIN_BASE + 0x00 + 1)
+#define AT91_PIN_PA2 (PIN_BASE + 0x00 + 2)
+#define AT91_PIN_PA3 (PIN_BASE + 0x00 + 3)
+#define AT91_PIN_PA4 (PIN_BASE + 0x00 + 4)
+#define AT91_PIN_PA5 (PIN_BASE + 0x00 + 5)
+#define AT91_PIN_PA6 (PIN_BASE + 0x00 + 6)
+#define AT91_PIN_PA7 (PIN_BASE + 0x00 + 7)
+#define AT91_PIN_PA8 (PIN_BASE + 0x00 + 8)
+#define AT91_PIN_PA9 (PIN_BASE + 0x00 + 9)
+#define AT91_PIN_PA10 (PIN_BASE + 0x00 + 10)
+#define AT91_PIN_PA11 (PIN_BASE + 0x00 + 11)
+#define AT91_PIN_PA12 (PIN_BASE + 0x00 + 12)
+#define AT91_PIN_PA13 (PIN_BASE + 0x00 + 13)
+#define AT91_PIN_PA14 (PIN_BASE + 0x00 + 14)
+#define AT91_PIN_PA15 (PIN_BASE + 0x00 + 15)
+#define AT91_PIN_PA16 (PIN_BASE + 0x00 + 16)
+#define AT91_PIN_PA17 (PIN_BASE + 0x00 + 17)
+#define AT91_PIN_PA18 (PIN_BASE + 0x00 + 18)
+#define AT91_PIN_PA19 (PIN_BASE + 0x00 + 19)
+#define AT91_PIN_PA20 (PIN_BASE + 0x00 + 20)
+#define AT91_PIN_PA21 (PIN_BASE + 0x00 + 21)
+#define AT91_PIN_PA22 (PIN_BASE + 0x00 + 22)
+#define AT91_PIN_PA23 (PIN_BASE + 0x00 + 23)
+#define AT91_PIN_PA24 (PIN_BASE + 0x00 + 24)
+#define AT91_PIN_PA25 (PIN_BASE + 0x00 + 25)
+#define AT91_PIN_PA26 (PIN_BASE + 0x00 + 26)
+#define AT91_PIN_PA27 (PIN_BASE + 0x00 + 27)
+#define AT91_PIN_PA28 (PIN_BASE + 0x00 + 28)
+#define AT91_PIN_PA29 (PIN_BASE + 0x00 + 29)
+#define AT91_PIN_PA30 (PIN_BASE + 0x00 + 30)
+#define AT91_PIN_PA31 (PIN_BASE + 0x00 + 31)
+
+#define AT91_PIN_PB0 (PIN_BASE + 0x20 + 0)
+#define AT91_PIN_PB1 (PIN_BASE + 0x20 + 1)
+#define AT91_PIN_PB2 (PIN_BASE + 0x20 + 2)
+#define AT91_PIN_PB3 (PIN_BASE + 0x20 + 3)
+#define AT91_PIN_PB4 (PIN_BASE + 0x20 + 4)
+#define AT91_PIN_PB5 (PIN_BASE + 0x20 + 5)
+#define AT91_PIN_PB6 (PIN_BASE + 0x20 + 6)
+#define AT91_PIN_PB7 (PIN_BASE + 0x20 + 7)
+#define AT91_PIN_PB8 (PIN_BASE + 0x20 + 8)
+#define AT91_PIN_PB9 (PIN_BASE + 0x20 + 9)
+#define AT91_PIN_PB10 (PIN_BASE + 0x20 + 10)
+#define AT91_PIN_PB11 (PIN_BASE + 0x20 + 11)
+#define AT91_PIN_PB12 (PIN_BASE + 0x20 + 12)
+#define AT91_PIN_PB13 (PIN_BASE + 0x20 + 13)
+#define AT91_PIN_PB14 (PIN_BASE + 0x20 + 14)
+#define AT91_PIN_PB15 (PIN_BASE + 0x20 + 15)
+#define AT91_PIN_PB16 (PIN_BASE + 0x20 + 16)
+#define AT91_PIN_PB17 (PIN_BASE + 0x20 + 17)
+#define AT91_PIN_PB18 (PIN_BASE + 0x20 + 18)
+#define AT91_PIN_PB19 (PIN_BASE + 0x20 + 19)
+#define AT91_PIN_PB20 (PIN_BASE + 0x20 + 20)
+#define AT91_PIN_PB21 (PIN_BASE + 0x20 + 21)
+#define AT91_PIN_PB22 (PIN_BASE + 0x20 + 22)
+#define AT91_PIN_PB23 (PIN_BASE + 0x20 + 23)
+#define AT91_PIN_PB24 (PIN_BASE + 0x20 + 24)
+#define AT91_PIN_PB25 (PIN_BASE + 0x20 + 25)
+#define AT91_PIN_PB26 (PIN_BASE + 0x20 + 26)
+#define AT91_PIN_PB27 (PIN_BASE + 0x20 + 27)
+#define AT91_PIN_PB28 (PIN_BASE + 0x20 + 28)
+#define AT91_PIN_PB29 (PIN_BASE + 0x20 + 29)
+#define AT91_PIN_PB30 (PIN_BASE + 0x20 + 30)
+#define AT91_PIN_PB31 (PIN_BASE + 0x20 + 31)
+
+#define AT91_PIN_PC0 (PIN_BASE + 0x40 + 0)
+#define AT91_PIN_PC1 (PIN_BASE + 0x40 + 1)
+#define AT91_PIN_PC2 (PIN_BASE + 0x40 + 2)
+#define AT91_PIN_PC3 (PIN_BASE + 0x40 + 3)
+#define AT91_PIN_PC4 (PIN_BASE + 0x40 + 4)
+#define AT91_PIN_PC5 (PIN_BASE + 0x40 + 5)
+#define AT91_PIN_PC6 (PIN_BASE + 0x40 + 6)
+#define AT91_PIN_PC7 (PIN_BASE + 0x40 + 7)
+#define AT91_PIN_PC8 (PIN_BASE + 0x40 + 8)
+#define AT91_PIN_PC9 (PIN_BASE + 0x40 + 9)
+#define AT91_PIN_PC10 (PIN_BASE + 0x40 + 10)
+#define AT91_PIN_PC11 (PIN_BASE + 0x40 + 11)
+#define AT91_PIN_PC12 (PIN_BASE + 0x40 + 12)
+#define AT91_PIN_PC13 (PIN_BASE + 0x40 + 13)
+#define AT91_PIN_PC14 (PIN_BASE + 0x40 + 14)
+#define AT91_PIN_PC15 (PIN_BASE + 0x40 + 15)
+#define AT91_PIN_PC16 (PIN_BASE + 0x40 + 16)
+#define AT91_PIN_PC17 (PIN_BASE + 0x40 + 17)
+#define AT91_PIN_PC18 (PIN_BASE + 0x40 + 18)
+#define AT91_PIN_PC19 (PIN_BASE + 0x40 + 19)
+#define AT91_PIN_PC20 (PIN_BASE + 0x40 + 20)
+#define AT91_PIN_PC21 (PIN_BASE + 0x40 + 21)
+#define AT91_PIN_PC22 (PIN_BASE + 0x40 + 22)
+#define AT91_PIN_PC23 (PIN_BASE + 0x40 + 23)
+#define AT91_PIN_PC24 (PIN_BASE + 0x40 + 24)
+#define AT91_PIN_PC25 (PIN_BASE + 0x40 + 25)
+#define AT91_PIN_PC26 (PIN_BASE + 0x40 + 26)
+#define AT91_PIN_PC27 (PIN_BASE + 0x40 + 27)
+#define AT91_PIN_PC28 (PIN_BASE + 0x40 + 28)
+#define AT91_PIN_PC29 (PIN_BASE + 0x40 + 29)
+#define AT91_PIN_PC30 (PIN_BASE + 0x40 + 30)
+#define AT91_PIN_PC31 (PIN_BASE + 0x40 + 31)
+
+#define AT91_PIN_PD0 (PIN_BASE + 0x60 + 0)
+#define AT91_PIN_PD1 (PIN_BASE + 0x60 + 1)
+#define AT91_PIN_PD2 (PIN_BASE + 0x60 + 2)
+#define AT91_PIN_PD3 (PIN_BASE + 0x60 + 3)
+#define AT91_PIN_PD4 (PIN_BASE + 0x60 + 4)
+#define AT91_PIN_PD5 (PIN_BASE + 0x60 + 5)
+#define AT91_PIN_PD6 (PIN_BASE + 0x60 + 6)
+#define AT91_PIN_PD7 (PIN_BASE + 0x60 + 7)
+#define AT91_PIN_PD8 (PIN_BASE + 0x60 + 8)
+#define AT91_PIN_PD9 (PIN_BASE + 0x60 + 9)
+#define AT91_PIN_PD10 (PIN_BASE + 0x60 + 10)
+#define AT91_PIN_PD11 (PIN_BASE + 0x60 + 11)
+#define AT91_PIN_PD12 (PIN_BASE + 0x60 + 12)
+#define AT91_PIN_PD13 (PIN_BASE + 0x60 + 13)
+#define AT91_PIN_PD14 (PIN_BASE + 0x60 + 14)
+#define AT91_PIN_PD15 (PIN_BASE + 0x60 + 15)
+#define AT91_PIN_PD16 (PIN_BASE + 0x60 + 16)
+#define AT91_PIN_PD17 (PIN_BASE + 0x60 + 17)
+#define AT91_PIN_PD18 (PIN_BASE + 0x60 + 18)
+#define AT91_PIN_PD19 (PIN_BASE + 0x60 + 19)
+#define AT91_PIN_PD20 (PIN_BASE + 0x60 + 20)
+#define AT91_PIN_PD21 (PIN_BASE + 0x60 + 21)
+#define AT91_PIN_PD22 (PIN_BASE + 0x60 + 22)
+#define AT91_PIN_PD23 (PIN_BASE + 0x60 + 23)
+#define AT91_PIN_PD24 (PIN_BASE + 0x60 + 24)
+#define AT91_PIN_PD25 (PIN_BASE + 0x60 + 25)
+#define AT91_PIN_PD26 (PIN_BASE + 0x60 + 26)
+#define AT91_PIN_PD27 (PIN_BASE + 0x60 + 27)
+#define AT91_PIN_PD28 (PIN_BASE + 0x60 + 28)
+#define AT91_PIN_PD29 (PIN_BASE + 0x60 + 29)
+#define AT91_PIN_PD30 (PIN_BASE + 0x60 + 30)
+#define AT91_PIN_PD31 (PIN_BASE + 0x60 + 31)
+
+#define AT91_PIN_PE0 (PIN_BASE + 0x80 + 0)
+#define AT91_PIN_PE1 (PIN_BASE + 0x80 + 1)
+#define AT91_PIN_PE2 (PIN_BASE + 0x80 + 2)
+#define AT91_PIN_PE3 (PIN_BASE + 0x80 + 3)
+#define AT91_PIN_PE4 (PIN_BASE + 0x80 + 4)
+#define AT91_PIN_PE5 (PIN_BASE + 0x80 + 5)
+#define AT91_PIN_PE6 (PIN_BASE + 0x80 + 6)
+#define AT91_PIN_PE7 (PIN_BASE + 0x80 + 7)
+#define AT91_PIN_PE8 (PIN_BASE + 0x80 + 8)
+#define AT91_PIN_PE9 (PIN_BASE + 0x80 + 9)
+#define AT91_PIN_PE10 (PIN_BASE + 0x80 + 10)
+#define AT91_PIN_PE11 (PIN_BASE + 0x80 + 11)
+#define AT91_PIN_PE12 (PIN_BASE + 0x80 + 12)
+#define AT91_PIN_PE13 (PIN_BASE + 0x80 + 13)
+#define AT91_PIN_PE14 (PIN_BASE + 0x80 + 14)
+#define AT91_PIN_PE15 (PIN_BASE + 0x80 + 15)
+#define AT91_PIN_PE16 (PIN_BASE + 0x80 + 16)
+#define AT91_PIN_PE17 (PIN_BASE + 0x80 + 17)
+#define AT91_PIN_PE18 (PIN_BASE + 0x80 + 18)
+#define AT91_PIN_PE19 (PIN_BASE + 0x80 + 19)
+#define AT91_PIN_PE20 (PIN_BASE + 0x80 + 20)
+#define AT91_PIN_PE21 (PIN_BASE + 0x80 + 21)
+#define AT91_PIN_PE22 (PIN_BASE + 0x80 + 22)
+#define AT91_PIN_PE23 (PIN_BASE + 0x80 + 23)
+#define AT91_PIN_PE24 (PIN_BASE + 0x80 + 24)
+#define AT91_PIN_PE25 (PIN_BASE + 0x80 + 25)
+#define AT91_PIN_PE26 (PIN_BASE + 0x80 + 26)
+#define AT91_PIN_PE27 (PIN_BASE + 0x80 + 27)
+#define AT91_PIN_PE28 (PIN_BASE + 0x80 + 28)
+#define AT91_PIN_PE29 (PIN_BASE + 0x80 + 29)
+#define AT91_PIN_PE30 (PIN_BASE + 0x80 + 30)
+#define AT91_PIN_PE31 (PIN_BASE + 0x80 + 31)
+
+static unsigned long at91_pios[] = {
+	AT91_PIOA,
+	AT91_PIOB,
+	AT91_PIOC,
+#ifdef AT91_PIOD
+	AT91_PIOD,
+#ifdef AT91_PIOE
+	AT91_PIOE
+#endif
+#endif
+};
+
+static inline void *pin_to_controller(unsigned pin)
+{
+	pin -= PIN_BASE;
+	pin /= 32;
+	return (void *)(AT91_BASE_SYS + at91_pios[pin]);
+}
+
+static inline unsigned pin_to_mask(unsigned pin)
+{
+	pin -= PIN_BASE;
+	return 1 << (pin % 32);
+}
+
+/*
+ * mux the pin to the "GPIO" peripheral role.
+ */
+static inline int at91_set_GPIO_periph(unsigned pin, int use_pullup)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_PER);
+	return 0;
+}
+
+/*
+ * mux the pin to the "A" internal peripheral role.
+ */
+static inline int at91_set_A_periph(unsigned pin, int use_pullup)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_ASR);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+
+/*
+ * mux the pin to the "B" internal peripheral role.
+ */
+static inline int at91_set_B_periph(unsigned pin, int use_pullup)
+{
+ void *pio = pin_to_controller(pin);
+ unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_BSR);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral), and
+ * configure it for an input.
+ */
+static inline int at91_set_gpio_input(unsigned pin, int use_pullup)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(mask, pio + PIO_ODR);
+	__raw_writel(mask, pio + PIO_PER);
+	return 0;
+}
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral),
+ * and configure it for an output.
+ */
+static inline int at91_set_gpio_output(unsigned pin, int value)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + PIO_PUDR);
+	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+	__raw_writel(mask, pio + PIO_OER);
+	__raw_writel(mask, pio + PIO_PER);
+	return 0;
+}
+
+/*
+ * enable/disable the glitch filter; mostly used with IRQ handling.
+ */
+static inline int at91_set_deglitch(unsigned pin, int is_on)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + (is_on ? PIO_IFER : PIO_IFDR));
+	return 0;
+}
+
+/*
+ * enable/disable the multi-driver; This is only valid for output and
+ * allows the output pin to run as an open collector output.
+ */
+static inline int at91_set_multi_drive(unsigned pin, int is_on)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + (is_on ? PIO_MDER : PIO_MDDR));
+	return 0;
+}
+
+static inline int gpio_direction_input(unsigned pin)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	if (!(__raw_readl(pio + PIO_PSR) & mask))
+		return -EINVAL;
+	__raw_writel(mask, pio + PIO_ODR);
+	return 0;
+}
+
+static inline int gpio_direction_output(unsigned pin, int value)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	if (!(__raw_readl(pio + PIO_PSR) & mask))
+	return -EINVAL;
+	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+	__raw_writel(mask, pio + PIO_OER);
+	return 0;
+}
+
+/*
+ * assuming the pin is muxed as a gpio output, set its value.
+ */
+static inline int at91_set_gpio_value(unsigned pin, int value)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+
+	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+	return 0;
+}
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+static inline int at91_get_gpio_value(unsigned pin)
+{
+	void *pio = pin_to_controller(pin);
+	unsigned mask = pin_to_mask(pin);
+	u32 pdsr;
+
+	pdsr = __raw_readl(pio + PIO_PDSR);
+	return (pdsr & mask) != 0;
+}
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/hardware.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/hardware.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/hardware.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-at91/hardware.h
+ *
+ * Copyright (C) 2003 SAN People
+ * Copyright (C) 2003 ATMEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#if defined(CONFIG_AT572D940HF)
+#include <asm/arch/at572d940hf.h>
+#else
+#error "Unsupported AT572D940HF processor"
+#endif
+
+/*
+ * container_of - cast a member of a structure out to the containing structure
+ *
+ * @ptr: the pointer to the member.
+ * @type: the type of the container struct this is embedded in.
+ * @member: the name of the member within the struct.
+ */
+#define container_of(ptr, type, member) ({ \
+	const typeof(((type *)0)->member) *__mptr = (ptr); \
+	(type *)((char *)__mptr - offsetof(type, member)); })
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/interrupts.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/interrupts.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/interrupts.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/interrupts.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ * include/asm-arm/arch-at572d940/at91_aic.h
+ *
+ * Copyright (C) 2008 Antonio R. Costa
+ * Copyright (C) ATMEL
+ *
+ * Advanced Interrupt Controller (AIC).
+ * Based on AT572D940 datasheet.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __AT572D940_INTERRUPTS_H__
+#define __AT572D940_INTERRUPTS_H__
+
+#include <asm/arch/at91_aic.h>
+
+typedef void (*irq_handler_t) (unsigned long int);
+
+#define SET_IRQ_HANDLER(s,m,h) \
+do { \
+	AIC_WRITE(AIC_SMR(s),m); \
+	AIC_WRITE(AIC_SVR(s),h); \
+	AIC_WRITE(AIC_IECR,(1<<s)); \
+} while(0)
+
+#define RESET_IRQ_HANDLER(s) \
+do { \
+	AIC_WRITE(AIC_SMR(s),0); \
+	AIC_WRITE(AIC_SVR(s),0); \
+	AIC_WRITE(AIC_IDCR,(1<<s)); \
+} while(0)
+
+#define IRQ_ACKNOWLEDGE(n) AIC_WRITE(AIC_EOICR,(n))
+
+extern reset_irqs(void);
+#endif /* __AT572D940_INTERRUPTS_H__ */
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/io.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/io.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/io.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/io.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * include/asm-arm/arch-at91/io.h
+ *
+ * Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include <asm/io.h>
+
+static inline unsigned int at91_sys_read(unsigned int reg_offset)
+{
+	void *addr = (void *)AT91_BASE_SYS;
+
+	return __raw_readl(addr + reg_offset);
+}
+
+static inline void at91_sys_write(unsigned int reg_offset, unsigned long value)
+{
+	void *addr = (void *)AT91_BASE_SYS;
+
+	__raw_writel(value, addr + reg_offset);
+}
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/memory-map.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/memory-map.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/memory-map.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/memory-map.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop <at> leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_ARM_ARCH_MEMORYMAP_H__
+#define __ASM_ARM_ARCH_MEMORYMAP_H__
+
+#include <asm/arch/hardware.h>
+
+#define USART0_BASE AT91_USART0
+#define USART1_BASE AT91_USART1
+#define USART2_BASE AT91_USART2
+#define USART3_BASE (AT91_BASE_SYS + AT91_DBGU)
+
+#define AT572D940_SDRAM_BASE 0x20000000
+
+#endif /* __ASM_ARM_ARCH_MEMORYMAP_H__ */
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/mmc.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/mmc.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/mmc.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * Antonio R. Costa <antonio.costa <at> atmel.com>
+ * <costa.antonior <at> gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_AT572D940_MMC_H
+#define __ASM_AT572D940_MMC_H
+
+struct mmc_cid {
+	unsigned long	psn;
+	unsigned short	oid;
+	unsigned char	mid;
+	unsigned char	prv;
+	unsigned char	mdt;
+	char		pnm[7];
+};
+
+/*
+ * Bitfileds are ugly and not portable,
+ * So lets redefine the CSD
+ */
+
+typedef unsigned long mmc_csd_t[4];
+typedef unsigned long sd_csd_t[4];
+
+/*
+ * CSD ver: 2.0 manipulation macros
+ */
+
+/*
+ * Masks
+ */
+
+#define CSD_2x_VER_MASK			0x3
+#define CSD_2x_RSVD1_MASK		0x3f
+#define CSD_2x_TAAC_MASK		0xff
+#define CSD_2x_NSAC_MASK		0xff
+#define CSD_2x_TRANSPEED_MASK		0xff
+
+#define CSD_2x_CCC_MASK			0xfff
+#define CSD_2x_RBLEN_MASK		0xff
+#define CSD_2x_RBP_MASK			0x1
+#define CSD_2x_WBM_MASK			0x1
+#define CSD_2x_RBM_MASK			0x1
+#define CSD_2x_DSRIMP_MASK		0x1
+#define CSD_2x_RSVD2_MASK		0x3f
+#define CSD_2x_CSIZE_H_MASK		0x3f
+
+#define CSD_2x_CSIZE_MASK		0xffff
+#define CSD_2x_RSVD3_MASK		0x1
+#define CSD_2x_ERBL_MASK		0x1
+#define CSD_2x_SECSIZE_MASK		0x7f
+#define CSD_2x_WPGS_MASK		0x7f
+
+#define CSD_2x_WPGE_MASK		0x1
+#define CSD_2x_RSVD4_MASK		0x3
+#define CSD_2x_R2WF_MASK		0x7
+#define CSD_2x_WBL_MASK			0xf
+#define CSD_2x_WBP_MASK			0x1
+#define CSD_2x_RSVD5_MASK		0x1f
+#define CSD_2x_FFG_MASK			0x1
+#define CSD_2x_COPY_MASK		0x1
+#define CSD_2x_PWP_MASK			0x1
+#define CSD_2x_TWP_MASK			0x1
+#define CSD_2x_FF_MASK			0x3
+#define CSD_2x_RSVD6_MASK		0x3
+#define CSD_2x_CRC_MASK			0x7f
+#define CSD_2x_ONE_MASK			0x1
+
+/*
+ * Offsets inside the single word
+ */
+
+#define CSD_2x_VER_OFF			30
+#define CSD_2x_RSVD1_OFF		24
+#define CSD_2x_TAAC_OFF			16
+#define CSD_2x_NSAC_OFF			8
+#define CSD_2x_TRANSPEED_OFF		0
+
+#define CSD_2x_CCC_OFF			20
+#define CSD_2x_RBLEN_OFF		16
+#define CSD_2x_RBP_OFF			15
+#define CSD_2x_WBM_OFF			14
+#define CSD_2x_RBM_OFF			13
+#define CSD_2x_DSRIMP_OFF		12
+#define CSD_2x_RSVD2_OFF		6
+#define CSD_2x_CSIZE_H_OFF		0
+
+#define CSD_2x_CSIZE_OFF		16
+#define CSD_2x_RSVD3_OFF		15
+#define CSD_2x_ERBL_OFF			14
+#define CSD_2x_SECSIZE_OFF		7
+#define CSD_2x_WPGS_OFF			0
+
+#define CSD_2x_WPGE_OFF			31
+#define CSD_2x_RSVD4_OFF		29
+#define CSD_2x_R2WF_OFF			26
+#define CSD_2x_WBL_OFF			22
+#define CSD_2x_WBP_OFF			21
+#define CSD_2x_RSVD5_OFF		16
+#define CSD_2x_FFG_OFF			15
+#define CSD_2x_COPY_OFF			14
+#define CSD_2x_PWP_OFF			13
+#define CSD_2x_TWP_OFF			12
+#define CSD_2x_FF_OFF			10
+#define CSD_2x_RSVD6_OFF		8
+#define CSD_2x_CRC_OFF			1
+#define CSD_2x_ONE_OFF			0
+
+/*
+ * Word in which the field is placed
+ */
+
+#define CSD_2x_VER_W			0
+#define CSD_2x_RSVD1_W			0
+#define CSD_2x_TAAC_W			0
+#define CSD_2x_NSAC_W			0
+#define CSD_2x_TRANSPEED_W		0
+
+#define CSD_2x_CCC_W			1
+#define CSD_2x_RBLEN_W			1
+#define CSD_2x_RBP_W			1
+#define CSD_2x_WBM_W			1
+#define CSD_2x_RBM_W			1
+#define CSD_2x_DSRIMP_W			1
+#define CSD_2x_RSVD2_W			1
+#define CSD_2x_CSIZE_H_W		1
+
+#define CSD_2x_CSIZE_W			2
+#define CSD_2x_RSVD3_W			2
+#define CSD_2x_ERBL_W			2
+#define CSD_2x_SECSIZE_W		2
+#define CSD_2x_WPGS_W			2
+
+#define CSD_2x_WPGE_W			3
+#define CSD_2x_RSVD4_W			3
+#define CSD_2x_R2WF_W			3
+#define CSD_2x_WBL_W			3
+#define CSD_2x_WBP_W			3
+#define CSD_2x_RSVD5_W			3
+#define CSD_2x_FFG_W			3
+#define CSD_2x_COPY_W			3
+#define CSD_2x_PWP_W			3
+#define CSD_2x_TWP_W			3
+#define CSD_2x_FF_W			3
+#define CSD_2x_RSVD6_W			3
+#define CSD_2x_CRC_W			3
+#define CSD_2x_ONE_W			3
+
+/*
+ * ARC:
+ * Please note that CSIZE field crosses the word boundary,
+ * anyway since SD spec 2.0 states that the highest 6 bits
+ * shall be set to 0s the following macro still works
+ */
+
+#define SD_CSD_2x_CSIZE(pcsd) \
+	(((unsigned long long) SD_CSD_2x_FIELD(CSIZE,pcsd)) | \
+	(((unsigned long long) SD_CSD_2x_FIELD(CSIZE_H,pcsd)) << 16))
+
+#define SD_CSD_2x_FIELD(name,pcsd) \
+	((((unsigned long *)pcsd)[CSD_2x_## name ##_W] >> \
+	CSD_2x_## name ##_OFF) & CSD_2x_## name ##_MASK)
+
+#define CSD_1x_VER_MASK			0x3
+#define CSD_1x_RSVD1_MASK		0x3f
+#define CSD_1x_TAAC_MASK		0xff
+#define CSD_1x_NSAC_MASK		0xff
+#define CSD_1x_TRANSPEED_MASK		0xff
+
+#define CSD_1x_CCC_MASK			0xfff
+#define CSD_1x_RBLEN_MASK		0xf
+#define CSD_1x_RBP_MASK			0x1
+#define CSD_1x_WBM_MASK			0x1
+#define CSD_1x_RBM_MASK			0x1
+#define CSD_1x_DSRIMP_MASK		0x1
+#define CSD_1x_RSVD2_MASK		0x3
+#define CSD_1x_CSIZE_H_MASK		0x3ff
+
+#define CSD_1x_CSIZE_MASK		0x3
+#define CSD_1x_RCMIN_MASK		0x7
+#define CSD_1x_RCMAX_MASK		0x7
+#define CSD_1x_WCMIN_MASK		0x7
+#define CSD_1x_WCMAX_MASK		0x7
+#define CSD_1x_CSMUL_MASK		0x7
+#define CSD_1x_ESBE_MASK		0x1
+#define CSD_1x_SEC_SIZE_MASK		0x7ff
+
+#define CSD_1x_WPGS_MASK		0x7ff
+#define CSD_1x_WPGE_MASK		0x1
+#define CSD_1x_RSVD4_MASK		0x3
+#define CSD_1x_R2WF_MASK		0x7
+#define CSD_1x_WBL_MASK			0xf
+#define CSD_1x_WBP_MASK			0x1
+#define CSD_1x_RSVD5_MASK		0x1f
+#define CSD_1x_FFG_MASK			0x1
+#define CSD_1x_COPY_MASK		0x1
+#define CSD_1x_PWP_MASK			0x1
+#define CSD_1x_TWP_MASK			0x1
+#define CSD_1x_FF_MASK			0x3
+#define CSD_1x_RSVD6_MASK		0x3
+#define CSD_1x_CRC_MASK			0x7f
+#define CSD_1x_ONE_MASK			0x1
+
+/*
+ * Offsets inside the single word
+ */
+
+#define CSD_1x_VER_OFF			30
+#define CSD_1x_RSVD1_OFF		24
+#define CSD_1x_TAAC_OFF			16
+#define CSD_1x_NSAC_OFF			8
+#define CSD_1x_TRANSPEED_OFF		0
+
+#define CSD_1x_CCC_OFF			20
+#define CSD_1x_RBLEN_OFF		16
+#define CSD_1x_RBP_OFF			15
+#define CSD_1x_WBM_OFF			14
+#define CSD_1x_RBM_OFF			13
+#define CSD_1x_DSRIMP_OFF		12
+#define CSD_1x_RSVD2_OFF		10
+#define CSD_1x_CSIZE_H_OFF		0
+
+#define CSD_1x_CSIZE_OFF		30
+#define CSD_1x_RCMIN_OFF		27
+#define CSD_1x_RCMAX_OFF		24
+#define CSD_1x_WCMIN_OFF		21
+#define CSD_1x_WCMAX_OFF		18
+#define CSD_1x_CSMUL_OFF		15
+#define CSD_1x_ERBL_OFF			14
+#define CSD_1x_SECSIZE_OFF		7
+#define CSD_1x_WPGS_OFF			0
+
+#define CSD_1x_WPGE_OFF			31
+#define CSD_1x_RSVD4_OFF		29
+#define CSD_1x_R2WF_OFF			26
+#define CSD_1x_WBL_OFF			22
+#define CSD_1x_WBP_OFF			21
+#define CSD_1x_RSVD5_OFF		16
+#define CSD_1x_FFG_OFF			15
+#define CSD_1x_COPY_OFF			14
+#define CSD_1x_PWP_OFF			13
+#define CSD_1x_TWP_OFF			12
+#define CSD_1x_FF_OFF			10
+#define CSD_1x_RSVD6_OFF		8
+#define CSD_1x_CRC_OFF			1
+#define CSD_1x_ONE_OFF			0
+
+/*
+ * Word in which the field is placed
+ */
+
+#define CSD_1x_VER_W			0
+#define CSD_1x_RSVD1_W			0
+#define CSD_1x_TAAC_W			0
+#define CSD_1x_NSAC_W			0
+#define CSD_1x_TRANSPEED_W		0
+
+#define CSD_1x_CCC_W			1
+#define CSD_1x_RBLEN_W			1
+#define CSD_1x_RBP_W			1
+#define CSD_1x_WBM_W			1
+#define CSD_1x_RBM_W			1
+#define CSD_1x_DSRIMP_W			1
+#define CSD_1x_RSVD2_W			1
+#define CSD_1x_CSIZE_H_W		1
+
+#define CSD_1x_CSIZE_W			2
+#define CSD_1x_RCMIN_W			2
+#define CSD_1x_RCMAX_W			2
+#define CSD_1x_WCMIN_W			2
+#define CSD_1x_WCMAX_W			2
+#define CSD_1x_CSMUL_W			2
+#define CSD_1x_ERBL_W			2
+#define CSD_1x_SECSIZE_W		2
+#define CSD_1x_WPGS_W			2
+
+#define CSD_1x_WPGE_W			3
+#define CSD_1x_RSVD4_W			3
+#define CSD_1x_R2WF_W			3
+#define CSD_1x_WBL_W			3
+#define CSD_1x_WBP_W			3
+#define CSD_1x_RSVD5_W			3
+#define CSD_1x_FFG_W			3
+#define CSD_1x_COPY_W			3
+#define CSD_1x_PWP_W			3
+#define CSD_1x_TWP_W			3
+#define CSD_1x_FF_W			3
+#define CSD_1x_RSVD6_W			3
+#define CSD_1x_CRC_W			3
+#define CSD_1x_ONE_W			3
+
+#define SD_CSD_1x_FIELD(name,pcsd) \
+	((((unsigned long *)pcsd)[CSD_1x_## name ##_W] >> \
+	CSD_1x_## name ##_OFF) & CSD_1x_## name ##_MASK)
+
+#define SD_CSD_FIELD(name,pcsd) \
+	((SD_CSD_1x_FIELD(VER,pcsd) == 0x0) ? \
+	SD_CSD_1x_FIELD(name,pcsd) : SD_CSD_2x_FIELD(name,pcsd))
+
+#define SD_CSD_1x_CSIZE(pcsd) \
+	(SD_CSD_1x_FIELD(CSIZE,pcsd)+(SD_CSD_1x_FIELD(CSIZE_H,pcsd) << 2))
+
+#define SD_CSD_VER(pcsd) \
+	(SD_CSD_1x_FIELD(VER,pcsd))
+
+#define MMC_CSD_VER(pcsd) SD_CSD_VER(pcsd)
+#define MMC_CSD_FIELD(name,pcsd) SD_CSD_1x_FIELD(name,pcsd)
+
+/* MMC Command numbers */
+#define MMC_CMD_GO_IDLE_STATE		0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID		2
+#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_CMD_SD_SEND_RELATIVE_ADDR	3
+#define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_IF_COND			8
+#define MMC_CMD_SEND_CSD		9
+#define MMC_CMD_SEND_CID		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_SINGLE_BLOCK	17
+#define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_WRITE_BLOCK		24
+#define MMC_CMD_APP_CMD			55
+
+#define MMC_ACMD_BUS_WIDTH		6
+#define MMC_ACMD_SD_SEND_OP_COND	41
+
+#define R1_ILLEGAL_COMMAND		(1 << 22)
+#define R1_APP_CMD			(1 << 5)
+
+#endif /* __ASM_AT572D940_MMC_H */
+
diff -urN u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/timer.h u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/timer.h
--- u-boot-2009.01-rc1-0rig//include/asm-arm/arch-at572d940hf/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/asm-arm/arch-at572d940hf/timer.h	2009-01-04 22:02:50.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Author: Antonio R. Costa
+ */
+
+#ifndef _AT91_TIMER_H_
+#define _AT91_TIMER_H_
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//include/configs/at572d940hfeb.h u-boot-2009.01-rc1/include/configs/at572d940hfeb.h
--- u-boot-2009.01-rc1-0rig//include/configs/at572d940hfeb.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01-rc1/include/configs/at572d940hfeb.h	2009-01-04 22:04:18.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * (C) Copyright 2008
+ * Antonio R. Costa <antonio.costa <at> atmel.com>
+ * ATMEL CORP <www.atmel.com>
+ *
+ * Configuation settings for the AT572D940HFEB board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* ARM asynchronous clock */
+/* Miniloader */
+#define AT91_MAIN_CLOCK 160000000		/* from 12 MHz crystal */
+#define AT91_MASTER_CLOCK 80000000		/* peripheral = main / 2 */
+
+/* ROM Boot */
+//#define AT91_MAIN_CLOCK 96000000		/* from 18.432 MHz crystal */
+//#define AT91_MASTER_CLOCK 48000000		/* peripheral = main / 2 */
+
+#define CONFIG_SYS_HZ 1000000				/* 1us resolution */
+
+#define AT91_CLK_DELAY_CYCLES 256
+#define AT91_SLOW_CLOCK 32768			/* slow clock */
+#define CONFIG_SLOW_CLK AT91_SLOW_CLOCK
+
+#define	AT91_SLOW_FREQ				0
+#define	AT91_SYS_FREQ				1
+#define	AT91_PROC_FREQ				2
+#define	AT91_MASTER_FREQ			3
+
+#define CONFIG_ARM926EJS 1			/* This is an ARM926EJS Core */
+#define CONFIG_AT572D940HF 1			/* It's an Atmel AT572D940HF SoC */
+#define CONFIG_AT572D940HFEB 1			/* on an AT572D940HFEB Board */
+#define CONFIG_MACH_AT572D940HFEB 1
+#define CONFIG_USE_IRQ 1
+
+#define CONFIG_CMDLINE_TAG 1			/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG 1
+
+#define CONFIG_SKIP_LOWLEVEL_INIT 1
+#define CONFIG_SKIP_RELOCATE_UBOOT 1
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_ATMEL_USART 1
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#define CONFIG_USART3 1				/* USART 3 is DBGU */
+#define CONFIG_ATMEL_MCI		1
+#define CONFIG_BOOTDELAY 3
+/*
+ * #define CONFIG_BOOTARGS "console=ttyS0,115200 " \
+ * "root=/dev/mtdblock0 rw rootfstype=jffs2"
+ */
+
+#undef CONFIG_HWFLOW				/* don't include RTS/CTS flow control support */
+
+#define CONFIG_ENV_OVERWRITE 1
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE 1
+#define CONFIG_BOOTP_BOOTPATH 1
+#define CONFIG_BOOTP_GATEWAY 1
+#define CONFIG_BOOTP_HOSTNAME 1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+//#undef CONFIG_CMD_BDI
+//#undef CONFIG_CMD_IMI
+//#undef CONFIG_CMD_NET
+//#undef CONFIG_CMD_PING
+
+#define CONFIG_AUTO_COMPLETE 1
+#define CONFIG_CMDLINE_EDITING 1
+
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+
+#define CONFIG_CMD_PING 1
+#define CONFIG_CMD_DHCP 1
+#undef CONFIG_CMD_NAND 1
+#define CONFIG_CMD_USB 1
+#define CONFIG_CMD_MMC 1
+// #undef CONFIG_CMD_I2C
+// #undef CONFIG_CMD_SPI
+// #define CONFIG_CMD_AT91_SPIMUX 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_EXT2 1
+#define CONFIG_CMD_JFFS2 1
+
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS 1
+#define PHYS_SDRAM 0x20000000
+#define PHYS_SDRAM_SIZE 0x04000000		/* 64 megs */
+
+/* DataFlash */
+#define CONFIG_HAS_DATAFLASH 1
+#define CONFIG_SYS_SPI_WRITE_TOUT (5*CONFIG_SYS_HZ)
+#define CONFIG_SYS_MAX_DATAFLASH_BANKS 2
+#define CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS0 0xC0000000	/* CS0 */
+#define CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS1 0xD0000000	/* CS1 */
+#define AT91_SPI_CLK 33000000
+#define DATAFLASH_TCSS (0x1a << 16)
+#define DATAFLASH_TCHS (0x01 << 24)
+
+/* NAND flash */
+#define NAND_MAX_CHIPS 1
+#define CONFIG_SYS_MAX_NAND_DEVICE 1
+#define CONFIG_SYS_NAND_BASE 0x40000000
+#define CONFIG_SYS_NAND_DBW_8			1
+
+#define CONFIG_SYS_FLASH_BASE 0x10000000
+#define CONFIG_SYS_BOOT_SIZE (7 * 0x1000)		/* 7 4K sectors */
+#define CONFIG_SYS_ENV_ADDR 0x10007000
+#define CONFIG_SYS_ENV_SIZE 0x1000			/* 4K */
+
+#define CONFIG_U_BOOT_BASE 0x10008000
+#define CONFIG_U_BOOT_SIZE (10 * 0x1000)		/* 10 4K sectors */
+
+#define CONFIG_MAX_FLASH_SECT 135
+#define CONFIG_MAX_FLASH_BANKS 1
+#define CONFIG_FLASH_ERASE_TOUT 120000
+#define CONFIG_FLASH_WRITE_TOUT 500
+#define CONFIG_USE_BUFFER_WRITE 1
+
+#undef CONFIG_ENV_IS_IN_NVRAM
+#undef CONFIG_ENV_IS_IN_EEPROM
+#undef CONFIG_ENV_IS_IN_FLASH
+#undef CONFIG_ENV_IS_IN_DATAFLASH
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_IS_IN_ONENAND
+
+#define CONFIG_ENV_IS_NOWHERE 1
+
+#define PHYS_FLASH_1 CONFIG_FLASH_BASE
+
+/* NOR flash - no real flash on this board */
+#define CONFIG_SYS_NO_FLASH		1
+#define CONFIG_SYS_MAX_FLASH_SECT	16
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_BOOT_SIZE		16384
+#define	CONFIG_SYS_U_BOOT_BASE		0x00000000
+#define	CONFIG_SYS_FLASH_ERASE_TOUT	10
+
+/* Ethernet */
+
+#define CONFIG_MACB 1
+#define CONFIG_RMII 1
+#define CONFIG_NET_MULTI 1
+#define CONFIG_NET_RETRY_COUNT 20
+#define CONFIG_RESET_PHY_R 1
+#define CONFIG_ETHADDR 00:11:22:33:AA:BB
+#define CONFIG_IPADDR 172.16.1.187
+#define CONFIG_NETMASK 255.255.0.0
+#define CONFIG_HOSTNAME D940DEB
+#define CONFIG_SERVERIP 172.16.1.30
+#define CONFIG_BOOTFILE d940deb.bin
+
+/* USB */
+#define CONFIG_USBH 1
+#define CONFIG_USB_OHCI_NEW 1
+#define LITTLEENDIAN 1
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_SYS_USB_OHCI_CPU_INIT 1
+#define CONFIG_SYS_USB_OHCI_REGS_BASE 0x00500000	/* AT572D940_UHP_BASE */
+#define CONFIG_SYS_USB_OHCI_SLOT_NAME "at572d940"
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS 2
+#define CONFIG_SYS_USB_STORAGE 1
+
+#define CONFIG_SYS_LOAD_ADDR 0x22000000		/* load address */
+
+#define CONFIG_SYS_MEMTEST_START PHYS_SDRAM
+#define CONFIG_SYS_MEMTEST_END 0x23e00000
+
+#undef CONFIG_USE_DATAFLASH_CS0
+#undef CONFIG_USE_DATAFLASH_CS1
+#undef CONFIG_USE_NANDFLASH
+#define CONFIG_USE_SD 1
+
+#ifdef CONFIG_USE_DATAFLASH_CS0
+
+/* bootstrap + u-boot + env + linux in dataflash on CS0 */
+#define CONFIG_ENV_IS_IN_DATAFLASH 1
+#define CONFIG_SYS_MONITOR_BASE (CONFIG_DATAFLASH_LOGIC_ADDR_CS0 + 0x8400)
+#define CONFIG_ENV_OFFSET 0x4200
+#define CONFIG_ENV_ADDR (CONFIG_DATAFLASH_LOGIC_ADDR_CS0 + CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_SIZE 0x4200
+#define CONFIG_BOOTCOMMAND "cp.b 0xC003DE00 0x22000000 0x200040; bootm"
+
+#elif CONFIG_USE_DATAFLASH_CS1
+
+/* bootstrap + u-boot + env + linux in dataflash on CS1 */
+#define CONFIG_ENV_IS_IN_DATAFLASH 1
+#define CONFIG_MONITOR_BASE (CONFIG_DATAFLASH_LOGIC_ADDR_CS1 + 0x8400)
+#define CONFIG_ENV_OFFSET 0x4200
+#define CONFIG_ENV_ADDR (CONFIG_DATAFLASH_LOGIC_ADDR_CS1 + CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_SIZE 0x4200
+#define CONFIG_BOOTCOMMAND "cp.b 0xD003DE00 0x22000000 0x200040; bootm"
+
+#elif CONFIG_USE_NANDFLASH
+
+/* bootstrap + u-boot + env + linux in nandflash */
+#define CONFIG_ENV_IS_IN_NAND 1
+#define CONFIG_ENV_OFFSET 0x60000
+#define CONFIG_ENV_OFFSET_REDUND 0x80000
+#define CONFIG_ENV_SIZE 0x20000			/* 1 sector = 128 kB */
+#define CONFIG_BOOTCOMMAND "nand read 0x22000000 0xA0000 0x200000; bootm"
+
+#elif CONFIG_USE_SD
+//#define CONFIG_ENV_IS_IN_DATAFLASH 1
+#define CONFIG_MONITOR_BASE (CONFIG_DATAFLASH_LOGIC_ADDR_CS1 + 0x8400)
+#define CONFIG_ENV_OFFSET 0x4200
+#define CONFIG_ENV_ADDR (CONFIG_DATAFLASH_LOGIC_ADDR_CS1 + CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_SIZE 0x4200
+
+#define CONFIG_MMC 1
+#define CONFIG_SD_CARD_BOOT 1
+
+//#define CONFIG_MMC_CLK_OD 1500000
+//#define CONFIG_MMC_CLK_PP 1500000
+#define CONFIG_MMC_CLK_OD 20000000
+#define CONFIG_MMC_CLK_PP 20000000
+#define CONFIG_MMC_OP_COND (0x401f8000)		/* SDHC + voltage rage 2.7-3.3 */
+
+#define CONFIG_BOOTCOMMAND "mmcinit; fatload mmc 0:1 0x21400000 uLinux.img; fatload mmc 0:1 0x21100000 initrd.img; bootm 0x21400000"
+#else
+#define CONFIG_ENV_SIZE 0x1000
+
+#endif
+
+#define CONFIG_BAUDRATE 115200
+#define CONFIG_SYS_BAUDRATE_TABLE {115200 , 19200, 38400, 57600, 9600 }
+
+#define CONFIG_SYS_PROMPT "Diopsis U-Boot> "
+#define CONFIG_SYS_CBSIZE 256
+#define CONFIG_SYS_MAXARGS 16
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMDLINE_EDITING 1
+
+#define ROUND(A, B) (((A) + (B)) & ~((B) - 1))
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN ROUND(3 * CONFIG_ENV_SIZE + 128*1024, 0x1000)
+#define CONFIG_SYS_GBL_DATA_SIZE 128			/* 128 bytes for initial data */
+
+#define CONFIG_STACKSIZE (32*1024)		/* regular stack */
+
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ 4096
+#define CONFIG_STACKSIZE_FIQ 4096
+//#error CONFIG_USE_IRQ not supported
+#endif
+
+#endif
+
diff -urN u-boot-2009.01-rc1-0rig//Makefile u-boot-2009.01-rc1/Makefile
--- u-boot-2009.01-rc1-0rig//Makefile	2009-01-04 22:02:22.000000000 +0100
+++ u-boot-2009.01-rc1/Makefile	2009-01-04 22:02:50.000000000 +0100
@@ -2702,6 +2702,12 @@
 	@$(MKCONFIG) -a at91sam9rlek arm arm926ejs at91sam9rlek atmel at91
 
 ########################################################################
+# AT572D940HF
+########################################################################
+#
+at572d940hfeb_config : unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs at572d940hfeb atmel at572d940hf
+
 ## ARM Integrator boards - see doc/README-integrator for more info.
 integratorap_config	\
 ap_config		\
