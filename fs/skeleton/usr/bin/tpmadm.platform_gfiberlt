#!/usr/bin/python
# Copyright 2011 Google Inc. All Rights Reserved.
#
"""A command-line tool for configuring HW forwarding."""

__author__ = 'kedong@google.com (Ke Dong)'


import cStringIO
import os
import sys
import tpm
import options

FRWD_DS = 'frwd_ds'
FRWD_US = 'frwd_us'
OWNER_ID = '1000'
L2_KEY_MAC_WAN = 'mac_wan'
L2_KEY_MAC_BC = 'mac_bc'

# Constants
MAC_ALL_ZERO = '00:00:00:00:00:00'
MAC_ALL_ONE = 'FF:FF:FF:FF:FF:FF'
PORT_PON = 'pon0'
PORT_ETH = 'eth0'
ETH_BMP = 0x40000
PON_BMP = 0x00001

# Empty Rules
FRWD_EMPTY = 'frwd_empty'
MOD_EMPTY = 'mod_empty'
L2_KEY_EMPTY = 'l2_key_empty'

optspec = """
tpmadm -w <port> [options...]
tpmadm -p
tpmadm -f
--
w,wanport=        set WAN port to (pon0, eth0)
l,lanport=        set LAN port to (pon0, eth0)
p,printall        print all tpm rules
f,flushall        flush all tpm rules
v,verbose         verbose output
"""


def EnableWanProfile(wan_port, lan_port):
  """Enable WAN Profile."""
  if wan_port is None:
    tpm.Logger.Log('Upstream port must be defined.\n')
    return

  if wan_port == lan_port:
    tpm.Logger.Log('WAN port and LAN port should be different.\n')
    return

  with open(os.path.join('/sys/class/net', wan_port, 'address'), 'r') as f:
    wan_mac = f.readline().rstrip()
  if wan_port == PORT_PON:
    us_port = 'WAN'
  elif wan_port == PORT_ETH:
    us_port = 'UNI_ANY'
  else:
    raise tpm.Fatal('Invalid WAN port - %s\n', wan_port)

  tt = tpm.TpmTransaction()
  tt.Begin()
  try:
    tt.FlushAll()
    tt.AddL2KeyMacAddr(L2_KEY_MAC_WAN, MAC_ALL_ZERO, MAC_ALL_ZERO,
                       wan_mac, MAC_ALL_ONE)
    tt.AddL2KeyMacAddr(L2_KEY_MAC_BC, MAC_ALL_ZERO, MAC_ALL_ZERO,
                       MAC_ALL_ONE, MAC_ALL_ONE)
    rule_num = 0
    tt.AddL2Rule(OWNER_ID, us_port, rule_num, 0x0001, 0x0000, 0x0000, 'done',
                 L2_KEY_MAC_WAN, FRWD_EMPTY, MOD_EMPTY, 0x0000)
    # TODO(kedong) Marvell's current TPM can only be configured to either take
    # all broadcast traffic to CPU or forward to GE. But it make more sense for
    # broadcast to reach both GE and CPU. This is reported to marvell as 479564.
    # For now, we don't need any broadcast traffic to be processed in CPU until
    # we have to deal with non-standard DHCP setup which broadcast DHCP offer
    # in broadcast.
    #rule_num += 1
    #tt.AddL2Rule(OWNER_ID, us_port, rule_num, 0x0001, 0x0000, 0x0000, 'done',
    #             L2_KEY_MAC_BC, FRWD_EMPTY, MOD_EMPTY, 0x0000)

    # If LAN port is not defined, spare media converting rules.
    if lan_port:
      if lan_port == PORT_PON:
        ds_bmp = PON_BMP
        us_bmp = ETH_BMP
        ds_port = 'WAN'
      elif lan_port == PORT_ETH:
        ds_bmp = ETH_BMP
        us_bmp = PON_BMP
        ds_port = 'UNI_ANY'
      else:
        raise tpm.Fatal('Invalid LAN port - %s\n', ds_port)

      tt.AddFrwdRule(FRWD_DS, ds_bmp)
      tt.AddFrwdRule(FRWD_US, us_bmp)
      rule_num += 1
      tt.AddL2Rule(OWNER_ID, us_port, rule_num, 0x0000, 0x0000, 0x06,
                   'done', L2_KEY_EMPTY, FRWD_DS, MOD_EMPTY, 0x0000)
      rule_num += 1
      tt.AddL2Rule(OWNER_ID, ds_port, rule_num, 0x0000, 0x0000, 0x06,
                   'done', L2_KEY_EMPTY, FRWD_US, MOD_EMPTY, 0x0000)

    tt.Commit()
    tt.Verify()
  finally:
    tt.End()


def main():
  o = options.Options(optspec)
  opt, _, _ = o.parse(sys.argv[1:])

  if not (opt.wanport or opt.flushall or opt.printall):
    o.fatal('Expected at least one of -p, -f, or -w')

  tpm.Logger.VERBOSE = opt.verbose if opt.verbose else False

  if opt.wanport:
    EnableWanProfile(opt.wanport, opt.lanport)
  elif opt.flushall:
    tt = tpm.TpmTransaction()
    tt.Begin()
    try:
      tt.FlushAll()
      tt.Commit()
      tt.Verify()
    finally:
      tt.End()
  elif opt.printall:
    tt = tpm.TpmTransaction()
    tt.Begin()
    output = cStringIO.StringIO()
    try:
      tt.PrintAll(output)
      print output.getvalue()
    finally:
      output.close()
      tt.End()


if __name__ == '__main__':
  try:
    sys.exit(main())
  except tpm.Fatal, e:
    tpm.Logger.Log('%s\n', e)
    sys.exit(1)
