#!/bin/sh
CONFIG_DIR=/config/wifi
band=
show_bands="2.4 5"
bridge=
if_suffix=
ssid=$(serial)_TestWifi
crypto=WPA2_PSK_AES
channel=auto
autotype=NONDFS
protos=a/b/g/n/ac
allow_ab=
allow_g=
allow_n=
allow_ac=
width=20
enable_80211n=
enable_wmm=
hidden=
guard_interval=
vht_guard_interval=
persist=
extra_short_timeouts=
force_restart=
RGSETUPPSK="very_secret_passphrase"

chop_multiline()
{
  echo "$1" | { read x; echo "$x"; }
}

# use $WIFI_PSK from the environment if given.
# You shouldn't pass passwords as command-line options because they show up
# in 'ps' even to users other than you.
psk=$(chop_multiline "$WIFI_PSK")

. /etc/utils.sh
register_experiment AutoSetupSSID
register_experiment NoSwapWifiPrimaryChannel  # checked by hostapd itself
register_experiment NoAutoNarrowWifiChannel   # checked by hostapd itself


log() {
  echo "$@" >&2
}


die() {
  log "Fatal:" "$@"
  exit 99
}


bin=$(basename "$0")
USAGE="
Usage: $bin set [options...]
 -b <band>        Wifi band to use (5 GHz or 2.4 GHz, default=$band)
 -c <channel>     Channel to use (default=$channel)
 -a <autotype>    Autochannel method to use (LOW, HIGH, DFS, NONDFS, ANY,
                    OVERLAP) (default=$autotype)
 -s <ssid>        SSID to use (default=$ssid)
 -e <encryption>  Encryption type to use (WPA_PSK_AES, WPA2_PSK_AES,
                    WPA12_PSK_AES, WPA_PSK_TKIP, WPA2_PSK_TKIP, WPA12_PSK_TKIP,
                    WEP, or NONE) (default=$crypto)
 -f               Force restart even if already running with these settings
 -H               Enable hidden mode (disable SSID advertisements)
 -M               Enable wmm extensions (needed for block acks)
 -G               Enable short guard interval
 -p <a/b/g/n/ac>  802.11 levels to allow, slash-delimited [default=$protos]
 -w <20|40|80>    Channel width to use, in MHz (default=$width)
 -B <bridge>      Bridge device to use (default=$bridge)
 -X               Use extra short timeout intervals for stress testing
 -P               Persist settings so we can restore them with 'wifi restore'
 -S               wlan interface suffix (default: none)
$bin <off|stop> [options...]
 disable wifi on the given band(s)
 -b <band>        Wifi band to use (5 GHz or 2.4 GHz, default='$show_bands')
 -P               Also remove persisted wifi settings
 -S               wlan interface suffix (default: none)
$bin restore [options...]
 restore the wifi settings from the last time you used -P
 -b <band>        Wifi band to restore (default='$show_bands')
 -S               wlan interface suffix (default: none)
$bin show [options...]
 print all known parameters
 -b <band>        Wifi band to use (5 GHz or 2.4 GHz, default='$show_bands')
 -S               wlan interface suffix (default: none)
"
usage() {
  echo "$USAGE" >&2
  exit 1
}


contains_item() {
  # like contains(), only assumes the list is a whitespace-separated list
  # and we want one element of it, rather than just a substring.
  local list="$1" want="$2" i
  set $list  # break on all whitespace characters
  list="$*"  # rejoin with just ' ' space character
  contains " $list " " $want "
}


split()
{
  (
    IFS=" ,/"
    set $1
    echo "$@"
  )
}


WL() {
  log "wl" "$@"
  wl "$@" || die "wl $*: failed"
}


IW() {
  log "iw" "$@"
  iw "$@" || die "iw $*: failed"
}


iw_find_phy() {
  band=$1
  channel=$2
  phy=
  channum=
  iw phy | while IFS=" []" read a b c d junk; do
    if [ "$a" = "Wiphy" ]; then
      phy=$b
    elif [ "$c" = "MHz" ]; then
      freq=$b
      channum=$d
      if [ "$channel" = "$channum" ]; then
        echo "$phy"
        break
      elif [ "$channel" = "auto" ]; then
        if startswith "$band" 2 && startswith "$freq" 2; then
          echo "$phy"
          break
        elif startswith "$band" 5 && startswith "$freq" 5; then
          echo "$phy"
          break
        fi
      fi
    fi
  done
}


iw_find_ifc() {
  phynum=$1
  pattern="^wlan[0-9]${if_suffix}$"
  thisphynum=
  ifcname=
  iw dev | while read a b junk; do
    if startswith "$a" "phy#"; then
      thisphynum=${a#phy#}
    elif [ "$a" = "Interface" ] && ! startswith "$b" "mon."; then
      if [ "$thisphynum" = "$phynum" ]; then
        if echo "$b" | grep -q "$pattern"; then
          echo "$b"
          break
        fi
      fi
    fi
  done
}


iw_find_ifc_from_band() {
  phy=$(iw_find_phy "$band" auto)
  [ -n "$phy" ] || die "no wifi phy for band='$band'"
  phynum=${phy#phy}
  ifc=$(iw_find_ifc "$phynum")
  [ -n "$ifc" ] || die "no wifi interface for band='$band'"
  echo "$ifc"
}


iw_check1_hostapd() {
  local ifc="$1"
  local pidfile="/tmp/hostapd.pid.$ifc"
  [ -e "$pidfile" ] && kill -0 "$(cat "$pidfile")" 2>/dev/null
}


iw_check2_hostapd() {
  local ifc="$1"
  hostapd_cli -i "$ifc" get_config >/dev/null 2>&1
}


iw_stop_hostapd() {
  local ifc=$1
  local pidfile=/tmp/hostapd.pid.$ifc
  pkillwait -f "hostapd .* /tmp/hostapd.conf.$ifc\$"
  killpid "$pidfile"
  rm -f "$pidfile"
  # TODO(apenwarr): hostapd doesn't always delete interface mon.$ifc.
  #  Then it gets confused by the fact that it already exists.
  #  Let's help out.  We should really fix this by eliminating the need for
  #  hostapd to have a monitor interface at all (which is deprecated anyway)
  # Remove this line when our hostapd no longer needs a monitor interface.
  iw dev "mon.$ifc" del 2>/dev/null
  ip link set "$ifc" down
}

is_interface_up() {
  [ -e "/sys/class/net/$1" ] && [ "$(cat /sys/class/net/$1/operstate 2>/dev/null)" = "up" ]
}


iw_start_hostapd() {
  local ifc="$1"
  local pidfile="/tmp/hostapd.pid.$ifc"
  opts=""
  log "Starting hostapd."
  babysit 10 \
      startpid "$pidfile" \
      alivemonitor "/tmp/hostapd.$ifc.alive" 30 2 65 \
      hostapd $opts \
      -A "/tmp/hostapd.$ifc.alive" \
      -F "/tmp/wifi/fingerprints" \
      "/tmp/hostapd.conf.$ifc" \
      2>&1 | logos "hostapd-$ifc" &

  # Wait for hostapd to start, and return an error if it doesn't
  for d in $(seq 10); do
    iw_check1_hostapd "$ifc" && break
    echo -n . >&2
    sleep 0.1
  done
  # hostapd_cli returns success on command timeouts.  If we time this
  # perfectly and manage to connect but then hostapd dies right after,
  # we'd think it succeeded.  So sleep a bit to try to give hostapd
  # a chance to die from its error before we try to connect to it.
  sleep 0.5
  for d in $(seq 50); do
    iw_check1_hostapd "$ifc" || break
    if iw_check2_hostapd "$ifc"; then
      [ -n "$persist" ] && atomic "$CONFIG_DIR/hostapd.conf.$ifc" "$hostconf"
      if is-network-box && experiment AutoSetupSSID; then
        if [ "$ifc" = "wlan0" ]; then
          ifconfig wlan0.tv $WLAN0TVIP 2>/dev/null
          ifconfig wlan0.setup $WLAN0SETUPIP 2>/dev/null
        else
          ifconfig wlan1.tv $WLAN1TVIP 2>/dev/null
          ifconfig wlan1.setup $WLAN1SETUPIP 2>/dev/null
        fi
        if is_interface_up "$ifc.tv" && is_interface_up "$ifc.setup"; then
          log ok
          brctl addif br0 $ifc.tv
          brctl addif br0 $ifc.setup
          exit 0
        fi
      else
        log ok
        exit 0
      fi
    fi
    echo -n . >&2
    sleep 0.1
  done
  log
  die "hostapd failed to start. Look at hostapd logs for details."
}


iw_maybe_restart_hostapd() {
  local ifc="$1"
  local cfgdata="$2"
  local cfgfile="/tmp/hostapd.conf.$ifc"
  local oldcfgdata="$(cat "$cfgfile")"
  if ! iw_check2_hostapd "$ifc"; then
    log "hostapd not running yet, starting."
  elif [ "$oldcfgdata" != "$cfgdata" ]; then
    log "hostapd config changed, restarting."
  elif [ -n "$force_restart" ]; then
    log "Forced restart requested."
  else
    log "hostapd-$ifc already configured and running."
    return
  fi

  # make sure it's stopped *before* replacing config, so that if we
  # get interrupted, we won't accidentally think the new config is the
  # one that's running
  iw_stop_hostapd "$ifc"
  atomic "$cfgfile" "$cfgdata"
  iw_start_hostapd "$ifc"
}


stopwifi() {
  band=$1
  if runnable iw; then
    ifc=$(iw_find_ifc_from_band "$band") || die
    iw_stop_hostapd "$ifc"
    [ -n "$persist" ] && rm -f "$CONFIG_DIR/hostapd.conf.$ifc"
    return 0
  fi
}


restorewifi() {
  band=$1
  if runnable iw; then
    ifc=$(iw_find_ifc_from_band "$band") || die
    if [ -r "$CONFIG_DIR/hostapd.conf.$ifc" ]; then
      cfgdata=$(cat "$CONFIG_DIR/hostapd.conf.$ifc")
      ( iw_maybe_restart_hostapd "$ifc" "$cfgdata" )
    else
      stopwifi "$band"
    fi
  fi
}


# TODO(apenwarr): extend this to notice actual running settings.
#  Including whether hostapd is up or down, etc.
showwifi() {
  band=$1
  if runnable iw; then
    # TODO(dgentry): iw says 'Do NOT screenscrape this tool,
    # we don't consider its output stable.'
    # should we write an iwget tool using iwlib, where the API is more stable?
    ifc=$(iw_find_ifc_from_band "$band") || die

    echo "Band: $band"
    output=$(iw reg get)
    country=${output##country }
    country=${country%%:*}
    echo "RegDomain: $country"

    myinterface=0
    iw dev "$ifc" info | while read a b; do
      [ "$a" = "channel" ] && echo "Channel: ${b%% *}"
      [ "$a" = "ssid" ] && echo "SSID: $b"
      [ "$a" = "addr" ] && echo "BSSID: $b"
    done

    if [ -e "/tmp/autochan.$ifc" ]; then
      echo "AutoChannel: TRUE"
    else
      echo "AutoChannel: FALSE"
    fi
    if [ -e "/tmp/autotype.$ifc" ]; then
      echo "AutoType: $(cat /tmp/autotype.$ifc)"
    fi

    echo "Station List for band: $band"
    iw dev "$ifc" station dump
    echo
  fi
}


if [ $# -eq 0 ]; then
  usage
fi

cmd=$1
shift

while getopts "b:c:a:s:e:fp:w:HMGB:PXS:" opt
do
  case $opt in
    b) band=$OPTARG; show_bands=$OPTARG ;;
    c) channel=$OPTARG ;;
    a) autotype=$OPTARG ;;
    s) ssid=$(chop_multiline "$OPTARG") ;;
    e) crypto=$OPTARG ;;
    f) force_restart=1 ;;
    p) protos=$OPTARG ;;
    w) width=$OPTARG ;;
    H) hidden="ignore_broadcast_ssid=1" ;;
    M) enable_wmm="wmm_enabled=1" ;;
    G) guard_interval="[SHORT-GI-20][SHORT-GI-40]"
       vht_guard_interval="[SHORT-GI-80]";;
    B) bridge=$OPTARG ;;
    P) persist=1; mkdir -p "$CONFIG_DIR" ;;
    X) extra_short_timeouts=1 ;;
    S) if_suffix=$OPTARG ;;
    *) usage ;;
  esac
done

case "$cmd" in
  show)
    e=0
    for b in $show_bands; do
      showwifi "$b" || e=1
    done
    exit $e
    ;;
  off|stop)
    e=0
    for b in $show_bands; do
      log "stopping wifi for $b GHz..."
      stopwifi "$b" || e=1
    done
    exit $e
    ;;
  restore)
    e=0
    for b in $show_bands; do
      log "restoring wifi for $b GHz..."
      restorewifi "$b" || e=1
    done
    exit $e
    ;;
  set)
    ;;  # fall through
  *)
    usage
    ;;
esac


# set

case "$band" in
  2.4|5) ;;
  *) die "you must specify a band with -b2.4 or -b5" ;;
esac


# Allowed frequencies for various different modes
C_24MAIN_20="2412 2432 2462"
C_24MAIN_40="2412"
C_24MAIN_80=""
C_24OVERLAP_20="2412 2417 2422 2427 2432 2437 2442 2447 2452 2457 2462"
C_24OVERLAP_40="2412"
C_24OVERLAP_80=""
C_5LOW_20="5180 5200 5220 5240"
C_5LOW_40="5180 5220"
C_5LOW_80="5180"
C_5HIGH_20="5745 5765 5785 5805 5825"
C_5HIGH_40="5745 5785"
C_5HIGH_80="5745"
C_5DFS_20="5260 5280 5300 5320 5500 5520 5540 5560 5580 5660 5680 5700"
C_5DFS_40="5260 5300 5500 5540 5660"
C_5DFS_80="5260 5500"

# Recommended HT40/VHT80 settings for given primary channels.
# HT40 channels can fall back to 20 MHz, and VHT80 can fall back to 40 or 20.
# So we configure using a "primary" 20 MHz channel, then allow wider
# transmissions if $width says to do so.  These tables are the extra
# information needed to locate the "wider" channels.
# (It might be nicer to use frequencies instead of channels here, but
# unfortunately iw makes conversion back and forth complicated, and the
# math is easier with channel numbers.  TODO(apenwarr): make iw less lame.)
HT_DIRECTIONS="
    1+ 5- 7+ 11-
    36+ 40- 44+ 48-
    149+ 153- 157+ 161-
    52+ 56- 60+ 64-
    100+ 104- 108+ 112-
    132+ 136-
"
VHT_BASES="
    36=36 40=36 44=36 48=36
    149=149 153=149 157=149 161=149
    52=52 56=52 60=52 64=52
    100=100 104=100 108=100 112=100
"

case "$band-$autotype-$width" in
  # There are no 80Mhz channels in 2.4Ghz band.
  2*-*-80) die "80Mhz not valid in 2.4Ghz: type='$autotype' band='$band' width='$width'" ;;

  # DFS is not valid in 2.4Ghz
  2*-DFS-*)die "dfs not valid in 2.4Ghz: type='$autotype' band='$band' width='$width'" ;;

  # There are no overlapping channels in 5Ghz, so requesting that isn't valid.
  5*-OVERLAP-*) die "overlap not allowed in 5ghz: type='$autotype band='$band' width='$width'" ;;

  # 2.4 Ghz channels
  2*-LOW-20) permit_freq="$C_24MAIN_20" ;;
  2*-LOW-40) permit_freq="$C_24MAIN_40" ;;
  2*-HIGH-20) permit_freq="$C_24MAIN_20" ;;
  2*-HIGH-40) permit_freq="$C_24MAIN_40" ;;
  2*-NONDFS-20) permit_freq="$C_24MAIN_20" ;;
  2*-NONDFS-40) permit_freq="$C_24MAIN_40" ;;
  2*-ANY-20) permit_freq="$C_24MAIN_20" ;;
  2*-ANY-40) permit_freq="$C_24MAIN_40" ;;
  2*-OVERLAP-20) permit_freq="$C_24OVERLAP_20" ;;
  2*-OVERLAP-40) permit_freq="$C_24OVERLAP_40" ;;

  # 5 Ghz channels
  5*-LOW-20) permit_freq="$C_5LOW_20" ;;
  5*-LOW-40) permit_freq="$C_5LOW_40" ;;
  5*-LOW-80) permit_freq="$C_5LOW_80" ;;
  5*-HIGH-20) permit_freq="$C_5HIGH_20" ;;
  5*-HIGH-40) permit_freq="$C_5HIGH_40" ;;
  5*-HIGH-80) permit_freq="$C_5HIGH_80" ;;
  5*-DFS-20) permit_freq="$C_5DFS_20" ;;
  5*-DFS-40) permit_freq="$C_5DFS_40" ;;
  5*-DFS-80) permit_freq="$C_5DFS_80" ;;
  5*-NONDFS-20) permit_freq="$C_5LOW_20 $C_5HIGH_20" ;;
  5*-NONDFS-40) permit_freq="$C_5LOW_40 $C_5HIGH_40" ;;
  5*-NONDFS-80) permit_freq="$C_5LOW_80 $C_5HIGH_80" ;;
  5*-ANY-20) permit_freq="$C_5LOW_20 $C_5HIGH_20 $C_5DFS_20" ;;
  5*-ANY-40) permit_freq="$C_5LOW_40 $C_5HIGH_40 $C_5DFS_40" ;;
  5*-ANY-80) permit_freq="$C_5LOW_80 $C_5HIGH_80 $C_5DFS_80" ;;
  *) die "unknown autochannel type='$autotype' band='$band' width='$width'" ;;
esac

for d in $(split "$protos"); do
  case "$d" in
    a|b|ab) allow_ab=1 ;;
    g) allow_g=1 ;;
    n) allow_n=1 ;;
    ac) allow_ac=1 ;;
    *) die "unknown proto '$d'" ;;
  esac
done

case "$width" in
  20) ;;
  40) [ -n "$allow_n" ] || die "'-p n' is needed for 40 MHz channels" ;;
  80) [ -n "$allow_ac" ] || die "'-p ac' is needed for 80 MHz channels" ;;
  *) die "invalid channel width='$width'"
esac

case "$crypto" in
  *_PSK_*|WEP)
    [ -n "$psk" ] ||
        die "encryption enabled; use WIFI_PSK=whatever wifi set ..."
    ;;
  NONE)
    psk="NOT_ACTUALLY_USED"
    ;;
esac

if runnable wl && [ -z "$(iw list 2>/dev/null)" ]; then
  log "Configuring broadcom wifi."
  WL radio on
  WL down
  WL ssid ""
  [ "$channel" = "auto" ] || band=auto
  case $band in
    5)    WL band a ;;
    2.4)  WL band b ;;
    auto) WL band auto ;;
    *) die "invalid band '$band'" ;;
  esac
  WL ap 0
  WL up
  if [ "$channel" = "auto" ]; then
    # We can only run autochannel when ap=0, but setting ap=1 later will
    # wipe the value.  So we have to capture the autochannel setting, then
    # set it later.  'wl autochannel 2' is thus useless.
    WL autochannel 1
    sleep 3  # enough time to scan all the 2.4 or 5 GHz channels at 100ms each
    channel=$(WL autochannel | ( read chan junk; echo "$chan"; ))
  fi
  WL ap 1
  WL chanspec "$channel"
  WL auth 0
  WL infra 1
  case $crypto in
    *_AES)  WL wsec 4 ;;
    *_TKIP) WL wsec 2 ;;
    WEP)    WL wsec 1 ;;
    NONE)   WL wsec 0 ;;
    *) die "invalid crypto '$crypto'" ;;
  esac
  WL sup_wpa 1
  case $crypto in
    WPA_*)    WL wpa_auth 4 ;;
    WPA2_*)   WL wpa_auth 128 ;;
    WEP|NONE) WL wpa_auth 0 ;;
    *) die "invalid crypto '$crypto'" ;;
  esac
  WL up
  case $crypto in
    *_PSK_*)
      # WPA keys must be added *before* setting the SSID
      WL set_pmk "$psk"
      WL ssid "$ssid"
      ;;
    WEP)
      # WEP keys must be added *after* setting the SSID
      WL ssid "$ssid"
      WL addwep 0 "$psk"
      ;;
    NONE)
      WL ssid "$ssid"
      ;;
    *)
      die "invalid crypto '$crypto'"
      ;;
  esac
elif runnable iw; then
  log "Configuring cfg80211 wifi."
  phy=$(iw_find_phy "$band" "$channel")
  [ -n "$phy" ] || die "no wifi phy for band='$band' channel='$channel'"
  phynum=${phy#phy}
  log "phy='$phy' phynum='$phynum'"
  ifc=$(iw_find_ifc "$phynum")
  [ -n "$ifc" ] || die "no wifi interface for band='$band' channel='$channel'"
  log "ifc='$ifc'"

  IWC() {
    IW dev "$ifc" "$@"
  }

  pidfile=/tmp/hostapd.pid.$ifc
  log "pidfile='$pidfile'"

  old_autotype=$(cat "/tmp/autotype.$ifc" 2>/dev/null)
  old_band=$(cat "/tmp/band.$ifc" 2>/dev/null)
  old_width=$(cat "/tmp/width.$ifc" 2>/dev/null)

  # Special case: if autochannel enabled and we've done it before,
  # just use the old autochannel.  The main reason for this is we may not
  # be able to run the autochannel algorithm without stopping hostapd first,
  # which defeats the code that tries not to restart hostapd unnecessarily.
  if [ "$channel" = "auto" ] &&
     [ "$autotype-$band-$width" = "$old_autotype-$old_band-$old_width" ]; then
    # ...but only if not forced mode.  If it's forced, don't use the old
    # value, but don't wipe it either.
    if [ -z "$force_restart" ]; then
      autochan=$(cat "/tmp/autochan.$ifc" 2>/dev/null)
      if [ -n "$autochan" ] && [ "$autochan" -gt 0 ]; then
        log "Reusing old autochannel='$autochan'"
        channel="$autochan"
      fi
    fi
  else
    # forget old autochannel setting
    rm -f "/tmp/autochan.$ifc"
  fi

  # TODO(apenwarr): Play more with hostapd's auto channel selection.
  #  I read comments elsewhere that it's rather incomplete, and glancing
  #  through the code it looks like it doesn't handle all the interesting
  #  cases.  But neither does this code yet...
  if [ "$channel" = "auto" ]; then
    log "Doing autochannel scan."

    atomic "/tmp/autochan.$ifc" ""

    iw_stop_hostapd "$ifc"
    log "ip link set $ifc up..."
    ip link set "$ifc" up

    # TODO(apenwarr): we really want to clear any old survey results first.
    #  But there seems to be no iw command for that yet...
    # TODO(apenwarr): This only scans each channel for 100ms.
    #  Ideally it should scan for longer, to get a better activity sample.
    #  It would also be nice to continue scanning in the background while
    #  hostapd is running, using 'iw offchannel'.
    # Retry this a few times if it fails, just in case there was a scan
    # already in progress started somewhere else (eg. from waveguide).
    for i in 1 2 3 4 5 6 7 8 9; do
      ( IWC scan passive >/dev/null ) && break
      sleep 0.5
    done

    # TODO(apenwarr): this algorithm doesn't deal with overlapping channels.
    #  Just because channel 1 looks good doesn't mean we should use it;
    #  activity in overlapping channels could destroy performance.  In fact,
    #  overlapping channel activity is much worse than activity on the main
    #  channel.  Also, if using 40 MHz or 80 MHz channel width, we should
    #  count activity in all the 20 MHz sub-channels separately, and choose
    #  the least-active sub-channel as the primary.
    bestfreq=$(
      bestfreq=
      bestnoise=
      bestratio=
      freq=
      IWC survey dump | {
        # TODO(apenwarr): Randomize the order of channels.
        #  Otherwise when channels are all about equally good, we would always
        #  choose exactly the same channel, which might be bad in the case
        #  of hidden nodes.
        while read a b c d e junk; do
          if [ "$a" = "frequency:" ]; then
            freq=$b
            noise=
            active=
            busy=
          elif [ "$a" = "noise:" ]; then
            noise="$b"
          elif [ "$a $b $c" = "channel active time:" ]; then
            active=$d
          elif [ "$a $b $c" = "channel receive time:" ]; then
            busy=$d
            ratio=$(( ($active+1) * 1000 / ($busy+1) ))
            contains_item "$permit_freq" "$freq" || continue
            # some radios support both bands, but we only want to match
            # channels on the band we have chosen.
            startswith "$band" 2 && ! startswith "$freq" 2 && continue
            startswith "$band" 5 && ! startswith "$freq" 5 && continue
            log "freq=$freq ratio=$ratio noise=$noise"
            if [ -z "$bestnoise" ] ||
               [ "$(($bestnoise - 15))" -gt "$noise" ] ||
               [ "$bestratio" -lt "$ratio" ]; then
              bestfreq=$freq
              bestratio=$ratio
              bestnoise=$noise
            fi
          fi
        done
        echo "$bestfreq"
      }
    )
    if [ -z "$bestfreq" ]; then
      log "autoscan did not find any channel, picking random channel"
      log "permit_freq='$permit_freq'"
      [ -n "$permit_freq" ] || die "no default channel: type='$autotype'  band='$band' width='$width'"
      bestfreq=$(choose $permit_freq)
    fi
    log "autofreq='$bestfreq'"

    channel=$(
      IW phy | while IFS=" []" read a b c d junk; do
        if [ "$c" = "MHz" ]; then
          freq=$b
          channum=$d
          if [ "$freq" = "$bestfreq" ]; then
            echo "$channum"
            break
          fi
        fi
      done
    )
    [ -n "$channel" ] || die "no channel number matched freq='$bestfreq'"
    log "autochannel='$channel'"
    atomic "/tmp/autochan.$ifc" "$channel"
    atomic "/tmp/autotype.$ifc" "$autotype"
    atomic "/tmp/band.$ifc" "$band"
    atomic "/tmp/width.$ifc" "$width"
  fi
  log "using channel='$channel'"

  case $band in
    2.4) [ -n "$allow_g$allow_n" ] && hostapd_band=g || hostapd_band=b ;;
    5) hostapd_band=a ;;
    *) die "invalid band in '$band'" ;;
  esac
  ampdu=
  enable_80211n=
  enable_80211ac=
  require_ht=
  require_vht=
  ht20=
  ht40=
  ht_rxstbc=
  vht_settings=

  log "getting phy info..."
  phyinfo=$(IW phy "$phy" info 2>/dev/null) || die "failed to get phy info"
  contains "$phyinfo" "RX STBC 3-stream" && ht_rxstbc="[RX-STBC123]"
  contains "$phyinfo" "RX STBC 2-stream" && ht_rxstbc="[RX-STBC12]"
  contains "$phyinfo" "RX STBC 1-stream" && ht_rxstbc="[RX-STBC1]"

  log "generating configuration..."
  [ -n "$allow_n" ] && enable_80211n="ieee80211n=1" && ht20="[HT20]"
  if [ -n "$allow_ac" ]; then
    [ "$width" = 80 ] && enable_80211ac="ieee80211ac=1"
    contains "$phyinfo" "Maximum RX AMPDU length 16383 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP1]"
    contains "$phyinfo" "Maximum RX AMPDU length 32767 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP2]"
    contains "$phyinfo" "Maximum RX AMPDU length 65535 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP3]"
    contains "$phyinfo" "Maximum RX AMPDU length 131071 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP4]"
    contains "$phyinfo" "Maximum RX AMPDU length 262143 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP5]"
    contains "$phyinfo" "Maximum RX AMPDU length 524287 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP6]"
    contains "$phyinfo" "Maximum RX AMPDU length 1048575 bytes" && ampdu="[MAX-A-MPDU-LEN-EXP7]"
  fi
  [ -n "$allow_ab$allow_g" ] || require_ht="require_ht=1"
  [ -n "$allow_ab$allow_g$allow_n" ] || require_vht="require_vht=1"
  case $crypto in
    WPA_PSK_*) auth_algs=1; wpa=1 ;;
    WPA2_PSK_*) auth_algs=1; wpa=2 ;;
    WPA12_PSK_*) auth_algs=1; wpa=3 ;;
    WEP) auth_algs=3; wpa=0 ;;
    NONE) auth_algs=1; wpa=0 ;;
    *) die "invalid crypto protocol in '$crypto'" ;;
  esac
  case $crypto in
    *_AES) wpa_pairwise=CCMP ;;
    *_TKIP) wpa_pairwise=TKIP ;;
    WEP|NONE) wpa_pairwise=CCMP ;;
    *) die "invalid crypto alg in '$crypto'" ;;
  esac
  if [ "$width" -ge 40 ]; then
    if contains_item "$HT_DIRECTIONS" "$channel+"; then
      ht40="[HT40+]"
    elif contains_item "$HT_DIRECTIONS" "$channel-"; then
      ht40="[HT40-]"
    else
      die "HT40 requested but not available on channel $channel."
    fi
  fi
  if [ "$width" = 80 ]; then
    ldpc="[RXLDPC]"
    vht_base=
    for i in $VHT_BASES; do
      if startswith "$i" "$channel="; then
        vht_base="${i#$channel=}"
        break
      fi
    done
    if [ -n "$vht_base" ]; then
      vht_settings=$(cat <<-EOF
	vht_capab=$ampdu$vht_guard_interval$ldpc
	vht_oper_chwidth=1

	# Wifi channel numbers define the center of a 20 MHz
	# channel.  40 MHz channels are defined as one channel plus
	# the next one 4 up.  80 MHz channels go back to defining by
	# center.  If you think about it long enough, you eventually
	# discover that the center is 6 channels up from the base 20
	# MHz channel, although this isn't very intuitive.
	vht_oper_centr_freq_seg0_idx=$(($vht_base + 6))
	EOF
      )
    else
      die "VHT80 requested but not available on channel $channel."
    fi
  fi
  setupvdev=
  if is-network-box; then
    if [ "$ifc" = "wlan0" ]; then
      bssid=$(hnvram -qr MAC_ADDR_WIFI)
    else
      bssid=$(hnvram -qr MAC_ADDR_WIFI2)
    fi

    if [ -z "$bssid" ]; then
      bssid=$(hnvram -rq MAC_ADDR)
      if [ -z "$bssid" ]; then
        echo "$0: WARNING: Box has no MAC_ADDR nor MAC_ADDR_WIFI(2)"
        # should not happen, but hardcode one for extreme case.
        bssid="f8:8f:ca:80:11:22"
      fi
    fi

    if experiment AutoSetupSSID; then
      bssidtv=$(mac_addr_increment "$bssid" 4)
      bssidsetup=$(mac_addr_increment "$bssid" 5)
      setupvdev=$(cat <<-EOF
	bss=$ifc.tv
	bssid=$bssidtv
	ssid=${ssid}tv
	auth_algs=$auth_algs
	wpa=$wpa
	wpa_passphrase=$psk
	wpa_key_mgmt=WPA-PSK
	wpa_pairwise=$wpa_pairwise

	bss=$ifc.setup
	bssid=$bssidsetup
	ssid=${ifc}setup
	auth_algs=$auth_algs
	wpa=$wpa
	wpa_passphrase=$RGSETUPPSK
	wpa_key_mgmt=WPA-PSK
	wpa_pairwise=$wpa_pairwise
	EOF
      )
    fi
  fi
  hostconf=$(cat <<-EOF
	ctrl_interface=/var/run/hostapd
	interface=$ifc
	bridge=$bridge
	ssid=$ssid
	auth_algs=$auth_algs
	wpa=$wpa
	wpa_passphrase=$psk
	wpa_key_mgmt=WPA-PSK
	wpa_pairwise=$wpa_pairwise
	hw_mode=$hostapd_band
	channel=$channel
	country_code=US
	ieee80211d=1
	ieee80211h=1
	$enable_80211n
	$enable_80211ac
	$enable_wmm
	$require_ht
	$require_vht
	$hidden

	$setupvdev

	ht_capab=$ht20$ht40$guard_interval$ht_rxstbc
	$vht_settings
	EOF
  )
  if [ -n "$extra_short_timeouts" ]; then
    hostconf=$(cat <<-EOF
	$hostconf

	# Obnoxiously short rekey intervals to maximize the chance of discovering
	# bugs caused by rekeying at inopportune times.
	wep_rekey_period=10
	wpa_group_rekey=10
	wpa_strict_rekey=1
	wpa_gmk_rekey=9
	wpa_ptk_rekey=10
	EOF
    )
  fi
  log "configuration ready."
  iw_maybe_restart_hostapd "$ifc" "$hostconf"
else
  die "No wifi runtime found."
fi
