#!/bin/sh
#
# This script monitors /tmp/gpio/ledcontrol and decides which is the
# led sequence that should be used to indicate the current system status.
#
. /etc/utils.sh

OUT="/tmp/gpio"
IN="/tmp/gpio/ledcontrol"

# LED sequences
OFF="0"
PURPLE="5"
SOLID_RED="1"
SLOW_RED="x4 1 0"
SOLID_BLUE="4"
FAST_BLUE="4 0 4 0 4 0"
SLOW_BLUE="x2 4 0"

change_state() {
  # Check if the new state is different from the previous one
  if [ ! -e /tmp/gpio/ledstate ] || [ "$last_ledstate" != "$1" ]; then
    leds $2
    last_leds="$2"
    atomic /tmp/gpio/ledstate "$1"
    last_ledstate="$1"
    echo "state changed to: $last_ledstate $last_leds"
  fi
}

is_interface_up() {
  [ -n "$(ip link show $1 2>/dev/null | grep LOWER_UP)" ]
}

has_ip_address() {
  [ -n "$(ip -f inet6 addr show dev $1 scope global 2>/dev/null)" ] ||
    [ -n "$(ip -f inet addr show dev $1 scope global 2>/dev/null)" ]
}

is_link_up() {
  if interface_exists wan0; then
    # If there is an explicit WAN link, use that.
    is_interface_up wan0
  elif is-tv-box; then
    # Otherwise for TV Boxes, any interface could be upstream.
    is_interface_up eth0 ||
    is_interface_up eth1 ||
    is_interface_up moca0 ||
    is_interface_up wcli0
  elif is-storage-box; then
    # For storage boxes (the ones that don't have a wan0), the MoCA
    # link should never be upstream, so count only the ethernet.
    is_interface_up eth0
  elif is-ptp; then
    is_interface_up eth0 ||
    is_interface_up eth1
  else
    echo "Unknown device type; assuming link is down." >&2
    false
  fi
}

is_manufactured_recently() {
  if [ ! "$is_manufactured_recently_status" ]; then
    platform=$(cat /etc/platform)
    if [ "$platform" != GFHD100 ] && [ "$platform" != GFMS100 ]; then
      is_manufactured_recently_status=0
    else
      # Check if the device is made within or after 2013.
      serial=$(serial)

      # Serial number format: GABCYWWSSSSS.
      # Check if the serial number matches this format (starting from G)
      # and YWWSSSSS >= 30000000
      date_manufactured=${serial#G???}
      [ "$serial" != "$date_manufactured" ] && [ "$date_manufactured" -ge 30000000 ]
      is_manufactured_recently_status=$?
    fi
  fi
  return $is_manufactured_recently_status
}

{ echo; watch-dir "$IN"; } |
while read f; do
  if is_link_up; then
    rm -f "$OUT/link_down"
    if interface_exists wan0; then
      ifs="wan0 wan0.2"
    else
      ifs="br0"
    fi
    success=
    for ifname in $ifs; do
      if has_ip_address $ifname; then
        success="IP address acquired on $ifname"
        break
      fi
    done
    if [ -n "$success" ]; then
      atomic "$OUT/ipconnected" "$success"
    else
      rm -f "$IN/acsconnected" "$OUT/ipconnected"
    fi
  else
    atomic "$OUT/link_down" "Link down"
    rm -f "$IN/acsconnected" "$OUT/ipconnected"
  fi

  if is_manufactured_recently &&
     [ ! -f "$IN/secure_boot" ] &&
     [ ! -e "/config/IGNORE_UNSECURE" ]; then
    change_state UNSECUREBOOT "$PURPLE"
  elif [ -f "$IN/halted" ]; then
    change_state HALT "$SOLID_RED"
  elif [ -f "$IN/invalid_keybox" -a ! -f /rw/ignore-bad-keybox ]; then
    change_state INVALID_KEYBOX "$SOLID_RED"
  elif [ -f "$IN/overtemperature" ]; then
    change_state OVERTEMP "$SOLID_RED"
  elif [ -f "$IN/hdd_bad_pair" ]; then
    change_state HDPAIR_FAIL "$SOLID_RED"
  elif [ -f "$IN/hdd_mount_err" ]; then
    change_state HDMOUNT_FAIL "$SOLID_RED"
  elif [ -f "$IN/flash_bad_blocks" ]; then
    change_state BADBLOCK "$SOLID_RED"
  elif [ -f "$IN/waitpower" ]; then
    change_state POWEROFF "$OFF"
  elif [ -f "$OUT/link_down" ]; then
    change_state LINKDOWN "$SLOW_RED"
  elif [ ! -f "$OUT/ipconnected" ]; then
    change_state NOIP "$SLOW_BLUE"           # progress: link but no ip
  elif [ ! -f "$IN/acsconnected" ]; then
    change_state IPV6ACQUIRED "$FAST_BLUE"   # progress: ip but no acs
  else
    change_state ACSCONTACT "$SOLID_BLUE"    # success!
  fi
done
