#!/bin/sh
# SUBSYSTEM, ACTION, DEVPATH, and FIRMWARE are all provided by the kernel
# when this script is started.
exec >/dev/kmsg 2>&1

. /etc/utils.sh


create_client_interface() {
  local interface="$1"
  local wlan_mac=$(cat /sys/class/net/"$interface"/address)
  local mac=$(mac_addr_increment "$wlan_mac" 1)
  local client_interface=$(echo "$interface" | sed s/^wlan/wcli/)
  if ! interface_exists "$client_interface"; then
    if is_quantenna_interface "$interface"; then
      ip link add link quantenna name "$client_interface" type vlan id 2
      mac=$(get_locally_administered_mac_addr "$mac")
    else
      local phy=$(find_phy_for_interface "$interface")
      iw phy "$phy" interface add "$client_interface" type station
    fi
    ip link set dev "$client_interface" address "$mac"
  fi
  # Disable IPv6 autoconfiguration of the interface, which breaks gftests.
  # accept_ra means "Accept Router Advertisements, and autoconfigure this
  # interface with received data."; disabling this prevents the problematic
  # autoconfiguration of routes.
  # TODO(rofrankel):  Find a way not to need to disable this, e.g. by making it
  # so that autoconfigured br0 routes have a lower metric than wcli* routes.
  echo 0 >/proc/sys/net/ipv6/conf/wcli0/accept_ra
}

load_firmware() {
  echo "Trying firmware '$1'" &&
  [ -r "$1" ] &&
  echo 1 >/sys/$DEVPATH/loading &&
  cat "$1" >/sys/$DEVPATH/data &&
  echo 0 >/sys/$DEVPATH/loading &&
  echo "  ...loaded firmware '$1'"
}

print_ath10k_cal_hash() {
  local checks=0
  local ath10k_cal=/sys/kernel/debug/ieee80211/phy1/ath10k/cal_data
  local ath10k_cal_tmp=/tmp/ath10k_cal_data
  while :; do
    cat "$ath10k_cal" >"$ath10k_cal_tmp" 2>/dev/null
    if [ -s "$ath10k_cal_tmp" ]; then
      break
    fi
    checks=$((checks + 1))
    if [ "$checks" -gt 100 ]; then
       echo "Unable to fetch ath10k calibration data" >&2
       return
    fi
    sleep 0.1
  done
  # Print ath10k cal_data sha1 to logs.
  echo "ath10k cal_data sha1sum: $(sha1sum $ath10k_cal_tmp | cut -d " " -f1)"
  rm -f "$ath10k_cal_tmp"
}

case "$SUBSYSTEM-$ACTION" in
  input-add)
    # BlueZ: adjust repeat speed on remotes
    if [ -c "/dev/$DEVNAME" ]; then
      echo "hotplug: setting autorepeat on $DEVNAME"
      input-repeat -f "/dev/$DEVNAME" -d 600
      # Allow user to access input device
      chmod 666 "/dev/$DEVNAME"
    fi
    ;;

  bluetooth-add)
    # BlueZ: Configure hci0 interface link mode
    hcidev=${DEVPATH##*/}
    if [ "$hcidev" = "hci0" ]; then
      echo "hotplug: configuring $hcidev"
      hciconfig "$hcidev" lm ACCEPT,MASTER
    fi
    ;;

  hidraw-add)
    if [ -c "/dev/$DEVNAME" ]; then
      echo "Trying gfrm100-rcu-audio for $DEVNAME"
      # Allow user to access input device
      chmod 666 "/dev/$DEVNAME"
      # gfrm100-rcu-audio will exit if not a GFRM100 or daemonize itself
      # if it is, so we run it in the foreground. The timeout is for
      # safety to not hang the hotplug script, just in case.
      timeout 5 setuid appclient:video gfrm100-rcu-audio "/dev/$DEVNAME" 2>&1 | logos "gfrm100_audio"
    fi
    ;;

  firmware-add)
    echo "hotplug: sys=$SUBSYSTEM act=$ACTION fw=$FIRMWARE dev=$DEVPATH"
    register_experiment RwFirmware
    if experiment RwFirmware; then
      load_firmware "/rw/firmware/$FIRMWARE" ||
      load_firmware "/rw/firmware/$(basename "$FIRMWARE")"
    else
      false  # fall back
    fi ||
    load_firmware "/lib/firmware/$FIRMWARE" ||
    echo -1 >"/sys/$DEVPATH/loading"
    ;;

  net-add)
    # At boot or device reset, a net add event is delivered for the primary
    # interface. Use this event to create a client interface, which is
    # created in user space unlike the primary interface.
    if startswith "$INTERFACE" "wlan"; then
      if is-wireless-client; then
        create_client_interface "$INTERFACE"
      fi
      if contains "GFRG200 GFRG210" "$(cat /etc/platform)" &&
        [ "$INTERFACE" = "wlan1" ]; then
        print_ath10k_cal_hash &
      fi
    fi
    ;;
esac

# DirectFB apps listen for an AF_UNIX message for hotplug events, which
# dfb_input_hotplug sends using the ACTION and DEVPATH in the environment.
if [ "$SUBSYSTEM" = "input" ] && [ "$ACTION" = "add" -o "$ACTION" = "remove" ]; then
  for dir in /usr/local/bin/directfb/* ; do
    if [ -d "$dir" ]; then
      export PATH="$PATH":"$dir"
    fi
  done
  if runnable dfb_input_hotplug; then
    dfb_input_hotplug
  fi
fi
